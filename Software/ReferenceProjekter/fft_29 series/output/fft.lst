    0000: 80 67    JMP   0x0068
    0002: 30       HALT  
    0003: 30       HALT  
FILE: .\boot.asm
(0001) ; Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0002) ;
(0003) ;@Id: boot.tpl#102 @
(0004) ;=============================================================================
(0005) ;  FILENAME:   boot.asm
(0006) ;  VERSION:    4.16
(0007) ;  DATE:       6 October 2005
(0008) ;
(0009) ;  DESCRIPTION:
(0010) ;  M8C Boot Code for CY8C29xxx microcontroller family.
(0011) ;
(0012) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
(0013) ;
(0014) ; NOTES:
(0015) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
(0016) ; the project's root directory to create BOOT.ASM. Any changes made to
(0017) ; BOOT.ASM will be  overwritten every time the project is generated; therfore
(0018) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
(0019) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
(0020) ; are not accidentally modified.
(0021) ;
(0022) ;=============================================================================
(0023) 
(0024) include ".\lib\GlobalParams.inc"
(0025) include "m8c.inc"
(0026) include "m8ssc.inc"
(0027) include "memory.inc"
(0028) 
(0029) ;--------------------------------------
(0030) ; Export Declarations
(0031) ;--------------------------------------
(0032) 
(0033) export __Start
(0034) export __bss_start
(0035) export __data_start
(0036) export __idata_start
(0037) export __func_lit_start
(0038) export __text_start
(0039) export  _bGetPowerSetting
(0040) export   bGetPowerSetting
(0041) 
(0042) 
(0043) ;--------------------------------------
(0044) ; Optimization flags
(0045) ;--------------------------------------
(0046) ;
(0047) ; To change the value of these flags, modify the file boot.tpl, not
(0048) ; boot.asm. See the notes in the banner comment at the beginning of
(0049) ; this file.
(0050) 
(0051) ; Optimization for Assembly language (only) projects and C-language projects
(0052) ; that do not depend on the C compiler to initialize the values of RAM variables.
(0053) ;   Set to 1: Support for C Run-time Environment initialization
(0054) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
(0055) ;
(0056) C_LANGUAGE_SUPPORT:              equ 1
(0057) 
(0058) 
(0059) ; The following equate is required for proper operation. Reseting its value
(0060) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
(0061) ; selected.  If the designer chooses to not wait then stabilization of the ECO
(0062) ; and PLL_Lock must take place within user code. See the family data sheet for
(0063) ; the requirements of starting the ECO and PLL lock mode.
(0064) ;
(0065) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
(0066) ;                invoking main
(0067) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
(0068) ;               the time code in main starts executing.
(0069) ;
(0070) WAIT_FOR_32K:                    equ 1
(0071) 
(0072) 
(0073) ; For historical reasons, by default the boot code uses an lcall instruction
(0074) ; to invoke the user's _main code. If _main executes a return instruction,
(0075) ; boot provides an infinite loop. By changing the following equate from zero
(0076) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
(0077) ; bytes on the stack which are otherwise required for the return address. If
(0078) ; this option is enabled, _main must not return. (Beginning with the 4.2
(0079) ; release, the C compiler automatically places an infinite loop at the end
(0080) ; of main, rather than a return instruction.)
(0081) ;
(0082) ENABLE_LJMP_TO_MAIN:             equ 0
(0083) 
(0084) 
(0085) ;-----------------------------------------------------------------------------
(0086) ; Interrupt Vector Table
(0087) ;-----------------------------------------------------------------------------
(0088) ;
(0089) ; Interrupt vector table entries are 4 bytes long.  Each one contains
(0090) ; a jump instruction to an ISR (Interrupt Service Routine), although
(0091) ; very short ISRs could be encoded within the table itself. Normally,
(0092) ; vector jump targets are modified automatically according to the user
(0093) ; modules selected. This occurs when the 'Generate Application' opera-
(0094) ; tion is run causing PSoC Designer to create boot.asm and the other
(0095) ; configuration files. If you need to hard code a vector, update the
(0096) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
(0097) ; of this file.
(0098) ;-----------------------------------------------------------------------------
(0099) 
(0100)     AREA TOP (ROM, ABS, CON)
(0101) 
(0102)     org   0                        ;Reset Interrupt Vector
(0103)     jmp   __Start                  ;First instruction executed following a Reset
(0104) 
(0105)     org   04h                      ;Supply Monitor Interrupt Vector
(0106)     halt                           ;Stop execution if power falls too low
    0004: 30       HALT  
    0005: 30       HALT  
    0006: 30       HALT  
    0007: 30       HALT  
(0107) 
(0108)     org   08h                      ;Analog Column 0 Interrupt Vector
(0109)     // call	void_handler
(0110)     reti
    0008: 7E       RETI  
    0009: 30       HALT  
    000A: 30       HALT  
    000B: 30       HALT  
(0111) 
(0112)     org   0Ch                      ;Analog Column 1 Interrupt Vector
(0113)     // call	void_handler
(0114)     reti
    000C: 7E       RETI  
    000D: 30       HALT  
    000E: 30       HALT  
    000F: 30       HALT  
(0115) 
(0116)     org   10h                      ;Analog Column 2 Interrupt Vector
(0117)     // call	void_handler
(0118)     reti
    0010: 7E       RETI  
    0011: 30       HALT  
    0012: 30       HALT  
    0013: 30       HALT  
(0119) 
(0120)     org   14h                      ;Analog Column 3 Interrupt Vector
(0121)     // call	void_handler
(0122)     reti
    0014: 7E       RETI  
    0015: 30       HALT  
    0016: 30       HALT  
    0017: 30       HALT  
(0123) 
(0124)     org   18h                      ;VC3 Interrupt Vector
(0125)     // call	void_handler
(0126)     reti
    0018: 7E       RETI  
    0019: 30       HALT  
    001A: 30       HALT  
    001B: 30       HALT  
(0127) 
(0128)     org   1Ch                      ;GPIO Interrupt Vector
(0129)     // call	void_handler
(0130)     reti
    001C: 7E       RETI  
    001D: 30       HALT  
    001E: 30       HALT  
    001F: 30       HALT  
(0131) 
(0132)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
(0133)     // call	void_handler
(0134)     reti
    0020: 7E       RETI  
    0021: 30       HALT  
    0022: 30       HALT  
    0023: 30       HALT  
(0135) 
(0136)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
(0137)     // call	void_handler
(0138)     reti
    0024: 7E       RETI  
    0025: 30       HALT  
    0026: 30       HALT  
    0027: 30       HALT  
(0139) 
(0140)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
(0141)     ljmp	_UART_1_TX_ISR
    0028: 7D 03 AA LJMP  0x03AA
(0142)     reti
    002B: 7E       RETI  
(0143) 
(0144)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
(0145)     ljmp	_UART_1_RX_ISR
    002C: 7D 03 AB LJMP  0x03AB
(0146)     reti
    002F: 7E       RETI  
(0147) 
(0148)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
(0149)     ljmp	_DELSIG11_1_ADConversion_ISR
    0030: 7D 07 C2 LJMP  0x07C2
(0150)     reti
    0033: 7E       RETI  
(0151) 
(0152)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
(0153)     // call	void_handler
(0154)     reti
    0034: 7E       RETI  
    0035: 30       HALT  
    0036: 30       HALT  
    0037: 30       HALT  
(0155) 
(0156)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
(0157)     // call	void_handler
(0158)     reti
    0038: 7E       RETI  
    0039: 30       HALT  
    003A: 30       HALT  
    003B: 30       HALT  
(0159) 
(0160)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
(0161)     // call	void_handler
(0162)     reti
    003C: 7E       RETI  
    003D: 30       HALT  
    003E: 30       HALT  
    003F: 30       HALT  
(0163) 
(0164)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
(0165)     // call	void_handler
(0166)     reti
    0040: 7E       RETI  
    0041: 30       HALT  
    0042: 30       HALT  
    0043: 30       HALT  
(0167) 
(0168)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
(0169)     // call	void_handler
(0170)     reti
    0044: 7E       RETI  
    0045: 30       HALT  
    0046: 30       HALT  
    0047: 30       HALT  
(0171) 
(0172)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
(0173)     // call	void_handler
(0174)     reti
    0048: 7E       RETI  
    0049: 30       HALT  
    004A: 30       HALT  
    004B: 30       HALT  
(0175) 
(0176)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
(0177)     // call	void_handler
(0178)     reti
    004C: 7E       RETI  
    004D: 30       HALT  
    004E: 30       HALT  
    004F: 30       HALT  
(0179) 
(0180)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
(0181)     // call	void_handler
(0182)     reti
    0050: 7E       RETI  
    0051: 30       HALT  
    0052: 30       HALT  
    0053: 30       HALT  
(0183) 
(0184)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
(0185)     // call	void_handler
(0186)     reti
    0054: 7E       RETI  
    0055: 30       HALT  
    0056: 30       HALT  
    0057: 30       HALT  
(0187) 
(0188)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
(0189)     // call	void_handler
(0190)     reti
    0058: 7E       RETI  
    0059: 30       HALT  
    005A: 30       HALT  
    005B: 30       HALT  
(0191) 
(0192)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
(0193)     // call	void_handler
(0194)     reti
    005C: 7E       RETI  
    005D: 30       HALT  
    005E: 30       HALT  
    005F: 30       HALT  
(0195) 
(0196)     org   60h                      ;PSoC I2C Interrupt Vector
(0197)     // call	void_handler
(0198)     reti
    0060: 7E       RETI  
    0061: 30       HALT  
    0062: 30       HALT  
    0063: 30       HALT  
(0199) 
(0200)     org   64h                      ;Sleep Timer Interrupt Vector
(0201)     // call	void_handler
(0202)     reti
    0064: 7E       RETI  
    0065: 30       HALT  
    0066: 30       HALT  
    0067: 30       HALT  
(0203) 
(0204) ;-----------------------------------------------------------------------------
(0205) ;  Start of Execution.
(0206) ;-----------------------------------------------------------------------------
(0207) ;  The Supervisory ROM SWBootReset function has already completed the
(0208) ;  calibrate1 process, loading trim values for 5 volt operation.
(0209) ;
(0210)     org 68h
(0211) __Start:
(0212) 
(0213)     ; initialize SMP values for voltage stabilization, if required,
(0214)     ; leaving power-on reset (POR) level at the default (low) level, at
(0215)     ; least for now. 
(0216)     ;
(0217)     M8C_SetBank1
    0068: 71 10    OR    F,16
(0218)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
    006A: 62 E3 87 MOV   REG[227],135
(0219)     M8C_SetBank0
    006D: 70 EF    AND   F,239
(0220) 
(0221)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
(0222)     mov   A, 20h
    006F: 50 20    MOV   A,32
(0223)     romx
    0071: 28       ROMX  
(0224)     mov   A, 40h
    0072: 50 40    MOV   A,64
(0225)     romx
    0074: 28       ROMX  
(0226)     mov   A, 60h
    0075: 50 60    MOV   A,96
(0227)     romx
    0077: 28       ROMX  
(0228)     ; %45%20%46%46% End workaround
(0229) 
(0230) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
(0231)     M8C_EnableWatchDog
(0232) ENDIF
(0233) 
(0234) IF ( SELECT_32K )
(0235)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
(0236) ELSE
(0237)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
    0078: 41 FE FB AND   REG[254],251
(0238) ENDIF
(0239) 
(0240)     ;---------------------------
(0241)     ; Set up the Temporary stack
(0242)     ;---------------------------
(0243)     ; A temporary stack is set up for the SSC instructions.
(0244)     ; The real stack start will be assigned later.
(0245)     ;
(0246) _stack_start:          equ 80h
(0247)     mov   A, _stack_start          ; Set top of stack to end of used RAM
    007B: 50 80    MOV   A,128
(0248)     swap  SP, A                    ; This is only temporary if going to LMM
    007D: 4E       SWAP  SP,A
(0249) 
(0250)     ;-----------------------------------------------
(0251)     ; Set Power-related Trim & the AGND Bypass bit.
(0252)     ;-----------------------------------------------
(0253) 
(0254) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
(0255)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
(0256)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
(0257)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
(0258)  ELSE                                          ; *** 12MHZ Main Oscillator ***
(0259)   IF ( AGND_BYPASS )
(0260)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(0261)     ; The 5V trim has already been set, but we need to update the AGNDBYP
(0262)     ; bit in the write-only BDG_TR register. Recalculate the register
(0263)     ; value using the proper trim values.
(0264)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(0265)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
(0266)   ENDIF
(0267)  ENDIF
(0268) ENDIF ; 5.0 V Operation
(0269) 
(0270) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
(0271)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
(0272)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
(0273)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
(0274)  ELSE                                          ; *** 12MHZ Main Oscillator ***
(0275)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
(0276)  ENDIF
(0277) ENDIF ; 3.3 Volt Operation
(0278) 
(0279)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
    007E: 55 F8 00 MOV   [248],0
(0280)     mov  [bSSC_KEYSP], 0
    0081: 55 F9 00 MOV   [249],0
(0281) 
(0282)     ;---------------------------------------
(0283)     ; Initialize Crystal Oscillator and PLL
(0284)     ;---------------------------------------
(0285) 
(0286) IF ( SELECT_32K & WAIT_FOR_32K )
(0287)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
(0288)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
(0289)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
(0290)     ; the ECO to stabilize.
(0291)     ;
(0292)     M8C_SetBank1
(0293)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
(0294)     M8C_SetBank0
(0295)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
(0296)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
(0297)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
(0298) .WaitFor1s:
(0299)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
(0300)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
(0301)                                           ;   since interrupts are not globally enabled
(0302) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
(0303)     ; Either no ECO, or waiting for stable clock is to be done in main
(0304)     M8C_SetBank1
    0084: 71 10    OR    F,16
(0305)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
    0086: 62 E0 02 MOV   REG[224],2
(0306)     M8C_SetBank0
    0089: 70 EF    AND   F,239
(0307)     M8C_ClearWDTAndSleep           ; Reset the watch dog
    008B: 62 E3 38 MOV   REG[227],56
(0308) 
(0309) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
(0310) 
(0311) IF ( PLL_MODE )
(0312)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
(0313)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
(0314)     ;
(0315)     M8C_SetBank1
(0316)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
(0317)     M8C_SetBank0
(0318)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
(0319)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
(0320) 
(0321) .WaitFor16ms:
(0322)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
(0323)     jz   .WaitFor16ms
(0324)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
(0325)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
(0326)     M8C_SetBank0
(0327) 
(0328) IF      ( WAIT_FOR_32K )
(0329) ELSE ; !( WAIT_FOR_32K )
(0330)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
(0331)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
(0332) ENDIF ;(WAIT_FOR_32K)
(0333) ENDIF ;(PLL_MODE)
(0334) 
(0335)     ;------------------------
(0336)     ; Close CT leakage path.
(0337)     ;------------------------
(0338)     mov   reg[ACB00CR0], 05h
    008E: 62 71 05 MOV   REG[113],5
(0339)     mov   reg[ACB01CR0], 05h
    0091: 62 75 05 MOV   REG[117],5
(0340)     mov   reg[ACB02CR0], 05h
    0094: 62 79 05 MOV   REG[121],5
(0341)     mov   reg[ACB03CR0], 05h
    0097: 62 7D 05 MOV   REG[125],5
(0342) 
(0343)     ;---------------------------------------------
(0344)     ; Enter the Large Memory Model, if applicable
(0345)     ;---------------------------------------------
(0346) IF ( SYSTEM_LARGE_MEMORY_MODEL )
(0347)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
    009A: 62 D1 07 MOV   REG[209],7
(0348)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
    009D: 50 01    MOV   A,1
(0349)     swap  A, SP
    009F: 4E       SWAP  SP,A
(0350)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
    00A0: 62 D3 07 MOV   REG[211],7
(0351)     RAM_SETPAGE_CUR 0
    00A3: 62 D0 00 MOV   REG[208],0
(0352)     RAM_SETPAGE_MVW 0
    00A6: 62 D5 00 MOV   REG[213],0
(0353)     RAM_SETPAGE_MVR 0
    00A9: 62 D4 00 MOV   REG[212],0
(0354) 
(0355)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
(0356)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
    00AC: 71 C0    OR    F,192
(0357)   ELSE
(0358)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
(0359)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
(0360) ELSE
(0361)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
(0362)     swap  SP, A
(0363) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
(0364) 
(0365)     ;-------------------------
(0366)     ; Load Base Configuration
(0367)     ;-------------------------
(0368)     ; Load global parameter settings and load the user modules in the
(0369)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
(0370)     ; to minimize start up time; (2) We may still need to play with the
(0371)     ; Sleep Timer.
(0372)     ;
(0373)     lcall LoadConfigInit
    00AE: 7C 03 41 LCALL 0x0341
(0374) 
(0375)     ;-----------------------------------
(0376)     ; Initialize C Run-Time Environment
(0377)     ;-----------------------------------
(0378) IF ( C_LANGUAGE_SUPPORT )
(0379) IF ( SYSTEM_SMALL_MEMORY_MODEL )
(0380)     mov  A,0                           ; clear the 'bss' segment to zero
(0381)     mov  [__r0],<__bss_start
(0382) BssLoop:
(0383)     cmp  [__r0],<__bss_end
(0384)     jz   BssDone
(0385)     mvi  [__r0],A
(0386)     jmp  BssLoop
(0387) BssDone:
(0388)     mov  A,>__idata_start              ; copy idata to data segment
(0389)     mov  X,<__idata_start
(0390)     mov  [__r0],<__data_start
(0391) IDataLoop:
(0392)     cmp  [__r0],<__data_end
(0393)     jz   C_RTE_Done
(0394)     push A
(0395)     romx
(0396)     mvi  [__r0],A
(0397)     pop  A
(0398)     inc  X
(0399)     adc  A,0
(0400)     jmp  IDataLoop
(0401) 
(0402) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
(0403) 
(0404) IF ( SYSTEM_LARGE_MEMORY_MODEL )
(0405)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
    00B1: 62 D0 00 MOV   REG[208],0
(0406)                                        ; to use the Virtual Register page.
(0407) 
(0408)     ; Dereference the constant (flash) pointer pXIData to access the start
(0409)     ; of the extended idata area, "xidata." Xidata follows the end of the
(0410)     ; text segment and may have been relocated by the Code Compressor.
(0411)     ;
(0412)     mov   A, >__pXIData                ; Get the address of the flash
    00B4: 50 03    MOV   A,3
(0413)     mov   X, <__pXIData                ;   pointer to the xidata area.
    00B6: 57 3F    MOV   X,63
(0414)     push  A
    00B8: 08       PUSH  A
(0415)     romx                               ; get the MSB of xidata's address
    00B9: 28       ROMX  
(0416)     mov   [__r0], A
    00BA: 53 1B    MOV   [__r0],A
(0417)     pop   A
    00BC: 18       POP   A
(0418)     inc   X
    00BD: 75       INC   X
(0419)     adc   A, 0
    00BE: 09 00    ADC   A,0
(0420)     romx                               ; get the LSB of xidata's address
    00C0: 28       ROMX  
(0421)     swap  A, X
    00C1: 4B       SWAP  A,X
(0422)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
    00C2: 51 1B    MOV   A,[27]
(0423)                                        ;   XIData structure list in flash
(0424)     jmp   .AccessStruct
    00C4: 80 04    JMP   0x00C9
(0425) 
(0426)     ; Unpack one element in the xidata "structure list" that specifies the
(0427)     ; values of C variables. Each structure contains 3 member elements.
(0428)     ; The first is a pointer to a contiguous block of RAM to be initial-
(0429)     ; ized. Blocks are always 255 bytes or less in length and never cross
(0430)     ; RAM page boundaries. The list terminates when the MSB of the pointer
(0431)     ; contains 0xFF. There are two formats for the struct depending on the
(0432)     ; value in the second member element, an unsigned byte:
(0433)     ; (1) If the value of the second element is non-zero, it represents
(0434)     ; the 'size' of the block of RAM to be initialized. In this case, the
(0435)     ; third member of the struct is an array of bytes of length 'size' and
(0436)     ; the bytes are copied to the block of RAM.
(0437)     ; (2) If the value of the second element is zero, the block of RAM is
(0438)     ; to be cleared to zero. In this case, the third member of the struct
(0439)     ; is an unsigned byte containing the number of bytes to clear.
(0440) 
(0441) .AccessNextStructLoop:
(0442)     inc   X                            ; pXIData++
    00C6: 75       INC   X
(0443)     adc   A, 0
    00C7: 09 00    ADC   A,0
(0444) .AccessStruct:                         ; Entry point for first block
(0445)     ;
(0446)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
(0447)     ;
(0448)     M8C_ClearWDT                       ; Clear the watchdog for long inits
    00C9: 62 E3 00 MOV   REG[227],0
(0449)     push  A
    00CC: 08       PUSH  A
(0450)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
    00CD: 28       ROMX  
(0451)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
    00CE: 60 D5    MOV   REG[213],A
(0452)     inc   A                            ; End of Struct List? (MSB==0xFF?)
    00D0: 74       INC   A
(0453)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
    00D1: A0 4B    JZ    0x011D
(0454)     pop   A                            ; restore pXIData to [A,X]
    00D3: 18       POP   A
(0455)     inc   X                            ; pXIData++
    00D4: 75       INC   X
(0456)     adc   A, 0
    00D5: 09 00    ADC   A,0
(0457)     push  A
    00D7: 08       PUSH  A
(0458)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
    00D8: 28       ROMX  
(0459)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
    00D9: 53 1B    MOV   [__r0],A
(0460)     pop   A                            ; restore pXIData to [A,X]
    00DB: 18       POP   A
(0461)     inc   X                            ; pXIData++ (point to size)
    00DC: 75       INC   X
(0462)     adc   A, 0
    00DD: 09 00    ADC   A,0
(0463)     push  A
    00DF: 08       PUSH  A
(0464)     romx                               ; Get the size (CPU.A <- *pXIData)
    00E0: 28       ROMX  
(0465)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
    00E1: A0 1C    JZ    0x00FE
(0466)     mov   [__r1], A                    ;             else downcount in __r1
    00E3: 53 1A    MOV   [__r1],A
(0467)     pop   A                            ; restore pXIData to [A,X]
    00E5: 18       POP   A
(0468) 
(0469) .CopyNextByteLoop:
(0470)     ; For each byte in the structure's array member, copy from flash to RAM.
(0471)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
(0472)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
(0473)     ;         __r1 holds a non-zero count of the number of bytes remaining.
(0474)     ;
(0475)     inc   X                            ; pXIData++ (point to next data byte)
    00E6: 75       INC   X
(0476)     adc   A, 0
    00E7: 09 00    ADC   A,0
(0477)     push  A
    00E9: 08       PUSH  A
(0478)     romx                               ; Get the data value (CPU.A <- *pXIData)
    00EA: 28       ROMX  
(0479)     mvi   [__r0], A                    ; Transfer the data to RAM
    00EB: 3F 1B    MVI   [__r0],A
(0480)     tst   [__r0], 0xff                 ; Check for page crossing
    00ED: 47 1B FF TST   [27],255
(0481)     jnz   .CopyLoopTail                ;   No crossing, keep going
    00F0: B0 06    JNZ   0x00F7
(0482)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
    00F2: 5D D5    MOV   A,REG[213]
(0483)     inc   A
    00F4: 74       INC   A
(0484)     mov   reg[ MVW_PP], A
    00F5: 60 D5    MOV   REG[213],A
(0485) .CopyLoopTail:
(0486)     pop   A                            ; restore pXIData to [A,X]
    00F7: 18       POP   A
(0487)     dec   [__r1]                       ; End of this array in flash?
    00F8: 7A 1A    DEC   [__r1]
(0488)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
    00FA: BF EB    JNZ   0x00E6
(0489)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
    00FC: 8F C9    JMP   0x00C6
(0490) 
(0491) .ClearRAMBlockToZero:
(0492)     pop   A                            ; restore pXIData to [A,X]
    00FE: 18       POP   A
(0493)     inc   X                            ; pXIData++ (point to next data byte)
    00FF: 75       INC   X
(0494)     adc   A, 0
    0100: 09 00    ADC   A,0
(0495)     push  A
    0102: 08       PUSH  A
(0496)     romx                               ; Get the run length (CPU.A <- *pXIData)
    0103: 28       ROMX  
(0497)     mov   [__r1], A                    ; Initialize downcounter
    0104: 53 1A    MOV   [__r1],A
(0498)     mov   A, 0                         ; Initialize source data
    0106: 50 00    MOV   A,0
(0499) 
(0500) .ClearRAMBlockLoop:
(0501)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
(0502)     ;         __r1 holds a non-zero count of the number of bytes remaining.
(0503)     ;
(0504)     mvi   [__r0], A                    ; Clear a byte
    0108: 3F 1B    MVI   [__r0],A
(0505)     tst   [__r0], 0xff                 ; Check for page crossing
    010A: 47 1B FF TST   [27],255
(0506)     jnz   .ClearLoopTail               ;   No crossing, keep going
    010D: B0 08    JNZ   0x0116
(0507)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
    010F: 5D D5    MOV   A,REG[213]
(0508)     inc   A
    0111: 74       INC   A
(0509)     mov   reg[ MVW_PP], A
    0112: 60 D5    MOV   REG[213],A
(0510)     mov   A, 0                         ; Restore the zero used for clearing
    0114: 50 00    MOV   A,0
(0511) .ClearLoopTail:
(0512)     dec   [__r1]                       ; Was this the last byte?
    0116: 7A 1A    DEC   [__r1]
(0513)     jnz   .ClearRAMBlockLoop           ;   No,  continue
    0118: BF EF    JNZ   0x0108
(0514)     pop   A                            ;   Yes, restore pXIData to [A,X] and
    011A: 18       POP   A
(0515)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
    011B: 8F AA    JMP   0x00C6
(0516) 
(0517) .C_RTE_WrapUp:
(0518)     pop   A                            ; balance stack
    011D: 18       POP   A
(0519) 
(0520) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
(0521) 
(0522) C_RTE_Done:
(0523) 
(0524) ENDIF ; C_LANGUAGE_SUPPORT
(0525) 
(0526)     ;-------------------------------
(0527)     ; Voltage Stabilization for SMP
(0528)     ;-------------------------------
(0529) 
(0530) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
(0531) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
(0532)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(0533)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
(0534)     ; 5V before enabling the Precision Power-On Reset (PPOR).
(0535)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
(0536)     or   reg[INT_MSK0],INT_MSK0_SLEEP
(0537)     M8C_SetBank1
(0538)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
(0539)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
(0540)     M8C_SetBank0
(0541)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
(0542)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
(0543) .WaitFor2ms:
(0544)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
(0545)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
(0546) ENDIF ; SMP is operational
(0547) ENDIF ; 5.0V Operation
(0548) 
(0549)     ;-------------------------------
(0550)     ; Set Power-On Reset (POR) Level
(0551)     ;-------------------------------
(0552)     M8C_SetBank1
    011E: 71 10    OR    F,16
(0553) 
(0554) IF (POWER_SETTING & POWER_SET_5V0)          ; 5.0V Operation?
(0555)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)    ; and Slow Mode?
(0556)  ELSE                                       ;    No, fast mode
(0557)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz ) ;    As fast as 24MHz?
(0558)                                             ;       no, set midpoint POR in user code, if desired
(0559)   ELSE ; 24HMz                              ;
(0560)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
    0120: 43 E3 20 OR    REG[227],32
(0561)   ENDIF ; 24MHz
(0562)  ENDIF ; Slow Mode
(0563) ENDIF ; 5.0V Operation
(0564) 
(0565)     M8C_SetBank0
    0123: 70 EF    AND   F,239
(0566) 
(0567)     ;----------------------------
(0568)     ; Wrap up and invoke "main"
(0569)     ;----------------------------
(0570) 
(0571)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
(0572)     ; no interrupts should be enabled now, so may as well clear the register.
(0573)     ;
(0574)     mov  reg[INT_MSK0],0
    0125: 62 E0 00 MOV   REG[224],0
(0575) 
(0576)     ; Everything has started OK. Now select requested CPU & sleep frequency.
(0577)     ;
(0578)     M8C_SetBank1
    0128: 71 10    OR    F,16
(0579)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
    012A: 62 E0 03 MOV   REG[224],3
(0580)     M8C_SetBank0
    012D: 70 EF    AND   F,239
(0581) 
(0582)     ; Global Interrupt are NOT enabled, this should be done in main().
(0583)     ; LVD is set but will not occur unless Global Interrupts are enabled.
(0584)     ; Global Interrupts should be enabled as soon as possible in main().
(0585)     ;
(0586)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
    012F: 62 E2 00 MOV   REG[226],0
(0587)                                    ; have been set during the boot process.
(0588) IF ENABLE_LJMP_TO_MAIN
(0589)     ljmp  _main                    ; goto main (no return)
(0590) ELSE
(0591)     lcall _main                    ; call main
    0132: 7C 1A AF LCALL _main
(0592) .Exit:
(0593)     jmp  .Exit                     ; Wait here after return till power-off or reset
    0135: 8F FF    JMP   0x0135
(0594) ENDIF
(0595) 
(0596)     ;---------------------------------
(0597)     ; Library Access to Global Parms
(0598)     ;---------------------------------
(0599)     ;
(0600)  bGetPowerSetting:
(0601) _bGetPowerSetting:
(0602)     ; Returns value of POWER_SETTING in the A register.
(0603)     ; No inputs. No Side Effects.
(0604)     ;
(0605)     mov   A, POWER_SETTING
    0137: 50 10    MOV   A,16
(0606)     ret
    0139: 7F       RET   
    013A: 30       HALT  
    013B: 30       HALT  
    013C: 30       HALT  
    013D: 30       HALT  
    013E: 30       HALT  
    013F: 30       HALT  
    0140: 30       HALT  
    0141: 30       HALT  
    0142: 30       HALT  
    0143: 30       HALT  
    0144: 30       HALT  
    0145: 30       HALT  
    0146: 30       HALT  
    0147: 30       HALT  
    0148: 30       HALT  
    0149: 30       HALT  
    014A: 30       HALT  
    014B: 30       HALT  
    014C: 30       HALT  
    014D: 30       HALT  
    014E: 30       HALT  
    014F: 30       HALT  
    0150: 20       POP   X
    0151: 48 7A 00 TST   [X+122],0
    0154: 46 46 54 XOR   REG[X+70],84
    0157: 20       POP   X
    0158: 20       POP   X
    0159: 64       ASL   A
    015A: 66 3D    ASL   [X+61]
    015C: 00       SWI   
    015D: 48 7A 00 TST   [X+122],0
    0160: 44 61 74 OR    REG[X+97],116
    0163: 61 20    MOV   REG[X+32],A
    0165: 69 6E    ASR   [X+110]
    0167: 69 74    ASR   [X+116]
    0169: 0A 00    ADC   A,[0]
    016B: 09 09    ADC   A,9
    016D: 00       SWI   
    016E: 52 65    MOV   A,[X+101]
    0170: 61 6C    MOV   REG[X+108],A
    0172: 20       POP   X
    0173: 50 61    MOV   A,97
    0175: 72 74    XOR   F,116
    0177: 09 09    ADC   A,9
    0179: 49 6D 61 TST   REG[109],97
    017C: 67       ASR   A
    017D: 69 6E    ASR   [X+110]
    017F: 61 72    MOV   REG[X+114],A
    0181: 79       DEC   X
    0182: 20       POP   X
    0183: 50 61    MOV   A,97
    0185: 72 74    XOR   F,116
    0187: 0A 00    ADC   A,[0]
FILE: lib\psocconfigtbl.asm
(0001) ; Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0002) ;
(0003) include "m8c.inc"
(0004) ;  Personalization tables 
(0005) export LoadConfigTBL_fft_Bank1
(0006) export LoadConfigTBL_fft_Bank0
(0007) export LoadConfigTBL_fft_Ordered
(0008) AREA lit(rom, rel)
(0009) LoadConfigTBL_fft_Ordered:
(0010) ;  Ordered Global Register values
(0011) 	M8C_SetBank1
    0189: 71 10    OR    F,16
(0012) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
    018B: 62 00 00 MOV   REG[0],0
(0013) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
    018E: 62 01 FF MOV   REG[1],255
(0014) 	M8C_SetBank0
    0191: 70 EF    AND   F,239
(0015) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
    0193: 62 03 FF MOV   REG[3],255
(0016) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
    0196: 62 02 00 MOV   REG[2],0
(0017) 	M8C_SetBank1
    0199: 71 10    OR    F,16
(0018) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
    019B: 62 02 00 MOV   REG[2],0
(0019) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
    019E: 62 03 00 MOV   REG[3],0
(0020) 	M8C_SetBank0
    01A1: 70 EF    AND   F,239
(0021) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
    01A3: 62 01 00 MOV   REG[1],0
(0022) 	M8C_SetBank1
    01A6: 71 10    OR    F,16
(0023) 	mov	reg[04h], 00h		; Port_1_DriveMode_0 register (PRT1DM0)
    01A8: 62 04 00 MOV   REG[4],0
(0024) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
    01AB: 62 05 FF MOV   REG[5],255
(0025) 	M8C_SetBank0
    01AE: 70 EF    AND   F,239
(0026) 	mov	reg[07h], bfh		; Port_1_DriveMode_2 register (PRT1DM2)
    01B0: 62 07 BF MOV   REG[7],191
(0027) 	mov	reg[06h], 40h		; Port_1_GlobalSelect register (PRT1GS)
    01B3: 62 06 40 MOV   REG[6],64
(0028) 	M8C_SetBank1
    01B6: 71 10    OR    F,16
(0029) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
    01B8: 62 06 00 MOV   REG[6],0
(0030) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
    01BB: 62 07 00 MOV   REG[7],0
(0031) 	M8C_SetBank0
    01BE: 70 EF    AND   F,239
(0032) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
    01C0: 62 05 00 MOV   REG[5],0
(0033) 	M8C_SetBank1
    01C3: 71 10    OR    F,16
(0034) 	mov	reg[08h], ffh		; Port_2_DriveMode_0 register (PRT2DM0)
    01C5: 62 08 FF MOV   REG[8],255
(0035) 	mov	reg[09h], 00h		; Port_2_DriveMode_1 register (PRT2DM1)
    01C8: 62 09 00 MOV   REG[9],0
(0036) 	M8C_SetBank0
    01CB: 70 EF    AND   F,239
(0037) 	mov	reg[0bh], 00h		; Port_2_DriveMode_2 register (PRT2DM2)
    01CD: 62 0B 00 MOV   REG[11],0
(0038) 	mov	reg[0ah], 80h		; Port_2_GlobalSelect register (PRT2GS)
    01D0: 62 0A 80 MOV   REG[10],128
(0039) 	M8C_SetBank1
    01D3: 71 10    OR    F,16
(0040) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
    01D5: 62 0A 00 MOV   REG[10],0
(0041) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
    01D8: 62 0B 00 MOV   REG[11],0
(0042) 	M8C_SetBank0
    01DB: 70 EF    AND   F,239
(0043) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
    01DD: 62 09 00 MOV   REG[9],0
(0044) 	M8C_SetBank1
    01E0: 71 10    OR    F,16
(0045) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
    01E2: 62 0C 00 MOV   REG[12],0
(0046) 	mov	reg[0dh], 00h		; Port_3_DriveMode_1 register (PRT3DM1)
    01E5: 62 0D 00 MOV   REG[13],0
(0047) 	M8C_SetBank0
    01E8: 70 EF    AND   F,239
(0048) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
    01EA: 62 0F 00 MOV   REG[15],0
(0049) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
    01ED: 62 0E 00 MOV   REG[14],0
(0050) 	M8C_SetBank1
    01F0: 71 10    OR    F,16
(0051) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
    01F2: 62 0E 00 MOV   REG[14],0
(0052) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
    01F5: 62 0F 00 MOV   REG[15],0
(0053) 	M8C_SetBank0
    01F8: 70 EF    AND   F,239
(0054) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
    01FA: 62 0D 00 MOV   REG[13],0
(0055) 	M8C_SetBank1
    01FD: 71 10    OR    F,16
(0056) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
    01FF: 62 10 00 MOV   REG[16],0
(0057) 	mov	reg[11h], 00h		; Port_4_DriveMode_1 register (PRT4DM1)
    0202: 62 11 00 MOV   REG[17],0
(0058) 	M8C_SetBank0
    0205: 70 EF    AND   F,239
(0059) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
    0207: 62 13 00 MOV   REG[19],0
(0060) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
    020A: 62 12 00 MOV   REG[18],0
(0061) 	M8C_SetBank1
    020D: 71 10    OR    F,16
(0062) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
    020F: 62 12 00 MOV   REG[18],0
(0063) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
    0212: 62 13 00 MOV   REG[19],0
(0064) 	M8C_SetBank0
    0215: 70 EF    AND   F,239
(0065) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
    0217: 62 11 00 MOV   REG[17],0
(0066) 	M8C_SetBank1
    021A: 71 10    OR    F,16
(0067) 	mov	reg[14h], 00h		; Port_5_DriveMode_0 register (PRT5DM0)
    021C: 62 14 00 MOV   REG[20],0
(0068) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
    021F: 62 15 00 MOV   REG[21],0
(0069) 	M8C_SetBank0
    0222: 70 EF    AND   F,239
(0070) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
    0224: 62 17 00 MOV   REG[23],0
(0071) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
    0227: 62 16 00 MOV   REG[22],0
(0072) 	M8C_SetBank1
    022A: 71 10    OR    F,16
(0073) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
    022C: 62 16 00 MOV   REG[22],0
(0074) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
    022F: 62 17 00 MOV   REG[23],0
(0075) 	M8C_SetBank0
    0232: 70 EF    AND   F,239
(0076) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
    0234: 62 15 00 MOV   REG[21],0
(0077) 	M8C_SetBank1
    0237: 71 10    OR    F,16
(0078) 	mov	reg[18h], 00h		; Port_6_DriveMode_0 register (PRT6DM0)
    0239: 62 18 00 MOV   REG[24],0
(0079) 	mov	reg[19h], 00h		; Port_6_DriveMode_1 register (PRT6DM1)
    023C: 62 19 00 MOV   REG[25],0
(0080) 	M8C_SetBank0
    023F: 70 EF    AND   F,239
(0081) 	mov	reg[1bh], 00h		; Port_6_DriveMode_2 register (PRT6DM2)
    0241: 62 1B 00 MOV   REG[27],0
(0082) 	mov	reg[1ah], 00h		; Port_6_GlobalSelect register (PRT6GS)
    0244: 62 1A 00 MOV   REG[26],0
(0083) 	M8C_SetBank1
    0247: 71 10    OR    F,16
(0084) 	mov	reg[1ah], 00h		; Port_6_IntCtrl_0 register (PRT6IC0)
    0249: 62 1A 00 MOV   REG[26],0
(0085) 	mov	reg[1bh], 00h		; Port_6_IntCtrl_1 register (PRT6IC1)
    024C: 62 1B 00 MOV   REG[27],0
(0086) 	M8C_SetBank0
    024F: 70 EF    AND   F,239
(0087) 	mov	reg[19h], 00h		; Port_6_IntEn register (PRT6IE)
    0251: 62 19 00 MOV   REG[25],0
(0088) 	M8C_SetBank1
    0254: 71 10    OR    F,16
(0089) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
    0256: 62 1C 00 MOV   REG[28],0
(0090) 	mov	reg[1dh], 00h		; Port_7_DriveMode_1 register (PRT7DM1)
    0259: 62 1D 00 MOV   REG[29],0
(0091) 	M8C_SetBank0
    025C: 70 EF    AND   F,239
(0092) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
    025E: 62 1F 00 MOV   REG[31],0
(0093) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
    0261: 62 1E 00 MOV   REG[30],0
(0094) 	M8C_SetBank1
    0264: 71 10    OR    F,16
(0095) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
    0266: 62 1E 00 MOV   REG[30],0
(0096) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
    0269: 62 1F 00 MOV   REG[31],0
(0097) 	M8C_SetBank0
    026C: 70 EF    AND   F,239
(0098) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
    026E: 62 1D 00 MOV   REG[29],0
(0099) 	ret
    0271: 7F       RET   
    0272: 60 28    MOV   REG[40],A
    0274: 66 00    ASL   [X+0]
    0276: 63 15 65 MOV   REG[X+21],101
    0279: 00       SWI   
    027A: E6 03    JACC  0x087E
    027C: E7 02    JACC  0x097F
    027E: D6 00    JNC   0x087F
    0280: B0 30    JNZ   0x02B1
    0282: B1 00    JNZ   0x0383
    0284: B2 00    JNZ   0x0485
    0286: B3 33    JNZ   0x05BA
    0288: B4 33    JNZ   0x06BC
    028A: B5 00    JNZ   0x078B
    028C: B6 20    JNZ   0x08AD
    028E: B8 55    JNZ   0xFAE4
    0290: B9 00    JNZ   0xFB91
    0292: BA 10    JNZ   0xFCA3
    0294: BB 33    JNZ   0xFDC8
    0296: BC 33    JNZ   0xFECA
    0298: BD 00    JNZ   0xFF99
    029A: BE 00    JNZ   0x009B
    029C: C0 00    JC    0x029D
    029E: C1 00    JC    0x039F
    02A0: C2 00    JC    0x04A1
    02A2: C3 33    JC    0x05D6
    02A4: C4 33    JC    0x06D8
    02A6: C5 00    JC    0x07A7
    02A8: C6 00    JC    0x08A9
    02AA: C8 55    JC    0xFB00
    02AC: C9 00    JC    0xFBAD
    02AE: CA 00    JC    0xFCAF
    02B0: CB 33    JC    0xFDE4
    02B2: CC 33    JC    0xFEE6
    02B4: CD 00    JC    0xFFB5
    02B6: CE 00    JC    0x00B7
    02B8: 6C 00    RLC   [X+0]
    02BA: 6D       RRC   A
    02BB: 00       SWI   
    02BC: 6E 00    RRC   [0]
    02BE: 6F 00    RRC   [X+0]
    02C0: 84 90    JMP   0x0751
    02C2: 85 00    JMP   0x07C3
    02C4: 86 60    JMP   0x0925
    02C6: 87 F0    JMP   0x0AB7
    02C8: 33 00    XOR   A,[X+0]
    02CA: 31 00    XOR   A,0
    02CC: 32 00    XOR   A,[0]
    02CE: 75       INC   X
    02CF: FD 76    INDEX 0x0047
    02D1: 21 77    AND   A,119
    02D3: 20       POP   X
    02D4: 74       INC   A
    02D5: 00       SWI   
    02D6: 2F 00 2D OR    [X+0],45
    02D9: 00       SWI   
    02DA: 2E 00 2B OR    [0],43
    02DD: 00       SWI   
    02DE: 29 00    OR    A,0
    02E0: 2A 00    OR    A,[0]
    02E2: FF 61    INDEX 0x0245
    02E4: 00       SWI   
    02E5: 69 00    ASR   [X+0]
    02E7: 60 00    MOV   REG[0],A
    02E9: 62 80 67 MOV   REG[128],103
    02EC: 33 68    XOR   A,[X+104]
    02EE: 33 63    XOR   A,[X+99]
    02F0: 00       SWI   
    02F1: 66 00    ASL   [X+0]
    02F3: D1 00    JNC   0x03F4
    02F5: D3 00    JNC   0x05F6
    02F7: D0 00    JNC   0x02F8
    02F9: D2 00    JNC   0x04FA
    02FB: E1 28    JACC  0x0424
    02FD: E2 00    JACC  0x04FE
    02FF: DF 9B    JNC   0x029B
    0301: DE 00    JNC   0x0102
    0303: DD 00    JNC   0x0004
    0305: E7 00    JACC  0x0A06
    0307: 30       HALT  
    0308: 20       POP   X
    0309: 31 15    XOR   A,21
    030B: 32 40    XOR   A,[64]
    030D: 2C 05    OR    [5],A
    030F: 2D E1    OR    [X-31],A
    0311: 2E 00 28 OR    [0],40
    0314: 0D 29    ADC   [X+41],A
    0316: 01 2A    ADD   A,42
    0318: 07 FF 30 ADD   [X-1],48
    031B: 31 32    XOR   A,50
    031D: 33 34    XOR   A,[X+52]
    031F: 35 36    XOR   [X+54],A
    0321: 37 38 39 XOR   [X+56],57
    0324: 61 62    MOV   REG[X+98],A
    0326: 63 64 65 MOV   REG[X+100],101
    0329: 66 67    ASL   [X+103]
    032B: 68 69    ASR   [105]
    032D: 6A       RLC   A
    032E: 6B 6C    RLC   [108]
    0330: 6D       RRC   A
    0331: 6E 6F    RRC   [111]
    0333: 70 71    AND   F,113
    0335: 72 73    XOR   F,115
    0337: 74       INC   A
    0338: 75       INC   X
    0339: 76 77    INC   [119]
    033B: 78       DEC   A
    033C: 79       DEC   X
    033D: 7A 00    DEC   [0]
    033F: 2D 42    OR    [X+66],A
FILE: lib\psocconfig.asm
(0001) ; Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0002) ;
(0003) ;==========================================================================
(0004) ;  PSoCConfig.asm
(0005) ;  @PSOC_VERSION
(0006) ;
(0007) ;  Version: 0.85
(0008) ;  Revised: June 22, 2004
(0009) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
(0010) ;
(0011) ;  This file is generated by the Device Editor on Application Generation.
(0012) ;  It contains code which loads the configuration data table generated in
(0013) ;  the file PSoCConfigTBL.asm
(0014) ;
(0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
(0016) ;  Edits to this file will not be preserved.
(0017) ;==========================================================================
(0018) ;
(0019) include "m8c.inc"
(0020) include "memory.inc"
(0021) include "GlobalParams.inc"
(0022) 
(0023) export LoadConfigInit
(0024) export _LoadConfigInit
(0025) export LoadConfig_fft
(0026) export _LoadConfig_fft
(0027) export Port_2_Data_SHADE
(0028) export _Port_2_Data_SHADE
(0029) export Port_2_DriveMode_0_SHADE
(0030) export _Port_2_DriveMode_0_SHADE
(0031) export Port_2_DriveMode_1_SHADE
(0032) export _Port_2_DriveMode_1_SHADE
(0033) 
(0034) 
(0035) export NO_SHADOW
(0036) export _NO_SHADOW
(0037) 
(0038) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
(0039) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
(0040) 
(0041) AREA psoc_config(rom, rel)
(0042) 
(0043) ;---------------------------------------------------------------------------
(0044) ; LoadConfigInit - Establish the start-up configuration (except for a few
(0045) ;                  parameters handled by boot code, like CPU speed). This
(0046) ;                  function can be called from user code, but typically it
(0047) ;                  is only called from boot.
(0048) ;
(0049) ;       INPUTS: None.
(0050) ;      RETURNS: Nothing.
(0051) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
(0052) ;               In the large memory model currently only the page
(0053) ;               pointer registers listed below are modified.  This does
(0054) ;               not guarantee that in future implementations of this
(0055) ;               function other page pointer registers will not be
(0056) ;               modified.
(0057) ;          
(0058) ;               Page Pointer Registers Modified: 
(0059) ;               CUR_PP
(0060) ;
(0061) _LoadConfigInit:
(0062)  LoadConfigInit:
(0063)     RAM_PROLOGUE RAM_USE_CLASS_4
(0064)     
(0065) 	mov		[Port_2_Data_SHADE], 0h
    0341: 55 00 00 MOV   [0],0
(0066) 	mov		[Port_2_DriveMode_0_SHADE], ffh
    0344: 55 01 FF MOV   [1],255
(0067) 	mov		[Port_2_DriveMode_1_SHADE], 0h
    0347: 55 02 00 MOV   [2],0
(0068) 
(0069) 	lcall	LoadConfigTBL_fft_Ordered
    034A: 7C 01 89 LCALL 0x0189
(0070) 	lcall	LoadConfig_fft
    034D: 7C 03 51 LCALL 0x0351
(0071) 
(0072)     RAM_EPILOGUE RAM_USE_CLASS_4
(0073)     ret
    0350: 7F       RET   
(0074) 
(0075) ;---------------------------------------------------------------------------
(0076) ; Load Configuration fft
(0077) ;
(0078) ;    Load configuration registers for fft.
(0079) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
(0080) ;
(0081) ;       INPUTS: None.
(0082) ;      RETURNS: Nothing.
(0083) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
(0084) ;               modified as may the Page Pointer registers!
(0085) ;               In the large memory model currently only the page
(0086) ;               pointer registers listed below are modified.  This does
(0087) ;               not guarantee that in future implementations of this
(0088) ;               function other page pointer registers will not be
(0089) ;               modified.
(0090) ;          
(0091) ;               Page Pointer Registers Modified: 
(0092) ;               CUR_PP
(0093) ;
(0094) _LoadConfig_fft:
(0095)  LoadConfig_fft:
(0096)     RAM_PROLOGUE RAM_USE_CLASS_4
(0097) 
(0098) 	push	x
    0351: 10       PUSH  X
(0099)     M8C_SetBank0                    ; Force bank 0
    0352: 70 EF    AND   F,239
(0100)     mov     a, 0                    ; Specify bank 0
    0354: 50 00    MOV   A,0
(0101)     asr     a                       ; Store in carry flag
    0356: 67       ASR   A
(0102)                                     ; Load bank 0 table:
(0103)     mov     A, >LoadConfigTBL_fft_Bank0
    0357: 50 02    MOV   A,2
(0104)     mov     X, <LoadConfigTBL_fft_Bank0
    0359: 57 72    MOV   X,114
(0105)     lcall   LoadConfig              ; Load the bank 0 values
    035B: 7C 03 6A LCALL 0x036A
(0106) 
(0107)     mov     a, 1                    ; Specify bank 1
    035E: 50 01    MOV   A,1
(0108)     asr     a                       ; Store in carry flag
    0360: 67       ASR   A
(0109)                                     ; Load bank 1 table:
(0110)     mov     A, >LoadConfigTBL_fft_Bank1
    0361: 50 02    MOV   A,2
(0111)     mov     X, <LoadConfigTBL_fft_Bank1
    0363: 57 E3    MOV   X,227
(0112)     lcall   LoadConfig              ; Load the bank 1 values
    0365: 7C 03 6A LCALL 0x036A
(0113) 
(0114) 	pop		x
    0368: 20       POP   X
(0115) 
(0116)     RAM_EPILOGUE RAM_USE_CLASS_4
(0117)     ret
    0369: 7F       RET   
(0118) 
(0119) 
(0120) 
(0121) 
(0122) ;---------------------------------------------------------------------------
(0123) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
(0124) ;              pairs. Terminate on address=0xFF.
(0125) ;
(0126) ;  INPUTS:  [A,X] points to the table to be loaded
(0127) ;           Flag Register Carry bit encodes the Register Bank
(0128) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
(0129) ;
(0130) ;  RETURNS: nothing.
(0131) ;
(0132) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
(0133) ;                X-3 Temporary store for register address
(0134) ;                X-2 LSB of config table address
(0135) ;                X-1 MSB of config table address
(0136) ;
(0137) LoadConfig:
(0138)     RAM_PROLOGUE RAM_USE_CLASS_2
(0139)     add     SP, 2                   ; Set up local vars
    036A: 38 02    ADD   SP,2
(0140)     push    X                       ; Save config table address on stack
    036C: 10       PUSH  X
(0141)     push    A
    036D: 08       PUSH  A
(0142)     mov     X, SP
    036E: 4F       MOV   X,SP
(0143)     mov     [X-4], 0                ; Set default Destination to Bank 0
    036F: 56 FC 00 MOV   [X-4],0
(0144)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
    0372: D0 04    JNC   0x0377
(0145)     mov     [X-4], 1                ; No Carry: default to Bank 1
    0374: 56 FC 01 MOV   [X-4],1
(0146) .BankSelectSaved:
(0147)     pop     A
    0377: 18       POP   A
(0148)     pop     X
    0378: 20       POP   X
(0149) 
(0150) LoadConfigLp:
(0151)     M8C_SetBank0                    ; Switch to bank 0
    0379: 70 EF    AND   F,239
(0152)     M8C_ClearWDT                    ; Clear the watchdog for long inits
    037B: 62 E3 00 MOV   REG[227],0
(0153)     push    X                       ; Preserve the config table address
    037E: 10       PUSH  X
(0154)     push    A
    037F: 08       PUSH  A
(0155)     romx                            ; Load register address from table
    0380: 28       ROMX  
(0156)     cmp     A, END_CONFIG_TABLE     ; End of table?
    0381: 39 FF    CMP   A,255
(0157)     jz      EndLoadConfig           ;   Yes, go wrap it up
    0383: A0 1F    JZ    0x03A3
(0158)     mov     X, SP                   ;
    0385: 4F       MOV   X,SP
(0159)     tst     [X-4], 1                ; Loading IO Bank 1?
    0386: 48 FC 01 TST   [X-4],1
(0160)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
    0389: A0 03    JZ    0x038D
(0161)     M8C_SetBank1                    ;   Yes, switch to Bank 1
    038B: 71 10    OR    F,16
(0162) .IOBankNowSet:
(0163)     mov     [X-3], A                ; Stash the register address
    038D: 54 FD    MOV   [X-3],A
(0164)     pop     A                       ; Retrieve the table address
    038F: 18       POP   A
(0165)     pop     X
    0390: 20       POP   X
(0166)     inc     X                       ; Advance to the data byte
    0391: 75       INC   X
(0167)     adc     A, 0
    0392: 09 00    ADC   A,0
(0168)     push    X                       ; Save the config table address again
    0394: 10       PUSH  X
(0169)     push    A
    0395: 08       PUSH  A
(0170)     romx                            ; load config data from the table
    0396: 28       ROMX  
(0171)     mov     X, SP                   ; retrieve the register address
    0397: 4F       MOV   X,SP
(0172)     mov     X, [X-3]
    0398: 59 FD    MOV   X,[X-3]
(0173)     mov     reg[X], A               ; Configure the register
    039A: 61 00    MOV   REG[X+0],A
(0174)     pop     A                       ; retrieve the table address
    039C: 18       POP   A
(0175)     pop     X
    039D: 20       POP   X
(0176)     inc     X                       ; advance to next table entry
    039E: 75       INC   X
(0177)     adc     A, 0
    039F: 09 00    ADC   A,0
(0178)     jmp     LoadConfigLp            ; loop to configure another register
    03A1: 8F D7    JMP   0x0379
(0179) EndLoadConfig:
(0180)     add     SP, -4
    03A3: 38 FC    ADD   SP,252
    03A5: 70 3F    AND   F,63
(0181)     RAM_EPILOGUE RAM_USE_CLASS_2
    03A7: 71 C0    OR    F,192
(0182)     ret
    03A9: 7F       RET   
FILE: lib\uart_1int.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  FILENAME:   UART_1INT.asm
(0004) ;;  Version: 5.2, Updated on 2005/09/30 at 16:26:37
(0005) ;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0006) ;;
(0007) ;;  DESCRIPTION:  UART Interrupt Service Routine.
(0008) ;;-----------------------------------------------------------------------------
(0009) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
(0010) ;;*****************************************************************************
(0011) ;;*****************************************************************************
(0012) 
(0013) 
(0014) include "UART_1.inc"
(0015) include "memory.inc"
(0016) include "m8c.inc"
(0017) 
(0018) ;-----------------------------------------------
(0019) ;  Global Symbols
(0020) ;-----------------------------------------------
(0021) export  _UART_1_TX_ISR
(0022) export  _UART_1_RX_ISR
(0023) 
(0024) IF (UART_1_RXBUF_ENABLE)
(0025) export  UART_1_aRxBuffer
(0026) export _UART_1_aRxBuffer
(0027) export  UART_1_bRxCnt
(0028) export _UART_1_bRxCnt
(0029) export  UART_1_fStatus
(0030) export _UART_1_fStatus
(0031) ENDIF
(0032) 
(0033) 
(0034) ;-----------------------------------------------
(0035) ; Variable Allocation
(0036) ;-----------------------------------------------
(0037) AREA InterruptRAM (RAM, REL, CON)
(0038) 
(0039) IF (UART_1_RXBUF_ENABLE)
(0040)  UART_1_fStatus:
(0041) _UART_1_fStatus:      BLK  1
(0042)  UART_1_bRxCnt:
(0043) _UART_1_bRxCnt:       BLK  1
(0044) AREA UART_1_RAM (RAM, REL, CON)
(0045)  UART_1_aRxBuffer:
(0046) _UART_1_aRxBuffer:    BLK UART_1_RX_BUFFER_SIZE
(0047) ENDIF
(0048) 
(0049) AREA InterruptRAM (RAM, REL, CON)
(0050) 
(0051) ;@PSoC_UserCode_INIT@ (Do not change this line.)
(0052) ;---------------------------------------------------
(0053) ; Insert your custom declarations below this banner
(0054) ;---------------------------------------------------
(0055) 
(0056) ;------------------------
(0057) ;  Constant Definitions
(0058) ;------------------------
(0059) 
(0060) 
(0061) ;------------------------
(0062) ; Variable Allocation
(0063) ;------------------------
(0064) 
(0065) 
(0066) ;---------------------------------------------------
(0067) ; Insert your custom declarations above this banner
(0068) ;---------------------------------------------------
(0069) ;@PSoC_UserCode_END@ (Do not change this line.)
(0070) 
(0071) 
(0072) AREA UserModules (ROM, REL, CON)
(0073) 
(0074) ;-----------------------------------------------------------------------------
(0075) ;  FUNCTION NAME: _UART_1_TX_ISR
(0076) ;
(0077) ;  DESCRIPTION:
(0078) ;     UART TX interrupt handler for instance UART_1.
(0079) ;
(0080) ;     This is a place holder function.  If the user requires use of an interrupt
(0081) ;     handler for this function, then place code where specified.
(0082) ;-----------------------------------------------------------------------------
(0083) 
(0084) _UART_1_TX_ISR:
(0085)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
(0086)    ;---------------------------------------------------
(0087)    ; Insert your custom code below this banner
(0088)    ;---------------------------------------------------
(0089)    ;   NOTE: interrupt service routines must preserve
(0090)    ;   the values of the A and X CPU registers.
(0091) 
(0092)    ;---------------------------------------------------
(0093)    ; Insert your custom code above this banner
(0094)    ;---------------------------------------------------
(0095)    ;@PSoC_UserCode_END@ (Do not change this line.)
(0096)    reti
    03AA: 7E       RETI  
(0097) 
(0098) 
(0099) ;-----------------------------------------------------------------------------
(0100) ;  FUNCTION NAME: _UART_1_RX_ISR
(0101) ;
(0102) ;  DESCRIPTION:
(0103) ;     UART RX interrupt handler for instance UART_1.
(0104) ;     This ISR handles the background processing of received characters if
(0105) ;     the buffer is enabled.
(0106) ;
(0107) ;
(0108) ;  The following assumes that the RX buffer feature has been enabled.
(0109) ;
(0110) ;  SIDE EFFECTS:
(0111) ;     There are 3 posible errors that may occur with the serial port.
(0112) ;      1) Parity Error
(0113) ;      2) Framing Error
(0114) ;      3) OverRun Error
(0115) ;
(0116) ;  This user module check for parity and framing error.  If either of these
(0117) ;  two errors are detected, the data is read and ignored.  When an overRun
(0118) ;  error occurs, the last byte was lost, but the current byte is valid.  For
(0119) ;  this reason this error is ignored at this time.  Code could be added to
(0120) ;  this ISR to set a flag if an error condition occurs.
(0121) ;
(0122) ;  THEORY of OPERATION:
(0123) ;     When using the RX buffer feature, the ISR collects received characters
(0124) ;     in a buffer until the user defined command terminator is detected.  After
(0125) ;     the command terminator is detected, the command bit is set and all other
(0126) ;     characters will be ignored until the command bit is reset.  Up to
(0127) ;     buffer_size - 1 characters will be collected waiting for a command
(0128) ;     terminator.  After that, the characters will be discarded, although
(0129) ;     a command determinator will still cause the command bit to be set.
(0130) ;
(0131) ;-----------------------------------------------------------------------------
(0132) _UART_1_RX_ISR:
(0133) 
(0134)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
(0135)    ;---------------------------------------------------
(0136)    ; Insert your custom code below this banner
(0137)    ;---------------------------------------------------
(0138)    ;   NOTE: interrupt service routines must preserve
(0139)    ;   the values of the A and X CPU registers.
(0140) 
(0141)    ;---------------------------------------------------
(0142)    ; Insert your custom code above this banner
(0143)    ;---------------------------------------------------
(0144)    ;@PSoC_UserCode_END@ (Do not change this line.)
(0145) 
(0146) IF (UART_1_RXBUF_ENABLE)
(0147)    push A
(0148)    push X
(0149)    
(0150)    IF SYSTEM_LARGE_MEMORY_MODEL
(0151)       REG_PRESERVE IDX_PP
(0152)    ENDIF
(0153)    
(0154)    mov  X,[UART_1_bRxCnt]                                  ; Load X with byte counter
(0155)    mov  A,REG[UART_1_RX_CONTROL_REG]                       ; Read the control register
(0156)    push A                                                  ; Store copy for later test
(0157)                                                            ; IF real RX interrupt
(0158)    and  A,UART_1_RX_REG_FULL                               ; Did really really get an IRQ
(0159)    jnz  .UARTRX_ReadRx                                     ; Data ready, go get it
(0160)    pop  A                                                  ; Restore stack
(0161)    jmp  .RESTORE_IDX_PP
(0162) 
(0163) .UARTRX_ReadRx:
(0164)    pop  A                                                  ; Restore status flags
(0165)                                                            ; IF there is no error, get data
(0166)                                                            ; Check for parity or framing error
(0167)    and  A,UART_1_RX_ERROR
(0168)    jz   .UARTRX_NO_ERROR                                   ; If there is not an Error go read data
(0169) 
(0170)    or   [UART_1_fStatus],A                                 ; Set error flags (parity,framing,overrun) bits
(0171)    mov  A,REG[UART_1_RX_BUFFER_REG ]                       ; Read the data buffer to clear it.
(0172)    and  A,UART_1_RX_FRAMING_ERROR                          ; Check for framing error special case
(0173)    jz   .RESTORE_IDX_PP                                    ; Not framing error, all done
(0174) 
(0175)                                                            ; Disable and re-enable RX to reset after
(0176)                                                            ; framing error.
(0177)    and   REG[UART_1_RX_CONTROL_REG], ~UART_1_RX_ENABLE     ; Disable RX
(0178)    or    REG[UART_1_RX_CONTROL_REG],  UART_1_RX_ENABLE     ; Enable RX
(0179)    jmp  .RESTORE_IDX_PP                                    ; Done with framing error, leave.
(0180) 
(0181) 
(0182) .UARTRX_NO_ERROR:
(0183)    mov  A,REG[UART_1_RX_BUFFER_REG ]                       ; Read the data buffer
(0184) 
(0185)                                                            ; IF buffer not full
(0186)    tst  [UART_1_fStatus],UART_1_RX_BUF_CMDTERM             ; Check for buffer full
(0187)    jnz  .RESTORE_IDX_PP                                    ; All done
(0188) 
(0189)    cmp  A,UART_1_CMD_TERM                                  ; Check for End of command
(0190)    jnz  .UARTRX_CHK_CTLCHAR
(0191)    or   [UART_1_fStatus],UART_1_RX_BUF_CMDTERM             ; Set command ready bit
(0192) 
(0193) 
(0194) 
(0195)    RAM_SETPAGE_IDX >UART_1_aRxBuffer
(0196)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
(0197)    mov  [X + UART_1_aRxBuffer],00h                         ; Zero out last data
(0198)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
(0199)    jmp  .RESTORE_IDX_PP
(0200) 
(0201) .UARTRX_CHK_CTLCHAR:                                       ; Ignore charaters below this value
(0202)                                                            ; If ignore char is set to 0x00, do not
(0203)                                                            ; ignore any characters.
(0204) IF(UART_1_RX_IGNORE_BELOW)
(0205)    cmp  A,UART_1_RX_IGNORE_BELOW
(0206)    jc   .RESTORE_IDX_PP
(0207) ENDIF
(0208) 
(0209) .UARTRX_CHK_OVFL:                                          ; Check for MAX String here
(0210) 	
(0211)    RAM_SETPAGE_IDX >UART_1_aRxBuffer                       ;   using idexed address mode
(0212)    cmp  [UART_1_bRxCnt],(UART_1_RX_BUFFER_SIZE - 1)
(0213)    jc   .UARTRX_ISR_GETDATA
(0214)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
(0215)    mov  [X + UART_1_aRxBuffer],00h                         ; Zero out last data in the buffer
(0216)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
(0217)    or   [UART_1_fStatus],UART_1_RX_BUF_OVERRUN                ; Set error flags (parity,framing,overrun) bits
(0218)    jmp  .RESTORE_IDX_PP
(0219) 
(0220) .UARTRX_ISR_GETDATA:                                       ; IF input data == "CR", then end of command
(0221)                                                            ; X is already loaded with pointer
(0222)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
(0223)    mov  [X+UART_1_aRxBuffer],A                             ; store data in array
(0224)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
(0225)    inc  X                                                  ; Inc the pointer
(0226)    mov  [UART_1_bRxCnt],X                                  ; Restore the pointer
(0227)                                                            ; ENDIF max string size
(0228) .RESTORE_IDX_PP:
(0229)    IF SYSTEM_LARGE_MEMORY_MODEL
(0230)       REG_RESTORE IDX_PP
(0231)    ENDIF
(0232) 
(0233) .END_UARTRX_ISR:
(0234)    pop  X
(0235)    pop  A
(0236) 
(0237) ENDIF
(0238) 
(0239) UART_1_RX_ISR_END:
(0240)    reti
    03AB: 7E       RETI  
FILE: lib\uart_1.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  Filename:   UART_1.asm
(0004) ;;  Version: 5.2, Updated on 2005/09/30 at 16:26:37
(0005) ;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0006) ;;
(0007) ;;  DESCRIPTION:  UART User Module software implementation file for the
(0008) ;;                22/24/25/26/27xxx families.
(0009) ;;
(0010) ;;
(0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
(0012) ;;        arguments and observe the associated "Registers are volatile" policy.
(0013) ;;        This means it is the caller's responsibility to preserve any values
(0014) ;;        in the X and A registers that are still needed after the API functions
(0015) ;;        returns. For Large Memory Model devices it is also the caller's 
(0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
(0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
(0018) ;;        now, there is no guarantee that will remain the case in future releases.
(0019) ;;-----------------------------------------------------------------------------
(0020) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
(0021) ;;*****************************************************************************
(0022) ;;*****************************************************************************
(0023) 
(0024) 
(0025) include "m8c.inc"
(0026) include "memory.inc"
(0027) include "UART_1.inc"
(0028) 
(0029) ;-----------------------------------------------
(0030) ;  Global Symbols
(0031) ;-----------------------------------------------
(0032) ;-------------------------------------------------------------------
(0033) ;  Declare the functions global for both assembler and C compiler.
(0034) ;
(0035) ;  Note that there are two names for each API. First name is
(0036) ;  assembler reference. Name with underscore is name refence for
(0037) ;  C compiler.  Calling function in C source code does not require
(0038) ;  the underscore.
(0039) ;-------------------------------------------------------------------
(0040) export  UART_1_SetTxIntMode
(0041) export _UART_1_SetTxIntMode
(0042) export  UART_1_EnableInt
(0043) export _UART_1_EnableInt
(0044) export  UART_1_DisableInt
(0045) export _UART_1_DisableInt
(0046) 
(0047) export  UART_1_Start
(0048) export _UART_1_Start
(0049) export  UART_1_Stop
(0050) export _UART_1_Stop
(0051) export  UART_1_SendData
(0052) export _UART_1_SendData
(0053) export  UART_1_bReadTxStatus
(0054) export _UART_1_bReadTxStatus
(0055) export  UART_1_bReadRxData
(0056) export _UART_1_bReadRxData
(0057) export  UART_1_bReadRxStatus
(0058) export _UART_1_bReadRxStatus
(0059) 
(0060) export  UART_1_IntCntl
(0061) export _UART_1_IntCntl
(0062) 
(0063) export  UART_1_TxIntMode
(0064) export _UART_1_TxIntMode
(0065) 
(0066) export  UART_1_PutSHexByte
(0067) export _UART_1_PutSHexByte
(0068) export  UART_1_PutSHexInt
(0069) export _UART_1_PutSHexInt
(0070) 
(0071) export  UART_1_CPutString
(0072) export _UART_1_CPutString
(0073) export  UART_1_PutString
(0074) export _UART_1_PutString
(0075) export  UART_1_PutChar
(0076) export _UART_1_PutChar
(0077) export  UART_1_Write
(0078) export _UART_1_Write
(0079) export  UART_1_CWrite
(0080) export _UART_1_CWrite
(0081) 
(0082) export  UART_1_cGetChar
(0083) export _UART_1_cGetChar
(0084) export  UART_1_cReadChar
(0085) export _UART_1_cReadChar
(0086) export  UART_1_iReadChar
(0087) export _UART_1_iReadChar
(0088) export  UART_1_PutCRLF
(0089) export _UART_1_PutCRLF
(0090) 
(0091) IF (UART_1_RXBUF_ENABLE)
(0092) export  UART_1_CmdReset
(0093) export _UART_1_CmdReset
(0094) export  UART_1_bCmdCheck
(0095) export _UART_1_bCmdCheck
(0096) export  UART_1_bCmdLength
(0097) export _UART_1_bCmdLength
(0098) export  UART_1_bErrCheck
(0099) export _UART_1_bErrCheck
(0100) 
(0101) export  UART_1_szGetParam
(0102) export _UART_1_szGetParam
(0103) export  UART_1_szGetRestOfParams
(0104) export _UART_1_szGetRestOfParams
(0105) ENDIF
(0106) 
(0107) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0108) ; WARNING WARNING WARNING
(0109) ; The following exports are for backwards compatibility only and should
(0110) ; not be used for new designs. They may be eliminated in a future release.
(0111) ; Their status is "NO FURTHER MAINTENANCE". 
(0112) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0113) export  bUART_1_ReadTxStatus
(0114) export _bUART_1_ReadTxStatus
(0115) export  bUART_1_ReadRxData
(0116) export _bUART_1_ReadRxData
(0117) export  bUART_1_ReadRxStatus
(0118) export _bUART_1_ReadRxStatus
(0119) 	
(0120) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0121) ;             END WARNING
(0122) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0123) 
(0124) ;-----------------------------------------------
(0125) ; Variable Allocation
(0126) ;-----------------------------------------------
(0127) IF (UART_1_RXBUF_ENABLE)
(0128)     
(0129) area UART_1_RAM (RAM, REL, CON)
(0130)     
(0131)  ptrParam:   BLK  1
(0132) 
(0133) ENDIF
(0134) 
(0135) area text (ROM,REL)
(0136) 
(0137) ;-----------------------------------------------
(0138) ;  EQUATES
(0139) ;-----------------------------------------------
(0140) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
(0141) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
(0142) 
(0143) area UserModules (ROM, REL, CON)
(0144) 
(0145) ;=============================================================================
(0146) ;=============================================================================
(0147) ;
(0148) ;     Low-Level Commands
(0149) ;
(0150) ;=============================================================================
(0151) ;=============================================================================
(0152) 
(0153) .SECTION
(0154) ;-----------------------------------------------------------------------------
(0155) ;  FUNCTION NAME: UART_1_EnableInt
(0156) ;
(0157) ;  DESCRIPTION:
(0158) ;     Enables this UART's interrupt by setting the interrupt enable mask
(0159) ;     bit associated with this User Module. Remember to call the global
(0160) ;     interrupt enable function by using the macro: M8C_EnableGInt.
(0161) ;-----------------------------------------------------------------------------
(0162) ;
(0163) ;  ARGUMENTS:
(0164) ;     none.
(0165) ;
(0166) ;  RETURNS:
(0167) ;     none.
(0168) ;
(0169) ;  SIDE EFFECTS:
(0170) ;    The A and X registers may be modified by this or future implementations
(0171) ;    of this function.  The same is true for all RAM page pointer registers in
(0172) ;    the Large Memory Model.  When necessary, it is the calling function's
(0173) ;    responsibility to perserve their values across calls to fastcall16 
(0174) ;    functions.
(0175) ;
(0176)  UART_1_EnableInt:
(0177) _UART_1_EnableInt:
(0178)    RAM_PROLOGUE RAM_USE_CLASS_1
(0179)    M8C_EnableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
    03AC: 43 E1 04 OR    REG[225],4
(0180)    M8C_EnableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
    03AF: 43 E1 08 OR    REG[225],8
(0181)    RAM_EPILOGUE RAM_USE_CLASS_1
(0182)    ret
    03B2: 7F       RET   
(0183) .ENDSECTION
(0184) 
(0185)     
(0186) .SECTION
(0187) ;-----------------------------------------------------------------------------
(0188) ;  FUNCTION NAME: UART_1_DisableInt
(0189) ;
(0190) ;  DESCRIPTION:
(0191) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
(0192) ;     associated with this User Module.
(0193) ;-----------------------------------------------------------------------------
(0194) ;
(0195) ;  ARGUMENTS:
(0196) ;     none.
(0197) ;
(0198) ;  RETURNS:
(0199) ;     none.
(0200) ;
(0201) ;  SIDE EFFECTS:
(0202) ;    The A and X registers may be modified by this or future implementations
(0203) ;    of this function.  The same is true for all RAM page pointer registers in
(0204) ;    the Large Memory Model.  When necessary, it is the calling function's
(0205) ;    responsibility to perserve their values across calls to fastcall16 
(0206) ;    functions.
(0207) ;
(0208)  UART_1_DisableInt:
(0209) _UART_1_DisableInt:
(0210)    RAM_PROLOGUE RAM_USE_CLASS_1
(0211)    M8C_DisableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
    03B3: 41 E1 FB AND   REG[225],251
(0212)    M8C_DisableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
    03B6: 41 E1 F7 AND   REG[225],247
(0213)    RAM_EPILOGUE RAM_USE_CLASS_1
(0214)    ret
    03B9: 7F       RET   
(0215) .ENDSECTION
(0216) 
(0217) 
(0218) .SECTION
(0219) ;-----------------------------------------------------------------------------
(0220) ;  FUNCTION NAME: UART_1_SetTxIntMode(BYTE bTxIntMode)
(0221) ;
(0222) ;  DESCRIPTION:
(0223) ;     Sets the Tx Interrupt Mode bit in the Function Register.
(0224) ;-----------------------------------------------------------------------------
(0225) ;
(0226) ;  ARGUMENTS:
(0227) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
(0228) ;        Passed in the A register
(0229) ;
(0230) ;  RETURNS:
(0231) ;     none.
(0232) ;
(0233) ;  SIDE EFFECTS:
(0234) ;    The A and X registers may be modified by this or future implementations
(0235) ;    of this function.  The same is true for all RAM page pointer registers in
(0236) ;    the Large Memory Model.  When necessary, it is the calling function's
(0237) ;    responsibility to perserve their values across calls to fastcall16 
(0238) ;    functions.
(0239) ;
(0240) ;  THEORY of OPERATION OR PROCEDURE:
(0241) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
(0242) ;     on TX register empty or TX transmit complete
(0243) ;
(0244)  UART_1_SetTxIntMode:
(0245) _UART_1_SetTxIntMode:
(0246)    RAM_PROLOGUE RAM_USE_CLASS_1
(0247)    M8C_SetBank1
    03BA: 71 10    OR    F,16
(0248)    and   A, UART_1_INT_MODE_TX_COMPLETE
    03BC: 21 01    AND   A,1
(0249)    jz    .SetModeRegEmpty
    03BE: A0 07    JZ    0x03C6
(0250)    or    REG[UART_1_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
    03C0: 43 28 10 OR    REG[40],16
(0251)    M8C_SetBank0
    03C3: 70 EF    AND   F,239
(0252)    RAM_EPILOGUE RAM_USE_CLASS_1
(0253)    ret
    03C5: 7F       RET   
(0254) 
(0255) .SetModeRegEmpty:
(0256)    and   REG[UART_1_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
    03C6: 41 28 EF AND   REG[40],239
(0257)    M8C_SetBank0
    03C9: 70 EF    AND   F,239
(0258)    RAM_EPILOGUE RAM_USE_CLASS_1
(0259)    ret
    03CB: 7F       RET   
(0260) .ENDSECTION
(0261) 
(0262) 
(0263) .SECTION
(0264) ;-----------------------------------------------------------------------------
(0265) ;  FUNCTION NAME: UART_1_Start(BYTE bParity)
(0266) ;
(0267) ;  DESCRIPTION:
(0268) ;     Sets the start bit and parity in the Control register of this user module.
(0269) ;-----------------------------------------------------------------------------
(0270) ;
(0271) ;  ARGUMENTS:
(0272) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
(0273) ;        Passed in the A register.
(0274) ;
(0275) ;  RETURNS:
(0276) ;     none.
(0277) ;
(0278) ;  SIDE EFFECTS:
(0279) ;    The A and X registers may be modified by this or future implementations
(0280) ;    of this function.  The same is true for all RAM page pointer registers in
(0281) ;    the Large Memory Model.  When necessary, it is the calling function's
(0282) ;    responsibility to perserve their values across calls to fastcall16 
(0283) ;    functions.
(0284) ;
(0285)  UART_1_Start:
(0286) _UART_1_Start:
(0287)    RAM_PROLOGUE RAM_USE_CLASS_1
(0288)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
(0289) 
(0290)    or    A, bfCONTROL_REG_START_BIT
    03CC: 29 01    OR    A,1
(0291)    mov   REG[UART_1_TX_CONTROL_REG], A
    03CE: 60 2B    MOV   REG[43],A
(0292)    mov   REG[UART_1_RX_CONTROL_REG], A
    03D0: 60 2F    MOV   REG[47],A
(0293) IF ( UART_1_RXBUF_ENABLE )
(0294)    call  _UART_1_CmdReset
(0295) ENDIF
(0296)    RAM_EPILOGUE RAM_USE_CLASS_1
(0297)    ret
    03D2: 7F       RET   
(0298) .ENDSECTION
(0299) 
(0300) 
(0301) .SECTION
(0302) ;-----------------------------------------------------------------------------
(0303) ;  FUNCTION NAME: UART_1_Stop
(0304) ;
(0305) ;  DESCRIPTION:
(0306) ;     Disables UART operation.
(0307) ;-----------------------------------------------------------------------------
(0308) ;
(0309) ;  ARGUMENTS:
(0310) ;     none.
(0311) ;
(0312) ;  RETURNS:
(0313) ;     none.
(0314) ;
(0315) ;  SIDE EFFECTS:
(0316) ;    The A and X registers may be modified by this or future implementations
(0317) ;    of this function.  The same is true for all RAM page pointer registers in
(0318) ;    the Large Memory Model.  When necessary, it is the calling function's
(0319) ;    responsibility to perserve their values across calls to fastcall16 
(0320) ;    functions.
(0321) ;
(0322)  UART_1_Stop:
(0323) _UART_1_Stop:
(0324)    RAM_PROLOGUE RAM_USE_CLASS_1
(0325)    and   REG[UART_1_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
    03D3: 41 2B FE AND   REG[43],254
(0326)    and   REG[UART_1_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
    03D6: 41 2F FE AND   REG[47],254
(0327)    RAM_EPILOGUE RAM_USE_CLASS_1
(0328)    ret
    03D9: 7F       RET   
(0329) .ENDSECTION
(0330) 
(0331) 
(0332) .SECTION
(0333) ;-----------------------------------------------------------------------------
(0334) ;  FUNCTION NAME: UART_1_SendData
(0335) ;
(0336) ;  DESCRIPTION:
(0337) ;     Initiates a transmission of data.
(0338) ;-----------------------------------------------------------------------------
(0339) ;
(0340) ;  ARGUMENTS:
(0341) ;     BYTE  TxData - data to transmit. PASSED in A register.
(0342) ;
(0343) ;  RETURNS:
(0344) ;     none.
(0345) ;
(0346) ;  SIDE EFFECTS:
(0347) ;    The A and X registers may be modified by this or future implementations
(0348) ;    of this function.  The same is true for all RAM page pointer registers in
(0349) ;    the Large Memory Model.  When necessary, it is the calling function's
(0350) ;    responsibility to perserve their values across calls to fastcall16 
(0351) ;    functions.
(0352) ;
(0353)  UART_1_SendData:
(0354) _UART_1_SendData:
(0355)    RAM_PROLOGUE RAM_USE_CLASS_1
(0356)    mov REG[UART_1_TX_BUFFER_REG], A
    03DA: 60 29    MOV   REG[41],A
(0357)    RAM_EPILOGUE RAM_USE_CLASS_1
(0358)    ret
    03DC: 7F       RET   
(0359) .ENDSECTION
(0360) 
(0361) 
(0362) .SECTION
(0363) ;-----------------------------------------------------------------------------
(0364) ;  FUNCTION NAME: UART_1_bReadTxStatus
(0365) ;
(0366) ;  DESCRIPTION:
(0367) ;     Reads the Tx Status bits in the Control/Status register.
(0368) ;-----------------------------------------------------------------------------
(0369) ;
(0370) ;  ARGUMENTS:
(0371) ;     none.
(0372) ;
(0373) ;  RETURNS:
(0374) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
(0375) ;           status bits (returned in A)
(0376) ;
(0377) ;  SIDE EFFECTS:
(0378) ;    The A and X registers may be modified by this or future implementations
(0379) ;    of this function.  The same is true for all RAM page pointer registers in
(0380) ;    the Large Memory Model.  When necessary, it is the calling function's
(0381) ;    responsibility to perserve their values across calls to fastcall16 
(0382) ;    functions.
(0383) ;
(0384)  UART_1_bReadTxStatus:
(0385) _UART_1_bReadTxStatus:
(0386)  bUART_1_ReadTxStatus:                           ; For backwards compatibility only
(0387) _bUART_1_ReadTxStatus:                           ; For backwards compatibility only
(0388)    RAM_PROLOGUE RAM_USE_CLASS_1
(0389)    mov A,  REG[UART_1_TX_CONTROL_REG]
    03DD: 5D 2B    MOV   A,REG[43]
(0390)    RAM_EPILOGUE RAM_USE_CLASS_1
(0391)    ret
    03DF: 7F       RET   
(0392) .ENDSECTION
(0393) 
(0394) 
(0395) .SECTION
(0396) ;-----------------------------------------------------------------------------
(0397) ;  FUNCTION NAME: UART_1_bReadRxData
(0398) ;
(0399) ;  DESCRIPTION:
(0400) ;     Reads the RX buffer register.  Should check the status regiser to make
(0401) ;     sure data is valid.
(0402) ;-----------------------------------------------------------------------------
(0403) ;
(0404) ;  ARGUMENTS:
(0405) ;     none.
(0406) ;
(0407) ;  RETURNS:
(0408) ;     bRxData - returned in A.
(0409) ;
(0410) ;  SIDE EFFECTS:
(0411) ;    The A and X registers may be modified by this or future implementations
(0412) ;    of this function.  The same is true for all RAM page pointer registers in
(0413) ;    the Large Memory Model.  When necessary, it is the calling function's
(0414) ;    responsibility to perserve their values across calls to fastcall16 
(0415) ;    functions.
(0416) ;
(0417)  UART_1_bReadRxData:
(0418) _UART_1_bReadRxData:
(0419)  bUART_1_ReadRxData:                             ; For backwards compatibility only
(0420) _bUART_1_ReadRxData:                             ; For backwards compatibility only
(0421)    RAM_PROLOGUE RAM_USE_CLASS_1
(0422)    mov A, REG[UART_1_RX_BUFFER_REG]
    03E0: 5D 2E    MOV   A,REG[46]
(0423)    RAM_EPILOGUE RAM_USE_CLASS_1
(0424)    ret
    03E2: 7F       RET   
(0425) .ENDSECTION
(0426) 
(0427) 
(0428) .SECTION
(0429) ;-----------------------------------------------------------------------------
(0430) ;  FUNCTION NAME: UART_1_bReadRxStatus
(0431) ;
(0432) ;  DESCRIPTION:
(0433) ;     Reads the RX Status bits in the Control/Status register.
(0434) ;-----------------------------------------------------------------------------
(0435) ;
(0436) ;  ARGUMENTS:
(0437) ;     none.
(0438) ;
(0439) ;  RETURNS:
(0440) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
(0441) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
(0442) ;           returned in A.
(0443) ;
(0444) ;  SIDE EFFECTS:
(0445) ;    The A and X registers may be modified by this or future implementations
(0446) ;    of this function.  The same is true for all RAM page pointer registers in
(0447) ;    the Large Memory Model.  When necessary, it is the calling function's
(0448) ;    responsibility to perserve their values across calls to fastcall16 
(0449) ;    functions.
(0450) ;
(0451)  UART_1_bReadRxStatus:
(0452) _UART_1_bReadRxStatus:
(0453)  bUART_1_ReadRxStatus:                           ; For backwards compatibility only
(0454) _bUART_1_ReadRxStatus:                           ; For backwards compatibility only
(0455)    RAM_PROLOGUE RAM_USE_CLASS_1
(0456)    mov A,  REG[UART_1_RX_CONTROL_REG]
    03E3: 5D 2F    MOV   A,REG[47]
(0457)    RAM_EPILOGUE RAM_USE_CLASS_1
(0458)    ret
    03E5: 7F       RET   
(0459) .ENDSECTION
(0460) 
(0461) 
(0462) .SECTION
(0463) ;-----------------------------------------------------------------------------
(0464) ;  FUNCTION NAME: UART_1_TxIntMode
(0465) ;
(0466) ;  DESCRIPTION:
(0467) ;     This function is used to change the TX Interrupt mode.
(0468) ;-----------------------------------------------------------------------------
(0469) ;
(0470) ;  ARGUMENTS:
(0471) ;     A => Tx Interrupt mode
(0472) ;             0 => Interrupt on TX_Reg_Empty  (Default)
(0473) ;             1 => Interrupt on TX Complete
(0474) ;
(0475) ;  RETURNS:
(0476) ;     none.
(0477) ;
(0478) ;  SIDE EFFECTS:
(0479) ;    The A and X registers may be modified by this or future implementations
(0480) ;    of this function.  The same is true for all RAM page pointer registers in
(0481) ;    the Large Memory Model.  When necessary, it is the calling function's
(0482) ;    responsibility to perserve their values across calls to fastcall16 
(0483) ;    functions.
(0484) ;
(0485)  UART_1_TxIntMode:
(0486) _UART_1_TxIntMode:
(0487)    RAM_PROLOGUE RAM_USE_CLASS_1
(0488) 
(0489)    and  A,UART_1_INT_MODE_TX_COMPLETE
    03E6: 21 01    AND   A,1
(0490)    M8C_SetBank1
    03E8: 71 10    OR    F,16
(0491)    cmp  A,UART_1_INT_MODE_TX_COMPLETE
    03EA: 39 01    CMP   A,1
(0492)    jz   .SetTxCmpMode
    03EC: A0 06    JZ    0x03F3
(0493) 
(0494)    and  reg[UART_1_TX_FUNC_REG],0xEF             ; Set Interrupt on Tx_Reg_Empty
    03EE: 41 28 EF AND   REG[40],239
(0495)    jmp  .TxIntMode_End
    03F1: 80 04    JMP   0x03F6
(0496) 
(0497) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
(0498)    or   reg[UART_1_TX_FUNC_REG],0x10
    03F3: 43 28 10 OR    REG[40],16
(0499) 
(0500) .TxIntMode_End:
(0501)    M8C_SetBank0
    03F6: 70 EF    AND   F,239
(0502)    RAM_EPILOGUE RAM_USE_CLASS_1
(0503)    ret
    03F8: 7F       RET   
(0504) .ENDSECTION
(0505) 
(0506)     
(0507) .SECTION
(0508) ;-----------------------------------------------------------------------------
(0509) ;  FUNCTION NAME: UART_1_IntCntl
(0510) ;
(0511) ;  DESCRIPTION:
(0512) ;     This function is used to enable/disable the Rx and Tx interrupt.
(0513) ;-----------------------------------------------------------------------------
(0514) ;
(0515) ;  ARGUMENTS:
(0516) ;     A => Interrupt mask
(0517) ;
(0518) ;  RETURNS:
(0519) ;     none.
(0520) ;
(0521) ;  SIDE EFFECTS:
(0522) ;    The A and X registers may be modified by this or future implementations
(0523) ;    of this function.  The same is true for all RAM page pointer registers in
(0524) ;    the Large Memory Model.  When necessary, it is the calling function's
(0525) ;    responsibility to perserve their values across calls to fastcall16 
(0526) ;    functions.
(0527) ;
(0528) ;  THEORY of OPERATION or PROCEDURE:
(0529) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
(0530) ;     and RX block.
(0531) ;
(0532)  UART_1_IntCntl:
(0533) _UART_1_IntCntl:
(0534)    RAM_PROLOGUE RAM_USE_CLASS_1
(0535) 
(0536)    push A
    03F9: 08       PUSH  A
(0537)    and  A,UART_1_ENABLE_RX_INT
    03FA: 21 01    AND   A,1
(0538)    jz   .DisRxInt
    03FC: A0 06    JZ    0x0403
(0539)      ; Enable Rx Interrupt
(0540)    M8C_EnableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
    03FE: 43 E1 08 OR    REG[225],8
(0541)    jmp  .CheckTxInt
    0401: 80 04    JMP   0x0406
(0542) .DisRxInt:
(0543)      ; Disable Rx Interrupt
(0544)    M8C_DisableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
    0403: 41 E1 F7 AND   REG[225],247
(0545) 
(0546) .CheckTxInt:
(0547)    pop  A
    0406: 18       POP   A
(0548)    and  A,UART_1_ENABLE_TX_INT
    0407: 21 02    AND   A,2
(0549)    jz   .DisTxInt
    0409: A0 06    JZ    0x0410
(0550)      ; Enable Tx Interrupt
(0551)    M8C_EnableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
    040B: 43 E1 04 OR    REG[225],4
(0552)    jmp  .End_IntCntl
    040E: 80 04    JMP   0x0413
(0553) .DisTxInt:
(0554)      ; Disable Tx Interrupt
(0555)    M8C_DisableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
    0410: 41 E1 FB AND   REG[225],251
(0556) 
(0557) .End_IntCntl:
(0558)    RAM_EPILOGUE RAM_USE_CLASS_1
(0559)    ret
    0413: 7F       RET   
    0414: 30       HALT  
    0415: 31 32    XOR   A,50
    0417: 33 34    XOR   A,[X+52]
    0419: 35 36    XOR   [X+54],A
    041B: 37 38 39 XOR   [X+56],57
    041E: 41 42 43 AND   REG[66],67
    0421: 44 45 46 OR    REG[X+69],70
(0560) .ENDSECTION
(0561) 
(0562) 
(0563) ;=============================================================================
(0564) ;=============================================================================
(0565) ;
(0566) ;     High-Level Commands
(0567) ;
(0568) ;=============================================================================
(0569) ;=============================================================================
(0570) 
(0571) 
(0572) ;-----------------------------------------------------------------------------
(0573) ;  FUNCTION NAME: UART_1_PutSHexByte
(0574) ;
(0575) ;  DESCRIPTION:
(0576) ;     Print a byte in Hex (two characters) to the UART Tx
(0577) ;-----------------------------------------------------------------------------
(0578) ;
(0579) ;  ARGUMENTS:
(0580) ;     A  => (BYTE) Data/char to be printed
(0581) ;
(0582) ;  RETURNS:
(0583) ;     none.
(0584) ;
(0585) ;  SIDE EFFECTS:
(0586) ;    The A and X registers may be modified by this or future implementations
(0587) ;    of this function.  The same is true for all RAM page pointer registers in
(0588) ;    the Large Memory Model.  When necessary, it is the calling function's
(0589) ;    responsibility to perserve their values across calls to fastcall16 
(0590) ;    functions.
(0591) ;
(0592) .LITERAL
(0593) UART_1_HEX_STR:
(0594)      DS    "0123456789ABCDEF"
(0595) .ENDLITERAL
(0596) 
(0597) .SECTION
(0598)  UART_1_PutSHexByte:
(0599) _UART_1_PutSHexByte:
(0600)    RAM_PROLOGUE RAM_USE_CLASS_1
(0601)    push  A                             ; Save lower nibble
    0424: 08       PUSH  A
(0602)    asr   A                             ; Shift high nibble to right
    0425: 67       ASR   A
(0603)    asr   A
    0426: 67       ASR   A
(0604)    asr   A
    0427: 67       ASR   A
(0605)    asr   A
    0428: 67       ASR   A
(0606)    and   A,0Fh                         ; Mask off nibble
    0429: 21 0F    AND   A,15
(0607)    index UART_1_HEX_STR                ; Get Hex value
    042B: FF E7    INDEX 0x0414
(0608)    call  UART_1_PutChar                ; Write data to screen
    042D: 90 0F    CALL  0x043E
(0609)    pop   A                             ; Restore value
    042F: 18       POP   A
(0610)    and   A,0Fh                         ; Mask off lower nibble
    0430: 21 0F    AND   A,15
(0611)    index UART_1_HEX_STR                ; Get Hex value
    0432: FF E0    INDEX 0x0414
(0612)    call  UART_1_PutChar                ; Write data to screen
    0434: 90 08    CALL  0x043E
(0613)    RAM_EPILOGUE RAM_USE_CLASS_1
(0614)    ret
    0436: 7F       RET   
(0615) .ENDSECTION
(0616) 
(0617) 
(0618) .SECTION
(0619) ;-----------------------------------------------------------------------------
(0620) ;  FUNCTION NAME: UART_1_PutSHexInt
(0621) ;
(0622) ;  DESCRIPTION:
(0623) ;     Print an Int in Hex (four characters) to UART Tx
(0624) ;-----------------------------------------------------------------------------
(0625) ;
(0626) ;  ARGUMENTS:
(0627) ;     Pointer to string
(0628) ;     A  => ASB of Int
(0629) ;     X  => MSB of Int
(0630) ;
(0631) ;  RETURNS:
(0632) ;     none.
(0633) ;
(0634) ;  SIDE EFFECTS:
(0635) ;    The A and X registers may be modified by this or future implementations
(0636) ;    of this function.  The same is true for all RAM page pointer registers in
(0637) ;    the Large Memory Model.  When necessary, it is the calling function's
(0638) ;    responsibility to perserve their values across calls to fastcall16 
(0639) ;    functions.
(0640) ;
(0641) 
(0642)  UART_1_PutSHexInt:
(0643) _UART_1_PutSHexInt:
(0644)    RAM_PROLOGUE RAM_USE_CLASS_1
(0645)    swap  A,X
    0437: 4B       SWAP  A,X
(0646)    call  UART_1_PutSHexByte            ; Print MSB
    0438: 9F EA    CALL  0x0424
(0647)    mov   A,X                           ; Move LSB into position
    043A: 5B       MOV   A,X
(0648)    call  UART_1_PutSHexByte            ; Print LSB
    043B: 9F E7    CALL  0x0424
(0649)    RAM_EPILOGUE RAM_USE_CLASS_1
(0650)    ret
    043D: 7F       RET   
    043E: 49 2B 10 TST   REG[43],16
(0651) .ENDSECTION
(0652) 
(0653) 
(0654) .SECTION
(0655) ;-----------------------------------------------------------------------------
(0656) ;  FUNCTION NAME: UART_1_PutChar
(0657) ;
(0658) ;  DESCRIPTION:
(0659) ;     Send character out through UART TX port.
(0660) ;-----------------------------------------------------------------------------
(0661) ;
(0662) ;  ARGUMENTS:
(0663) ;     A has Character to send to UART Tx Port
(0664) ;
(0665) ;  RETURNS:
(0666) ;     none
(0667) ;
(0668) ;  SIDE EFFECTS:
(0669) ;    The A and X registers may be modified by this or future implementations
(0670) ;    of this function.  The same is true for all RAM page pointer registers in
(0671) ;    the Large Memory Model.  When necessary, it is the calling function's
(0672) ;    responsibility to perserve their values across calls to fastcall16 
(0673) ;    functions.
(0674) ;
(0675) 
(0676)    macro InLinePutChar( Source )
(0677) .BufEmptyWaitLoop:
(0678)    tst REG[UART_1_TX_CONTROL_REG], UART_1_TX_BUFFER_EMPTY     ; Check Tx Status
(0679)    jz  .BufEmptyWaitLoop
(0680)    mov REG[UART_1_TX_BUFFER_REG], @Source        ; Write data to Tx Port
(0681)    endm
(0682) 
(0683)  UART_1_PutChar:
(0684) _UART_1_PutChar:
(0685)    RAM_PROLOGUE RAM_USE_CLASS_1
(0686)    InLinePutChar A
    0441: AF FC    JZ    0x043E
    0443: 60 29    MOV   REG[41],A
(0687)    RAM_EPILOGUE RAM_USE_CLASS_1
(0688)    ret
    0445: 7F       RET   
(0689) .ENDSECTION
(0690) 
(0691) 
(0692) .SECTION
(0693) ;-----------------------------------------------------------------------------
(0694) ;  FUNCTION NAME: UART_1_cGetChar
(0695) ;
(0696) ;  DESCRIPTION:
(0697) ;     Read character from UART RX port.
(0698) ;-----------------------------------------------------------------------------
(0699) ;
(0700) ;  ARGUMENTS:
(0701) ;      none
(0702) ;
(0703) ;  RETURNS:
(0704) ;     char that is returned from UART
(0705) ;
(0706) ;  SIDE EFFECTS:
(0707) ;    The A and X registers may be modified by this or future implementations
(0708) ;    of this function.  The same is true for all RAM page pointer registers in
(0709) ;    the Large Memory Model.  When necessary, it is the calling function's
(0710) ;    responsibility to perserve their values across calls to fastcall16 
(0711) ;    functions.
(0712) ;
(0713) ;    Program flow will stay in this function until a character is received.
(0714) ;    If the watchdog timer is used, care must be taken to make sure that
(0715) ;    the delay between characters is less than the watchdog timeout.
(0716) ;
(0717)  UART_1_cGetChar:
(0718) _UART_1_cGetChar:
(0719)    RAM_PROLOGUE RAM_USE_CLASS_1
(0720)    tst REG[UART_1_RX_CONTROL_REG],UART_1_RX_REG_FULL    ; Check if a character is ready
    0446: 49 2F 08 TST   REG[47],8
(0721)    jz  UART_1_cGetChar                              ; If not loop
    0449: AF FC    JZ    0x0446
(0722)    mov A, REG[UART_1_RX_BUFFER_REG]                 ; Get character
    044B: 5D 2E    MOV   A,REG[46]
(0723)    RAM_EPILOGUE RAM_USE_CLASS_1
(0724)    ret
    044D: 7F       RET   
(0725) .ENDSECTION
(0726) 
(0727) 
(0728) .SECTION
(0729) ;-----------------------------------------------------------------------------
(0730) ;  FUNCTION NAME: UART_1_cReadChar
(0731) ;
(0732) ;  DESCRIPTION:
(0733) ;     Read character from UART RX port.
(0734) ;-----------------------------------------------------------------------------
(0735) ;
(0736) ;  ARGUMENTS:
(0737) ;      none
(0738) ;
(0739) ;  RETURNS:
(0740) ;     char that is returned from UART
(0741) ;
(0742) ;  SIDE EFFECTS:
(0743) ;    The A and X registers may be modified by this or future implementations
(0744) ;    of this function.  The same is true for all RAM page pointer registers in
(0745) ;    the Large Memory Model.  When necessary, it is the calling function's
(0746) ;    responsibility to perserve their values across calls to fastcall16 
(0747) ;    functions.
(0748) ;
(0749) ;    A valid 0x00 character will be ignored, since a 0x00 return value
(0750) ;    implies a valid character or an error condition occured.
(0751) ;
(0752)  UART_1_cReadChar:
(0753) _UART_1_cReadChar:
(0754)    RAM_PROLOGUE RAM_USE_CLASS_1
(0755)    mov  A,REG[UART_1_RX_CONTROL_REG]                       ; Get Status of RX
    044E: 5D 2F    MOV   A,REG[47]
(0756)    push A
    0450: 08       PUSH  A
(0757)    and  A,UART_1_RX_COMPLETE                               ; Check if a character is ready
    0451: 21 08    AND   A,8
(0758)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
    0453: B0 04    JNZ   0x0458
(0759)    pop  A
    0455: 18       POP   A
(0760)    jmp  .RX_NO_VALID_CHAR
    0456: 80 0B    JMP   0x0462
(0761) 
(0762) .RX_DATA_RDY:
(0763)    mov  A,REG[UART_1_RX_BUFFER_REG ]          
    0458: 5D 2E    MOV   A,REG[46]
(0764)    swap A,X                                                ; determine if data is valid
    045A: 4B       SWAP  A,X
(0765) 
(0766)    pop  A                                                  ; Check for errors
    045B: 18       POP   A
(0767)    and  A,(UART_1_RX_PARITY_ERROR | UART_1_RX_FRAMING_ERROR)
    045C: 21 A0    AND   A,160
(0768)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
    045E: B0 03    JNZ   0x0462
(0769)    swap A,X                                                ; Put data in A and exit
    0460: 4B       SWAP  A,X
(0770)    RAM_EPILOGUE RAM_USE_CLASS_1
(0771)    ret
    0461: 7F       RET   
(0772) 
(0773) .RX_NO_VALID_CHAR:
(0774)    mov A,0x00                                              ; Zero out character
    0462: 50 00    MOV   A,0
(0775) 
(0776)  End_UART_1_cReadChar:
(0777)    RAM_EPILOGUE RAM_USE_CLASS_1
(0778)    ret
    0464: 7F       RET   
(0779) .ENDSECTION
(0780) 
(0781) 
(0782) .SECTION
(0783) ;-----------------------------------------------------------------------------
(0784) ;  FUNCTION NAME: UART_1_iReadChar
(0785) ;
(0786) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
(0787) ;  to just set a value in the upper byte if error conditions exists.
(0788) ;
(0789) ;  DESCRIPTION:
(0790) ;     Read character from UART RX port.
(0791) ;-----------------------------------------------------------------------------
(0792) ;
(0793) ;  ARGUMENTS:
(0794) ;      none
(0795) ;
(0796) ;  RETURNS:
(0797) ;     An integer value is returned.  A negative value inplies and error
(0798) ;     condition, a positive value between 0 and 255 is the return character.
(0799) ;
(0800) ;     Error Codes:
(0801) ;        0x80CC    Parity Error
(0802) ;        0x40CC    Overrun Error
(0803) ;        0x20CC    Framing Error
(0804) ;        0x01CC    No Data available
(0805) ;
(0806) ;  SIDE EFFECTS:
(0807) ;    The A and X registers may be modified by this or future implementations
(0808) ;    of this function.  The same is true for all RAM page pointer registers in
(0809) ;    the Large Memory Model.  When necessary, it is the calling function's
(0810) ;    responsibility to perserve their values across calls to fastcall16 
(0811) ;    functions.
(0812) ;
(0813)  UART_1_iReadChar:
(0814) _UART_1_iReadChar:
(0815)    RAM_PROLOGUE RAM_USE_CLASS_1
(0816)    mov  A,REG[UART_1_RX_CONTROL_REG]                       ; Get Status of RX
    0465: 5D 2F    MOV   A,REG[47]
(0817)                                                            ; Mask only errors and data ready
(0818)    and  A,(UART_1_RX_ERROR|UART_1_RX_REG_FULL)
    0467: 21 E8    AND   A,232
(0819)    push A
    0469: 08       PUSH  A
(0820)    and  A,UART_1_RX_COMPLETE                               ; Check if a character is ready
    046A: 21 08    AND   A,8
(0821)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
    046C: B0 07    JNZ   0x0474
(0822)    pop  A
    046E: 18       POP   A
(0823)    or   A,UART_1_RX_NO_DATA                                ; Add no data flag
    046F: 29 01    OR    A,1
(0824)    swap A,X
    0471: 4B       SWAP  A,X
(0825)    jmp  End_UART_1_iReadChar
    0472: 80 07    JMP   0x047A
(0826) 
(0827) .RX_GET_DATA:
(0828)    pop  A
    0474: 18       POP   A
(0829)    and  A,UART_1_RX_ERROR
    0475: 21 E0    AND   A,224
(0830)    swap A,X
    0477: 4B       SWAP  A,X
(0831)    mov  A,REG[UART_1_RX_BUFFER_REG ]                       ; Read data first, then
    0478: 5D 2E    MOV   A,REG[46]
(0832)                                                            ; determine if data is valid
(0833) 
(0834)  End_UART_1_iReadChar:
(0835)    RAM_EPILOGUE RAM_USE_CLASS_1
(0836)    ret
    047A: 7F       RET   
(0837) .ENDSECTION
(0838) 
(0839) 
(0840) .SECTION
(0841) ;-----------------------------------------------------------------------------
(0842) ;  FUNCTION NAME: UART_1_PutString
(0843) ;
(0844) ;  DESCRIPTION:
(0845) ;     Send String out through UART TX port.
(0846) ;-----------------------------------------------------------------------------
(0847) ;
(0848) ;  ARGUMENTS:
(0849) ;     Pointer to String
(0850) ;     A has MSB of string address
(0851) ;     X has LSB of string address
(0852) ;
(0853) ;  RETURNS:
(0854) ;     none
(0855) ;
(0856) ;  SIDE EFFECTS:
(0857) ;    The A and X registers may be modified by this or future implementations
(0858) ;    of this function.  The same is true for all RAM page pointer registers in
(0859) ;    the Large Memory Model.  When necessary, it is the calling function's
(0860) ;    responsibility to perserve their values across calls to fastcall16 
(0861) ;    functions.
(0862) ;          
(0863) ;    Currently only the page pointer registers listed below are modified: 
(0864) ;          IDX_PP
(0865) ;
(0866)  UART_1_PutString:
(0867) _UART_1_PutString:
(0868)    RAM_PROLOGUE RAM_USE_CLASS_3
    047B: 70 BF    AND   F,191
(0869)    RAM_SETPAGE_IDX A
    047D: 60 D3    MOV   REG[211],A
(0870) .PutStringLoop:
(0871)    mov   A,[X]                                   ; Get value pointed to by X
    047F: 52 00    MOV   A,[X+0]
(0872)    jz    End_PutString                           ; Check for end of string
    0481: A0 06    JZ    0x0488
(0873)    call  UART_1_PutChar                          ; Send character to Tx port
    0483: 9F B9    CALL  0x043E
(0874)    inc   X                                       ; Advance pointer to next character
    0485: 75       INC   X
(0875)    jmp   .PutStringLoop                          ; Get next character
    0486: 8F F8    JMP   0x047F
    0488: 70 3F    AND   F,63
(0876) 
(0877) End_PutString:
(0878)    RAM_EPILOGUE RAM_USE_CLASS_3
    048A: 71 C0    OR    F,192
(0879)    ret
    048C: 7F       RET   
(0880) .ENDSECTION
(0881)     
(0882) .SECTION
(0883) ;-----------------------------------------------------------------------------
(0884) ;  FUNCTION NAME: UART_1_Write
(0885) ;
(0886) ;  DESCRIPTION:
(0887) ;     Send String of length X to serial port
(0888) ;-----------------------------------------------------------------------------
(0889) ;
(0890) ;  ARGUMENTS:
(0891) ;     Pointer to String
(0892) ;     [SP-5] Count of characters to send
(0893) ;     [SP-4] has MSB of string address
(0894) ;     [SP-3] has LSB of string address
(0895) ;
(0896) ;  RETURNS:
(0897) ;     none
(0898) ;
(0899) ;  SIDE EFFECTS:
(0900) ;    The A and X registers may be modified by this or future implementations
(0901) ;    of this function.  The same is true for all RAM page pointer registers in
(0902) ;    the Large Memory Model.  When necessary, it is the calling function's
(0903) ;    responsibility to perserve their values across calls to fastcall16 
(0904) ;    functions.
(0905) ;          
(0906) ;    Currently only the page pointer registers listed below are modified: 
(0907) ;          IDX_PP
(0908) ;
(0909) CNT_LEN:    equ -5                               ; Length of data to send
(0910) STR_MSB:    equ -4                               ; MSB pointer of string 
(0911) STR_LSB:    equ -3                               ; LSB pointer of string 
(0912) 
(0913)  UART_1_Write:
(0914) _UART_1_Write:
(0915)    RAM_PROLOGUE RAM_USE_CLASS_3
    048D: 70 BF    AND   F,191
(0916)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
    048F: 62 D3 07 MOV   REG[211],7
(0917)    mov   X, SP                                   ; Establish the frame pointer 
    0492: 4F       MOV   X,SP
(0918) 
(0919) .NextByteLoop:
(0920)    mov   A, [X+CNT_LEN]                          ; End of the string?
    0493: 52 FB    MOV   A,[X-5]
(0921)    jz    .End_Write                              ;   Yes, prepare to exit
    0495: A0 1A    JZ    0x04B0
(0922)    dec   [X+CNT_LEN]                             ; Decrement counter
    0497: 7B FB    DEC   [X-5]
(0923) 
(0924)    IF SYSTEM_LARGE_MEMORY_MODEL
(0925)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
    0499: 52 FC    MOV   A,[X-4]
(0926)    ENDIF
(0927) 
(0928)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
    049B: 59 FD    MOV   X,[X-3]
(0929)    RAM_SETPAGE_IDX A                             ; switch index pages
    049D: 60 D3    MOV   REG[211],A
(0930)    mov   A, [X]                                  ; Grab the data
    049F: 52 00    MOV   A,[X+0]
    04A1: 49 2B 10 TST   REG[43],16
(0931)    InlinePutChar A                               ; Put data in empty TX buf reg
    04A4: AF FC    JZ    0x04A1
    04A6: 60 29    MOV   REG[41],A
(0932)    mov   X, SP                                   ; Recover frame pointer
    04A8: 4F       MOV   X,SP
(0933)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
    04A9: 62 D3 07 MOV   REG[211],7
(0934)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
    04AC: 77 FD    INC   [X-3]
(0935)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
    04AE: 8F E4    JMP   0x0493
    04B0: 70 3F    AND   F,63
(0936) 
(0937) .End_Write:
(0938)    RAM_EPILOGUE RAM_USE_CLASS_3
    04B2: 71 C0    OR    F,192
(0939)    ret
    04B4: 7F       RET   
(0940) .ENDSECTION
(0941)     
(0942) 
(0943) .SECTION
(0944) ;-----------------------------------------------------------------------------
(0945) ;  FUNCTION NAME: UART_1_CWrite
(0946) ;
(0947) ;             WARNING WARNING NOT COMPLETE
(0948) ;
(0949) ;  DESCRIPTION:
(0950) ;     Send String of length X to serial port
(0951) ;-----------------------------------------------------------------------------
(0952) ;
(0953) ;  ARGUMENTS:
(0954) ;     [SP-4] MSB of Count of character to send
(0955) ;     [SP-3] LSB of Count of character to send
(0956) ;     [SP-2] has MSB of string address
(0957) ;     [SP-1] has LSB of string address
(0958) ;
(0959) ;  RETURNS:
(0960) ;     none
(0961) ;
(0962) ;  SIDE EFFECTS:
(0963) ;    The A and X registers may be modified by this or future implementations
(0964) ;    of this function.  The same is true for all RAM page pointer registers in
(0965) ;    the Large Memory Model.  When necessary, it is the calling function's
(0966) ;    responsibility to perserve their values across calls to fastcall16 
(0967) ;    functions.
(0968) ;
(0969) CLEN_MSB:   equ -6           ; MSB Length of data to send
(0970) CLEN_LSB:   equ -5           ; LSB Length of data to send
(0971) CSTR_MSB:   equ -4           ; MSB pointer of string
(0972) CSTR_LSB:   equ -3           ; LSB pointer of string
(0973) 
(0974)  UART_1_CWrite:
(0975) _UART_1_CWrite:
(0976)    RAM_PROLOGUE RAM_USE_CLASS_2
(0977)    mov   X,SP
    04B5: 4F       MOV   X,SP
(0978) .CW_Loop:
(0979)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
    04B6: 3D FA 00 CMP   [X-6],0
(0980)    jnz   .CW_WRITEIT
    04B9: B0 06    JNZ   0x04C0
(0981)    cmp   [X+CLEN_LSB],0x00
    04BB: 3D FB 00 CMP   [X-5],0
(0982)    jz    .End_CWrite                        ; Leave if done
    04BE: A0 1D    JZ    0x04DC
(0983) 
(0984) .CW_WRITEIT:                                
(0985)    push  X                                  ; Save frame pointer
    04C0: 10       PUSH  X
(0986)    mov   A,[X+CSTR_MSB]
    04C1: 52 FC    MOV   A,[X-4]
(0987)    mov   X,[X+CSTR_LSB]
    04C3: 59 FD    MOV   X,[X-3]
(0988)    romx                                     ; Get character from ROM
    04C5: 28       ROMX  
    04C6: 49 2B 10 TST   REG[43],16
(0989)    InlinePutChar A                          ; Put data in empty TX buf reg
    04C9: AF FC    JZ    0x04C6
    04CB: 60 29    MOV   REG[41],A
(0990)    pop   X                                  ; Restore frame pointer
    04CD: 20       POP   X
(0991)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
    04CE: 07 FD 01 ADD   [X-3],1
(0992)    adc   [X+CSTR_MSB],0
    04D1: 0F FC 00 ADC   [X-4],0
(0993)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
    04D4: 17 FB 01 SUB   [X-5],1
(0994)    sbb   [X+CLEN_MSB],0x00
    04D7: 1F FA 00 SBB   [X-6],0
(0995)    jmp   .CW_Loop
    04DA: 8F DB    JMP   0x04B6
    04DC: 70 3F    AND   F,63
(0996) 
(0997) .End_CWrite:
(0998)    RAM_EPILOGUE RAM_USE_CLASS_2
    04DE: 71 C0    OR    F,192
(0999)    ret
    04E0: 7F       RET   
(1000) .ENDSECTION
(1001) 
(1002) 
(1003) .SECTION
(1004) ;-----------------------------------------------------------------------------
(1005) ;  FUNCTION NAME: UART_1_CPutString
(1006) ;
(1007) ;  DESCRIPTION:
(1008) ;     Send String out through UART TX port.
(1009) ;-----------------------------------------------------------------------------
(1010) ;
(1011) ;  ARGUMENTS:
(1012) ;     Pointer to String
(1013) ;     A has MSB of string address
(1014) ;     X has LSB of string address
(1015) ;
(1016) ;  RETURNS:
(1017) ;     none
(1018) ;
(1019) ;  SIDE EFFECTS:
(1020) ;    The A and X registers may be modified by this or future implementations
(1021) ;    of this function.  The same is true for all RAM page pointer registers in
(1022) ;    the Large Memory Model.  When necessary, it is the calling function's
(1023) ;    responsibility to perserve their values across calls to fastcall16 
(1024) ;    functions.
(1025) ;
(1026)  UART_1_CPutString:
(1027) _UART_1_CPutString:
(1028)    RAM_PROLOGUE RAM_USE_CLASS_1
(1029)    push  A                                       ; Store ROM pointer
    04E1: 08       PUSH  A
(1030)    push  X
    04E2: 10       PUSH  X
(1031)    romx                                          ; Get character from ROM
    04E3: 28       ROMX  
(1032)    jz    .End_CPutString
    04E4: A0 0B    JZ    0x04F0
(1033)    call  UART_1_PutChar                          ; Print character
    04E6: 9F 56    CALL  0x043E
(1034)    pop   X
    04E8: 20       POP   X
(1035)    pop   A
    04E9: 18       POP   A
(1036)    inc   X                                       ; Inc LSB of pointer
    04EA: 75       INC   X
(1037)    jnc   UART_1_CPutString                       ; Check for carry
    04EB: DF F5    JNC   0x04E1
(1038)    inc   A                                       ; Inc MSB of pointer
    04ED: 74       INC   A
(1039)    jmp   UART_1_CPutString
    04EE: 8F F2    JMP   0x04E1
(1040) 
(1041) 
(1042) .End_CPutString:
(1043)    add   SP, -2
    04F0: 38 FE    ADD   SP,254
(1044)    RAM_EPILOGUE RAM_USE_CLASS_1
(1045)    ret
    04F2: 7F       RET   
(1046) .ENDSECTION
(1047) 
(1048) 
(1049) .SECTION
(1050) ;-----------------------------------------------------------------------------
(1051) ;  FUNCTION NAME: UART_1_PutCRLF
(1052) ;
(1053) ;  DESCRIPTION:
(1054) ;     Send a CR and LF
(1055) ;-----------------------------------------------------------------------------
(1056) ;
(1057) ;  ARGUMENTS:
(1058) ;     none.
(1059) ;
(1060) ;  RETURNS:
(1061) ;     none.
(1062) ;
(1063) ;  SIDE EFFECTS:
(1064) ;    The A and X registers may be modified by this or future implementations
(1065) ;    of this function.  The same is true for all RAM page pointer registers in
(1066) ;    the Large Memory Model.  When necessary, it is the calling function's
(1067) ;    responsibility to perserve their values across calls to fastcall16 
(1068) ;    functions.
(1069) ;
(1070)  UART_1_PutCRLF:
(1071) _UART_1_PutCRLF:
(1072)    RAM_PROLOGUE RAM_USE_CLASS_1
(1073)    mov  A,0x0D                        ; Send CR
    04F3: 50 0D    MOV   A,13
(1074)    call UART_1_PutChar
    04F5: 9F 47    CALL  0x043E
(1075)    mov  A,0x0A                        ; Send LF
    04F7: 50 0A    MOV   A,10
(1076)    call UART_1_PutChar
    04F9: 9F 43    CALL  0x043E
(1077)    RAM_EPILOGUE RAM_USE_CLASS_1
(1078)    ret
    04FB: 7F       RET   
FILE: lib\pga_1.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  FILENAME:   PGA_1.asm  ( PGA )
(0004) ;;  Version: 3.2, Updated on 2005/10/03 at 13:04:43
(0005) ;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0006) ;;
(0007) ;;  DESCRIPTION:  PGA User Module software implementation file for the
(0008) ;;                22/24/27/29xxx PSoC family of devices.
(0009) ;;
(0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
(0011) ;;        arguments and observe the associated "Registers are volatile" policy.
(0012) ;;        This means it is the caller's responsibility to preserve any values
(0013) ;;        in the X and A registers that are still needed after the API functions
(0014) ;;        returns. For Large Memory Model devices it is also the caller's 
(0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
(0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
(0017) ;;        now, there is no guarantee that will remain the case in future releases.
(0018) ;;-----------------------------------------------------------------------------
(0019) ;;  Copyright (c) Cypress MicroSystems 2004. All Rights Reserved.
(0020) ;;*****************************************************************************
(0021) ;;*****************************************************************************
(0022) 
(0023) ;; -----------------------------------------------------------------
(0024) ;;                         Register Definitions
(0025) ;;
(0026) ;; Uses 1 Continuous Time Block configured as shown.
(0027) ;;
(0028) ;; * For a Mask/Val pair, this indicates that the value is
(0029) ;;   determined by the user either through config-time parameteriza-
(0030) ;;   tion or run-time manipulation.
(0031) ;;
(0032) ;; BIT FIELD             Mask/Val Function
(0033) ;; -----------------            -----   --------------------
(0034) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
(0035) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
(0036) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
(0037) ;; GAIN_CR0.RES_REF             03/*    Res ref
(0038) ;;
(0039) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
(0040) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
(0041) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
(0042) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
(0043) ;;
(0044) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
(0045) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
(0046) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
(0047) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
(0048) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
(0049) ;;
(0050) ;; --------------------------------------------------------------------
(0051) 
(0052) include "PGA_1.inc"
(0053) include "m8c.inc"
(0054) include "memory.inc"
(0055) 
(0056) 
(0057) ;-----------------------------------------------
(0058) ;  Global Symbols
(0059) ;-----------------------------------------------
(0060) export  PGA_1_Start
(0061) export _PGA_1_Start
(0062) export  PGA_1_SetPower
(0063) export _PGA_1_SetPower
(0064) 
(0065) export  PGA_1_SetGain
(0066) export _PGA_1_SetGain
(0067) 
(0068) export  PGA_1_Stop
(0069) export _PGA_1_Stop
(0070) 
(0071) ;-----------------------------------------------
(0072) ;  EQUATES
(0073) ;-----------------------------------------------
(0074) POWERMASK:     equ 03h
(0075) GAINREGMASK:   equ f8h
(0076) GAINMASK:      equ fCh
(0077) HIGHGAIN:      equ 04h
(0078) HIGHGAINMASK:  equ 18h
(0079) EXGAIN:        equ 01h
(0080) 
(0081) AREA UserModules (ROM, REL)
(0082) .SECTION
(0083) ;-----------------------------------------------------------------------------
(0084) ;  FUNCTION NAME: PGA_1_Start
(0085) ;  FUNCTION NAME: PGA_1_SetPower
(0086) ;
(0087) ;  DESCRIPTION:
(0088) ;    Applies power setting to the module's PSoC block.
(0089) ;-----------------------------------------------------------------------------
(0090) ;
(0091) ;  ARGUMENTS:
(0092) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High
(0093) ;
(0094) ;  RETURNS:  NA
(0095) ;
(0096) ;  SIDE EFFECTS:
(0097) ;    The A and X registers may be modified by this or future implementations
(0098) ;    of this function.  The same is true for all RAM page pointer registers in
(0099) ;    the Large Memory Model.  When necessary, it is the calling function's
(0100) ;    responsibility to perserve their values across calls to fastcall16 
(0101) ;    functions.
(0102) ;
(0103)  PGA_1_Start:
(0104) _PGA_1_Start:
(0105)  PGA_1_SetPower:
(0106) _PGA_1_SetPower:
(0107) 
(0108)    RAM_PROLOGUE RAM_USE_CLASS_2
(0109)    and  A, POWERMASK                                 ; mask A to protect unchanged bits
    04FC: 21 03    AND   A,3
(0110)    mov  X, SP                                        ; define temp store location
    04FE: 4F       MOV   X,SP
(0111) ;
(0112)    push A                                            ; put power value in temp store
    04FF: 08       PUSH  A
(0113)    mov  A, reg[PGA_1_GAIN_CR2]                             ; read power value
    0500: 5D 77    MOV   A,REG[119]
(0114)    and  A, ~POWERMASK                                ; clear power bits in A
    0502: 21 FC    AND   A,252
(0115)    or   A, [X]                                       ; combine power value with balance of reg.
    0504: 2B 00    OR    A,[X+0]
(0116)    mov  reg[PGA_1_GAIN_CR2], A                        ; move complete value back to register
    0506: 60 77    MOV   REG[119],A
(0117)    pop  A
    0508: 18       POP   A
    0509: 70 3F    AND   F,63
(0118)    RAM_EPILOGUE RAM_USE_CLASS_2
    050B: 71 C0    OR    F,192
(0119)    ret
    050D: 7F       RET   
(0120) .ENDSECTION
(0121) 
(0122) .SECTION
(0123) ;-----------------------------------------------------------------------------
(0124) ;  FUNCTION NAME: PGA_1_SetGain
(0125) ;
(0126) ;  DESCRIPTION:
(0127) ;    This function sets the Gain/Atten of the amplifier.  Valid gain settings
(0128) ;    are defined in the .inc file.
(0129) ;
(0130) ;-----------------------------------------------------------------------------
(0131) ;
(0132) ;  ARGUMENTS:
(0133) ;    A  Contains gain settings.
(0134) ;
(0135) ;    Gain values shown are for example. (See .inc file for gain equates)
(0136) ;
(0137) ;  RETURNS:  NA
(0138) ;
(0139) ;  SIDE EFFECTS:
(0140) ;    The A and X registers may be modified by this or future implementations
(0141) ;    of this function.  The same is true for all RAM page pointer registers in
(0142) ;    the Large Memory Model.  When necessary, it is the calling function's
(0143) ;    responsibility to perserve their values across calls to fastcall16 
(0144) ;    functions.
(0145) ;
(0146)  PGA_1_SetGain:
(0147) _PGA_1_SetGain:
(0148) 
(0149)    RAM_PROLOGUE RAM_USE_CLASS_2
(0150)    and  A, GAINMASK                                       ; mask A to protect unchanged bits
    050E: 21 FC    AND   A,252
(0151)    mov  X, SP                                             ; define temp store location
    0510: 4F       MOV   X,SP
(0152) ;
(0153)    push A                                                 ; put gain value in temp store
    0511: 08       PUSH  A
(0154)    mov  A, reg[PGA_1_GAIN_CR0]                             ; read mux settings
    0512: 5D 75    MOV   A,REG[117]
(0155)    and  A, ~GAINREGMASK                                   ; clear gain bits in A
    0514: 21 07    AND   A,7
(0156)    tst  [X],HIGHGAIN                                      ; See if High Gain is set
    0516: 48 00 04 TST   [X+0],4
(0157)    jnz  .SETHIGHGAIN
    0519: B0 0E    JNZ   0x0528
(0158)    and  reg[PGA_1_GAIN_CR3],~EXGAIN                        ; Clear High Gain bit.
    051B: 41 74 FE AND   REG[116],254
(0159)    or   A, [X]                                            ; combine gain value with balance of reg.
    051E: 2B 00    OR    A,[X+0]
(0160)    mov  reg[PGA_1_GAIN_CR0], A                             ; move complete value back to register
    0520: 60 75    MOV   REG[117],A
(0161)    pop  A
    0522: 18       POP   A
    0523: 70 3F    AND   F,63
(0162)    RAM_EPILOGUE RAM_USE_CLASS_2
    0525: 71 C0    OR    F,192
(0163)    ret
    0527: 7F       RET   
(0164) 
(0165) .SETHIGHGAIN:
(0166)    and  [X],HIGHGAINMASK                                  ; Make sure we have a valid high gain
    0528: 27 00 18 AND   [X+0],24
(0167)    or   A, [X]                                            ; combine gain value with balance of reg.
    052B: 2B 00    OR    A,[X+0]
(0168)    mov  reg[PGA_1_GAIN_CR0], A                             ; move complete value back to register
    052D: 60 75    MOV   REG[117],A
(0169)    or   reg[PGA_1_GAIN_CR3], EXGAIN                        ; Set High Gain bit.
    052F: 43 74 01 OR    REG[116],1
(0170)    pop  A
    0532: 18       POP   A
    0533: 70 3F    AND   F,63
(0171)    RAM_EPILOGUE RAM_USE_CLASS_2
    0535: 71 C0    OR    F,192
(0172)    ret
    0537: 7F       RET   
(0173) .ENDSECTION
(0174) 
(0175) .SECTION
(0176) ;-----------------------------------------------------------------------------
(0177) ;  FUNCTION NAME: PGA_1_Stop
(0178) ;
(0179) ;  DESCRIPTION:
(0180) ;    Turns off the power to the amplifier.
(0181) ;
(0182) ;-----------------------------------------------------------------------------
(0183) ;
(0184) ;  ARGUMENTS: None
(0185) ;
(0186) ;  RETURNS:  NA
(0187) ;
(0188) ;  SIDE EFFECTS:
(0189) ;    The A and X registers may be modified by this or future implementations
(0190) ;    of this function.  The same is true for all RAM page pointer registers in
(0191) ;    the Large Memory Model.  When necessary, it is the calling function's
(0192) ;    responsibility to perserve their values across calls to fastcall16 
(0193) ;    functions.
(0194) ;
(0195)  PGA_1_Stop:
(0196) _PGA_1_Stop:
(0197) 
(0198)    RAM_PROLOGUE RAM_USE_CLASS_1
(0199)    and REG[PGA_1_GAIN_CR2], ~POWERMASK
    0538: 41 77 FC AND   REG[119],252
(0200)    RAM_EPILOGUE RAM_USE_CLASS_1
(0201)    ret
    053B: 7F       RET   
FILE: lib\lcd_1.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  FILENAME:   LCD_1.asm
(0004) ;;  Version: 1.4, Updated on 2005/09/30 at 10:52:22
(0005) ;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0006) ;;
(0007) ;;  DESCRIPTION: LCD User Module software implementation file
(0008) ;;               for 22/24/25/26/27xxx PSoC family of devices.
(0009) ;;
(0010) ;; This set of functions is written for the common 2 and 4 line
(0011) ;; LCDs that use the Hitachi HD44780A controller.
(0012) ;;
(0013) ;;  LCD connections to PSoC port
(0014) ;;
(0015) ;;    PX.0 ==> LCD D4
(0016) ;;    PX.1 ==> LCD D5
(0017) ;;    PX.2 ==> LCD D6
(0018) ;;    PX.3 ==> LCD D7
(0019) ;;    PX.4 ==> LCD E
(0020) ;;    PX.5 ==> LCD RS
(0021) ;;    PX.6 ==> LCD R/W
(0022) ;;
(0023) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
(0024) ;;        arguments and observe the associated "Registers are volatile" policy.
(0025) ;;        This means it is the caller's responsibility to preserve any values
(0026) ;;        in the X and A registers that are still needed after the API functions
(0027) ;;        returns. For Large Memory Model devices it is also the caller's 
(0028) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
(0029) ;;        MVW_PP registers. Even though some of these registers may not be modified
(0030) ;;        now, there is no guarantee that will remain the case in future releases.
(0031) ;;-----------------------------------------------------------------------------
(0032) ;;  Copyright (c) Cypress MicroSystems 2001-2003. All Rights Reserved.
(0033) ;;*****************************************************************************
(0034) ;;*****************************************************************************
(0035) 
(0036) include "m8c.inc"
(0037) include "memory.inc"
(0038) include "LCD_1.inc"
(0039) 
(0040) ;-----------------------------------------------
(0041) ;  Global Symbols
(0042) ;-----------------------------------------------
(0043) 
(0044) export   LCD_1_Start
(0045) export  _LCD_1_Start
(0046) export   LCD_1_Init
(0047) export  _LCD_1_Init
(0048) 
(0049) export   LCD_1_WriteData
(0050) export  _LCD_1_WriteData
(0051) 
(0052) export   LCD_1_Control
(0053) export  _LCD_1_Control
(0054) 
(0055) export  LCD_1_PrString
(0056) export _LCD_1_PrString
(0057) 
(0058) export  LCD_1_PrCString
(0059) export _LCD_1_PrCString
(0060) 
(0061) export  LCD_1_Position
(0062) export _LCD_1_Position
(0063) 
(0064) export  LCD_1_PrHexByte
(0065) export _LCD_1_PrHexByte
(0066) 
(0067) export  LCD_1_PrHexInt
(0068) export _LCD_1_PrHexInt
(0069) 
(0070) export  LCD_1_Delay50uTimes
(0071) export _LCD_1_Delay50uTimes
(0072) 
(0073) export  LCD_1_Delay50u
(0074) export _LCD_1_Delay50u
(0075) 
(0076) ;-----------------------------------------------
(0077) ; If bargraph functions not required, don't
(0078) ; export the function names.
(0079) ;-----------------------------------------------
(0080) 
(0081) IF (LCD_1_BARGRAPH_ENABLE)
(0082) export  LCD_1_InitBG
(0083) export _LCD_1_InitBG
(0084) 
(0085) export  LCD_1_InitVBG
(0086) export _LCD_1_InitVBG
(0087) 
(0088) ; NOTE: The two functions,
(0089) ;
(0090) ;    LCD_1_DrawVBG and
(0091) ;    LCD_1_DrawBG
(0092) ;
(0093) ; are implemented using both fastcall16 and legacy fastcall16 because they
(0094) ; fall into a special and rare case where the calling sequences specified
(0095) ; by the two disciplines are incompatible. The fastcall16 versions are
(0096) ; provided for both C and Assembly users in all memory models. The legacy
(0097) ; fastcall16 versions are provided only to support existing small memory
(0098) ; model assembly language code---they do not work in the large memory
(0099) ; model.
(0100) ;
(0101) ; ** The legacy fastcall16 versions are provided on a temporary basis to
(0102) ; ** ease the transition to the 4.2 release of PSoC Designer. Their use is
(0103) ; ** deprecated and thier status is "No Further Maintenance".
(0104) ;
(0105) ; The fastcall16 versions of these functions are distinguished by a
(0106) ; leading underscore in the name. The legacy fastcall16 names (which appear
(0107) ; in this comment) do not have the leading underscore. Details on the
(0108) ; calling sequence to be used for fastcall16 are given in the user module
(0109) ; datasheet.
(0110) ;
(0111) ; Fastcall16 versions:
(0112) export _LCD_1_DrawVBG
(0113) export _LCD_1_DrawBG
(0114) 
(0115) IF SYSTEM_SMALL_MEMORY_MODEL
(0116) ; Legacy Fastcall versions:
(0117) export  LCD_1_DrawVBG
(0118) export  LCD_1_DrawBG
(0119) ENDIF  ; SYSTEM_SMALL_MEMORY_MODEL
(0120) 
(0121) ENDIF  ; BARGRAPH_ENABLE
(0122) 
(0123) ;
(0124) ; The following functions are deprecated and will be eliminated in a future
(0125) ; version of PSoC Designer.
(0126) ;
(0127) export   LCD_1_Write_Data
(0128) export  _LCD_1_Write_Data
(0129) 
(0130) 
(0131) ;-----------------------------------------------
(0132) ;  EQUATES
(0133) ;-----------------------------------------------
(0134) LCD_E:              equ    10h
(0135) LCD_RW:             equ    40h
(0136) LCD_RS:             equ    20h
(0137) 
(0138) LCD_DATA_MASK:      equ    0Fh
(0139) LCD_READY_BIT:      equ    08h
(0140) 
(0141) LCD_DATA_READ:      equ    ( LCD_E | LCD_RW | LCD_RS )
(0142) LCD_CNTL_READ:      equ    ( LCD_E | LCD_RW )
(0143) LCD_PORT_WRITE:     equ    7Fh
(0144) LCD_PORT_MASK:      equ    7Fh
(0145) 
(0146) LCD_Port:           equ    PRT2DR
(0147) LCD_PortMode0:      equ    PRT2DM0
(0148) LCD_PortMode1:      equ    PRT2DM1
(0149) 
(0150) DISP_INC:           equ    03h
(0151) DISP_OFF:           equ    08h
(0152) DISP_ON:            equ    0Ch
(0153) LCD_4BIT_2LINE:     equ    2Ch
(0154) 
(0155) 
(0156) ;-----------------------------------------------
(0157) ;      Bargraph definitions
(0158) ;-----------------------------------------------
(0159) 
(0160) LCD_BG_CHAR_WIDTH:  equ    16     ; 16 characters in width
(0161) LCD_BG_SEG_WIDTH:   equ    80     ; 16 * 5 = 80
(0162) LCD_BG_COL_START:   equ     0     ; Always start in the left most column
(0163) 
(0164)                                   ; Offsets for 2x16, 2x20, 4x20
(0165)                                   ; Change these values for a custome LCD
(0166) 
(0167) LCD_ROW1_OFFSET:    equ    80h    ; Address/command offset for row 1
(0168) LCD_ROW2_OFFSET:    equ    C0h    ; Address/command offset for row 2
(0169) LCD_ROW3_OFFSET:    equ    94h    ; Address/command offset for row 1
(0170) LCD_ROW4_OFFSET:    equ    D4h    ; Address/command offset for row 2
(0171) 
(0172) LCD_BG_ROW1_OFFSET: equ    80h    ; Address/command offset for row 1
(0173) LCD_BG_ROW2_OFFSET: equ    C0h    ; Address/command offset for row 2
(0174) 
(0175) CG_RAM_OFFSET:      equ    40h    ; Offset to character RAM
(0176) 
(0177) AREA UserModules (ROM, REL)
(0178) 
(0179) .SECTION
(0180) ;-----------------------------------------------------------------------------
(0181) ;  FUNCTION NAME: LCD_1_PrCString
(0182) ;
(0183) ;  DESCRIPTION:
(0184) ;    Print constant (ROM) string to LCD
(0185) ;-----------------------------------------------------------------------------
(0186) ;
(0187) ;  ARGUMENTS:
(0188) ;     A:X  Pointer to String
(0189) ;          A contains MSB of string address
(0190) ;          X contains LSB of string address
(0191) ;
(0192) ;  RETURNS:  none
(0193) ;
(0194) ;  SIDE EFFECTS:
(0195) ;    The A and X registers may be modified by this or future implementations
(0196) ;    of this function.  The same is true for all RAM page pointer registers in
(0197) ;    the Large Memory Model.  When necessary, it is the calling function's
(0198) ;    responsibility to perserve their values across calls to fastcall16 
(0199) ;    functions.
(0200) ;          
(0201) ;    Currently only the page pointer registers listed below are modified: 
(0202) ;          CUR_PP
(0203) ;
(0204)  LCD_1_PrCString:
(0205) _LCD_1_PrCString:
(0206)     RAM_PROLOGUE RAM_USE_CLASS_1
(0207)  Loop_PrCString:
(0208)     push  A                            ; Store ROM pointer
    053C: 08       PUSH  A
(0209)     push  X
    053D: 10       PUSH  X
(0210)     romx                               ; Get character from ROM
    053E: 28       ROMX  
(0211)     jnz   LCD_PrCString_WR             ; print character and advance pointer
    053F: B0 04    JNZ   0x0544
(0212)     pop   X                            ; Restore the stack
    0541: 20       POP   X
(0213)     pop   A
    0542: 18       POP   A
(0214)     RAM_EPILOGUE RAM_USE_CLASS_1
(0215)     ret                                ; Return
    0543: 7F       RET   
(0216) 
(0217) LCD_PrCString_WR:
(0218)     call  LCD_1_WriteData              ; Write data to LCD
    0544: 90 46    CALL  0x058C
(0219)     pop   X                            ; Get ROM pointer
    0546: 20       POP   X
(0220)     pop   A
    0547: 18       POP   A
(0221)     inc   X                            ; Inc LSB of pointer
    0548: 75       INC   X
(0222)     jnc   Loop_PrCString
    0549: DF F2    JNC   0x053C
(0223)     inc   A                            ; Inc MSB of pointer if LSB overflow
    054B: 74       INC   A
(0224)     jmp   Loop_PrCString
    054C: 8F EF    JMP   0x053C
    054E: 30       HALT  
    054F: 31 32    XOR   A,50
    0551: 33 34    XOR   A,[X+52]
    0553: 35 36    XOR   [X+54],A
    0555: 37 38 39 XOR   [X+56],57
    0558: 41 42 43 AND   REG[66],67
    055B: 44 45 46 OR    REG[X+69],70
(0225) 
(0226) .ENDSECTION
(0227) 
(0228) ;-----------------------------------------------------------------------------
(0229) ;  FUNCTION NAME: LCD_1_PrHexByte
(0230) ;
(0231) ;  DESCRIPTION:
(0232) ;     Print a byte in Hex (two characters) to current LCD position
(0233) ;
(0234) ;-----------------------------------------------------------------------------
(0235) ;
(0236) ;  ARGUMENTS:
(0237) ;     A  => (BYTE) Data/char to be printed
(0238) ;
(0239) ;  RETURNS: none
(0240) ;
(0241) ;  SIDE EFFECTS:
(0242) ;    The A and X registers may be modified by this or future implementations
(0243) ;    of this function.  The same is true for all RAM page pointer registers in
(0244) ;    the Large Memory Model.  When necessary, it is the calling function's
(0245) ;    responsibility to perserve their values across calls to fastcall16 
(0246) ;    functions.
(0247) ;          
(0248) ;    Currently only the page pointer registers listed below are modified: 
(0249) ;          CUR_PP
(0250) ;
(0251) .LITERAL
(0252) LCD_HEX_STR::
(0253)      DS    "0123456789ABCDEF"
(0254) .ENDLITERAL
(0255) .SECTION
(0256) 
(0257)  LCD_1_PrHexByte:
(0258) _LCD_1_PrHexByte:
(0259)     RAM_PROLOGUE RAM_USE_CLASS_1
(0260)     push  A                            ; Save lower nibble
    055E: 08       PUSH  A
(0261)     asr   A                            ; Shift high nibble to right
    055F: 67       ASR   A
(0262)     asr   A
    0560: 67       ASR   A
(0263)     asr   A
    0561: 67       ASR   A
(0264)     asr   A
    0562: 67       ASR   A
(0265)     and   A,0Fh                        ; Mask off nibble
    0563: 21 0F    AND   A,15
(0266)     index LCD_HEX_STR                  ; Get Hex value
    0565: FF E7    INDEX 0x054E
(0267)     call  LCD_1_WriteData              ; Write data to screen
    0567: 90 23    CALL  0x058C
(0268)     pop   A                            ; Restore value
    0569: 18       POP   A
(0269)     and   A,0Fh                        ; Mask off lower nibble
    056A: 21 0F    AND   A,15
(0270)     index LCD_HEX_STR                  ; Get Hex value
    056C: FF E0    INDEX 0x054E
(0271)     call  LCD_1_WriteData              ; Write data to screen
    056E: 90 1C    CALL  0x058C
(0272)     RAM_EPILOGUE RAM_USE_CLASS_1
(0273)     ret
    0570: 7F       RET   
(0274) .ENDSECTION
(0275) 
(0276) .SECTION
(0277) ;-----------------------------------------------------------------------------
(0278) ;  FUNCTION NAME: LCD_1_PrHexInt
(0279) ;
(0280) ;  DESCRIPTION:
(0281) ;     Print an Int in Hex (four characters) to current LCD position
(0282) ;
(0283) ;-----------------------------------------------------------------------------
(0284) ;
(0285) ;  ARGUMENTS:
(0286) ;     A:X Integer value
(0287) ;         A  contains LSB of Int
(0288) ;         X  contains MSB of Int
(0289) ;
(0290) ;  RETURNS: none
(0291) ;
(0292) ;  SIDE EFFECTS:
(0293) ;    The A and X registers may be modified by this or future implementations
(0294) ;    of this function.  The same is true for all RAM page pointer registers in
(0295) ;    the Large Memory Model.  When necessary, it is the calling function's
(0296) ;    responsibility to perserve their values across calls to fastcall16 
(0297) ;    functions.
(0298) ;          
(0299) ;    Currently only the page pointer registers listed below are modified: 
(0300) ;          CUR_PP
(0301) ;
(0302)  LCD_1_PrHexInt:
(0303) _LCD_1_PrHexInt:
(0304)     RAM_PROLOGUE RAM_USE_CLASS_1
(0305)     swap  A,X
    0571: 4B       SWAP  A,X
(0306)     call  LCD_1_PrHexByte              ; Print MSB
    0572: 9F EA    CALL  0x055E
(0307)     mov   A,X                          ; Move LSB into position
    0574: 5B       MOV   A,X
(0308)     call  LCD_1_PrHexByte              ; Print LSB
    0575: 9F E7    CALL  0x055E
(0309)     RAM_EPILOGUE RAM_USE_CLASS_1
(0310)     ret
    0577: 7F       RET   
(0311) .ENDSECTION
(0312) 
(0313) .SECTION
(0314) ;-----------------------------------------------------------------------------
(0315) ;  FUNCTION NAME: LCD_1_PrString
(0316) ;
(0317) ;  DESCRIPTION:
(0318) ;     Print (RAM) ASCII string to LCD
(0319) ;
(0320) ;-----------------------------------------------------------------------------
(0321) ;
(0322) ;  ARGUMENTS:
(0323) ;     A:X contains pointer to string
(0324) ;         X  contains LSB of string pointer
(0325) ;         A  contains MSB or page of string pointer (not used at this time)
(0326) ;
(0327) ;  RETURNS:
(0328) ;
(0329) ;  SIDE EFFECTS:
(0330) ;    The A and X registers may be modified by this or future implementations
(0331) ;    of this function.  The same is true for all RAM page pointer registers in
(0332) ;    the Large Memory Model.  When necessary, it is the calling function's
(0333) ;    responsibility to perserve their values across calls to fastcall16 
(0334) ;    functions.
(0335) ;          
(0336) ;    Currently only the page pointer registers listed below are modified: 
(0337) ;          CUR_PP
(0338) ;          IDX_PP
(0339) ;
(0340) ;
(0341)  LCD_1_PrString:
(0342) _LCD_1_PrString:
(0343)     RAM_PROLOGUE RAM_USE_CLASS_3
    0578: 70 BF    AND   F,191
(0344)     RAM_SETPAGE_IDX A
    057A: 60 D3    MOV   REG[211],A
(0345)  Loop_PrString:
(0346)     mov   A,[X]                        ; Get value pointed to by X
    057C: 52 00    MOV   A,[X+0]
(0347)     jz    End_LCD_PrString             ; Check for end of string
    057E: A0 08    JZ    0x0587
(0348)     ;LCD_1_writeData is known not to modify X so no need to perserve
(0349)     call  LCD_1_WriteData              ; Write data to screen
    0580: 90 0A    CALL  0x058C
(0350)     inc   X                            ; Advance pointer to next character
    0582: 75       INC   X
(0351)     push  X
    0583: 10       PUSH  X
(0352)     pop   X
    0584: 20       POP   X
(0353)     jmp   Loop_PrString                ; Go get next character
    0585: 8F F6    JMP   0x057C
    0587: 70 3F    AND   F,63
(0354) End_LCD_PrString:
(0355)     RAM_EPILOGUE RAM_USE_CLASS_3
    0589: 71 C0    OR    F,192
(0356)     ret
    058B: 7F       RET   
(0357) .ENDSECTION
(0358) 
(0359) .SECTION
(0360) ;-----------------------------------------------------------------------------
(0361) ;  FUNCTION NAME: LCD_1_WriteData
(0362) ;
(0363) ;  DESCRIPTION:
(0364) ;     Write a byte to the LCD's data register.
(0365) ;
(0366) ;-----------------------------------------------------------------------------
(0367) ;
(0368) ;  ARGUMENTS:
(0369) ;    A contains byte to be written to LCD data register
(0370) ;
(0371) ;  RETURNS: none
(0372) ;
(0373) ;  SIDE EFFECTS:
(0374) ;    The A and X registers may be modified by this or future implementations
(0375) ;    of this function.  The same is true for all RAM page pointer registers in
(0376) ;    the Large Memory Model.  When necessary, it is the calling function's
(0377) ;    responsibility to perserve their values across calls to fastcall16 
(0378) ;    functions.
(0379) ;          
(0380) ;    Currently only the page pointer registers listed below are modified: 
(0381) ;          CUR_PP
(0382) ;
(0383)  LCD_1_WriteData:
(0384) _LCD_1_WriteData:
(0385)  LCD_1_Write_Data:   ; Do not use
(0386) _LCD_1_Write_Data:   ; Do not use
(0387)     RAM_PROLOGUE RAM_USE_CLASS_1
(0388)     call  LCD_Check_Ready              ; Make sure controller is ready
    058C: 90 65    CALL  0x05F3
(0389)                                        ; A is preserved in LCD_Check_Ready
(0390)     push  A                            ; Save copy of character
    058E: 08       PUSH  A
(0391)     asr   A                            ; Shift high nibble to right
    058F: 67       ASR   A
(0392)     asr   A
    0590: 67       ASR   A
(0393)     asr   A
    0591: 67       ASR   A
(0394)     asr   A
    0592: 67       ASR   A
(0395)     and   A,0Fh                        ; Mask off high nibble
    0593: 21 0F    AND   A,15
(0396)     call  LCD_WDATA_Nibble             ; Write Upper nibble
    0595: 90 3B    CALL  0x05D2
(0397)     pop   A                            ; Retrieve copy of character
    0597: 18       POP   A
(0398)     and   A,0Fh                        ; Mask off high nibble
    0598: 21 0F    AND   A,15
(0399)     nop
    059A: 40       NOP   
(0400)     nop
    059B: 40       NOP   
(0401)     nop
    059C: 40       NOP   
(0402)     call  LCD_WDATA_Nibble             ; Write Lower nibble
    059D: 90 33    CALL  0x05D2
(0403)     RAM_EPILOGUE RAM_USE_CLASS_1
(0404)     ret
    059F: 7F       RET   
(0405) .ENDSECTION
(0406) 
(0407) .SECTION
(0408) ;-----------------------------------------------------------------------------
(0409) ;  FUNCTION NAME: LCD_1_Control
(0410) ;
(0411) ;  DESCRIPTION:
(0412) ;     Write a byte to the LCD's control register.
(0413) ;
(0414) ;-----------------------------------------------------------------------------
(0415) ;
(0416) ;  ARGUMENTS:
(0417) ;     A contains data to be written to LCD control register.
(0418) ;
(0419) ;  RETURNS: none
(0420) ;
(0421) ;  SIDE EFFECTS:
(0422) ;    The A and X registers may be modified by this or future implementations
(0423) ;    of this function.  The same is true for all RAM page pointer registers in
(0424) ;    the Large Memory Model.  When necessary, it is the calling function's
(0425) ;    responsibility to perserve their values across calls to fastcall16 
(0426) ;    functions.
(0427) ;          
(0428) ;    Currently only the page pointer registers listed below are modified: 
(0429) ;          CUR_PP
(0430) ;
(0431)  LCD_1_Control:
(0432) _LCD_1_Control:
(0433)     RAM_PROLOGUE RAM_USE_CLASS_1
(0434)     call  LCD_Check_Ready              ; Make sure controller is ready
    05A0: 90 51    CALL  0x05F3
(0435)                                        ; A is preserved in LCD_Check_Ready
(0436)     push  A                            ; Save copy of byte
    05A2: 08       PUSH  A
(0437)     asr   A                            ; Shift Upper Nibble to right
    05A3: 67       ASR   A
(0438)     asr   A
    05A4: 67       ASR   A
(0439)     asr   A
    05A5: 67       ASR   A
(0440)     asr   A
    05A6: 67       ASR   A
(0441)     and   A,0Fh                        ; Mask off, just in case
    05A7: 21 0F    AND   A,15
(0442)     call  LCD_WCNTL_Nibble             ; Write high nibble
    05A9: 90 09    CALL  0x05B4
(0443)     pop   A                            ; Restore copy of byte
    05AB: 18       POP   A
(0444)     and   A,0Fh                        ; Mask off high nibble
    05AC: 21 0F    AND   A,15
(0445)     nop
    05AE: 40       NOP   
(0446)     nop
    05AF: 40       NOP   
(0447)     nop
    05B0: 40       NOP   
(0448)     call  LCD_WCNTL_Nibble             ; Write Lower nibble
    05B1: 90 01    CALL  0x05B4
(0449)     RAM_EPILOGUE RAM_USE_CLASS_1
(0450)     ret
    05B3: 7F       RET   
(0451) .ENDSECTION
(0452) 
(0453) .SECTION
(0454) ;-----------------------------------------------------------------------------
(0455) ;  FUNCTION NAME: LCD_WCNTL_Nibble
(0456) ;
(0457) ;  DESCRIPTION:
(0458) ;     Write a single nibble to the LCD's command register
(0459) ;
(0460) ;-----------------------------------------------------------------------------
(0461) ;
(0462) ;  ARGUMENTS:
(0463) ;     A[3:0]   Contains Nibble to be written to command register
(0464) ;
(0465) ;  RETURNS: none
(0466) ;
(0467) ;  SIDE EFFECTS:
(0468) ;    The A and X registers may be modified by this or future implementations
(0469) ;    of this function.  The same is true for all RAM page pointer registers in
(0470) ;    the Large Memory Model.  When necessary, it is the calling function's
(0471) ;    responsibility to perserve their values across calls to fastcall16 
(0472) ;    functions.
(0473) ;          
(0474) ;    Currently only the page pointer registers listed below are modified: 
(0475) ;          CUR_PP
(0476) ;
(0477)  LCD_WCNTL_Nibble:
(0478)     RAM_PROLOGUE RAM_USE_CLASS_4
(0479)     push  A
    05B4: 08       PUSH  A
(0480)     RAM_SETPAGE_CUR >Port_2_Data_SHADE          ; Set CUR_PP to LCD variable address
    05B5: 62 D0 00 MOV   REG[208],0
(0481)     and   [Port_2_Data_SHADE],~LCD_PORT_MASK
    05B8: 26 00 80 AND   [0],128
(0482)     mov   A,[Port_2_Data_SHADE]
    05BB: 51 00    MOV   A,[0]
(0483)     mov   reg[LCD_Port],A                        ; Reset control lines
    05BD: 60 08    MOV   REG[8],A
(0484) 
(0485)     pop   A
    05BF: 18       POP   A
(0486)     and   A,LCD_DATA_MASK                        ; Make sure no bogus data in MSN
    05C0: 21 0F    AND   A,15
(0487)     or    A,LCD_E                                ; Bring "E" Enable line high
    05C2: 29 10    OR    A,16
(0488)     or    A,[Port_2_Data_SHADE]                  ; OR in bit 7 just
    05C4: 2A 00    OR    A,[0]
(0489)     mov   reg[LCD_Port], A                       ; Write data
    05C6: 60 08    MOV   REG[8],A
(0490)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
    05C8: 53 00    MOV   [0],A
(0491)     nop
    05CA: 40       NOP   
(0492)     and   A,(~LCD_PORT_MASK|LCD_DATA_MASK)       ; Disable E signal and leave data on bus.
    05CB: 21 8F    AND   A,143
(0493)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
    05CD: 53 00    MOV   [0],A
(0494)     mov   reg[LCD_Port],A
    05CF: 60 08    MOV   REG[8],A
(0495)     RAM_EPILOGUE RAM_USE_CLASS_4
(0496)     ret
    05D1: 7F       RET   
(0497) .ENDSECTION
(0498) 
(0499) .SECTION
(0500) ;-----------------------------------------------------------------------------
(0501) ;  FUNCTION NAME: LCD_WDATA_Nibble
(0502) ;
(0503) ;  DESCRIPTION:
(0504) ;     Write a single nibble to the LCD's DATA register
(0505) ;
(0506) ;-----------------------------------------------------------------------------
(0507) ;
(0508) ;  ARGUMENTS:
(0509) ;     A[3:0]   Contains Nibble to be written to data register
(0510) ;
(0511) ;  RETURNS: none
(0512) ;
(0513) ;  SIDE EFFECTS:
(0514) ;    The A and X registers may be modified by this or future implementations
(0515) ;    of this function.  The same is true for all RAM page pointer registers in
(0516) ;    the Large Memory Model.  When necessary, it is the calling function's
(0517) ;    responsibility to perserve their values across calls to fastcall16 
(0518) ;    functions.
(0519) ;          
(0520) ;    Currently only the page pointer registers listed below are modified: 
(0521) ;          CUR_PP
(0522) ;
(0523) LCD_WDATA_Nibble:
(0524)     RAM_PROLOGUE RAM_USE_CLASS_4
(0525)     push  A
    05D2: 08       PUSH  A
(0526)     RAM_SETPAGE_CUR >Port_2_Data_SHADE          ; Set CUR_PP to LCD variable address
    05D3: 62 D0 00 MOV   REG[208],0
(0527)     and   [Port_2_Data_SHADE],~LCD_PORT_MASK
    05D6: 26 00 80 AND   [0],128
(0528)     or    [Port_2_Data_SHADE],LCD_RS                  ; Raise RS to signify a Data Write
    05D9: 2E 00 20 OR    [0],32
(0529)     mov   A,[Port_2_Data_SHADE]
    05DC: 51 00    MOV   A,[0]
(0530)     mov   reg[LCD_Port],A
    05DE: 60 08    MOV   REG[8],A
(0531) 
(0532)     pop   A
    05E0: 18       POP   A
(0533)     and   A,LCD_DATA_MASK                             ; Make sure no bogus data in A[7:4]
    05E1: 21 0F    AND   A,15
(0534)     or    A,(LCD_E | LCD_RS)                          ; Bring "E" Enable line high
    05E3: 29 30    OR    A,48
(0535)     or    A,[Port_2_Data_SHADE]                       ; Keep shadow in sync
    05E5: 2A 00    OR    A,[0]
(0536)     mov   reg[LCD_Port], A                            ; Write data
    05E7: 60 08    MOV   REG[8],A
(0537)     mov   [Port_2_Data_SHADE],A                       ; Keep shadow in sync
    05E9: 53 00    MOV   [0],A
(0538)     NOP
    05EB: 40       NOP   
(0539)     and   A,(~LCD_PORT_MASK|LCD_DATA_MASK|LCD_RS)     ; Disable E signal and leave Data on bus
    05EC: 21 AF    AND   A,175
(0540)     mov   [Port_2_Data_SHADE],A                       ; keep shadow in sync
    05EE: 53 00    MOV   [0],A
(0541)     mov   reg[LCD_Port],A
    05F0: 60 08    MOV   REG[8],A
(0542)     RAM_EPILOGUE RAM_USE_CLASS_4
(0543)     ret
    05F2: 7F       RET   
(0544) .ENDSECTION
(0545) 
(0546) .SECTION
(0547) ;-----------------------------------------------------------------------------
(0548) ;  FUNCTION NAME: LCD_Check_Ready
(0549) ;
(0550) ;  DESCRIPTION:
(0551) ;     Wait until LCD has completed last command.
(0552) ;
(0553) ;-----------------------------------------------------------------------------
(0554) ;
(0555) ;  ARGUMENTS: none
(0556) ;
(0557) ;  RETURNS: none
(0558) ;
(0559) ;  SIDE EFFECTS:
(0560) ;    The A and X registers may be modified by this or future implementations
(0561) ;    of this function.  The same is true for all RAM page pointer registers in
(0562) ;    the Large Memory Model.  When necessary, it is the calling function's
(0563) ;    responsibility to perserve their values across calls to fastcall16 
(0564) ;    functions.
(0565) ;          
(0566) ;    Currently only the page pointer registers listed below are modified: 
(0567) ;          CUR_PP
(0568) ;
(0569) ;     If LCD is not present, this routine may never return.
(0570) ;
(0571) LCD_Check_Ready:
(0572)     RAM_PROLOGUE RAM_USE_CLASS_4
(0573)     push  A                                                     ; Save Accumulator
    05F3: 08       PUSH  A
(0574)     RAM_SETPAGE_CUR >Port_2_Data_SHADE          ; Set CUR_PP to LCD variable address
    05F4: 62 D0 00 MOV   REG[208],0
(0575)     and   [Port_2_Data_SHADE],~LCD_PORT_MASK                    ; Mask of all LCD bits
    05F7: 26 00 80 AND   [0],128
(0576)     mov   A,[Port_2_Data_SHADE]
    05FA: 51 00    MOV   A,[0]
(0577)     mov   reg[LCD_Port],A                                       ; Zero LCD port bits
    05FC: 60 08    MOV   REG[8],A
(0578) 
(0579)     and   [Port_2_DriveMode_0_SHADE],~LCD_DATA_MASK             ; Clear out LCD mode bits.
    05FE: 26 01 F0 AND   [1],240
(0580)     mov   A,[Port_2_DriveMode_0_SHADE]
    0601: 51 01    MOV   A,[1]
(0581)     M8C_SetBank1                                                ; Change port mode to read status
    0603: 71 10    OR    F,16
(0582)     mov   reg[LCD_PortMode0],A                                  ; Setup LCD Port for reading
    0605: 60 08    MOV   REG[8],A
(0583)     M8C_SetBank0
    0607: 70 EF    AND   F,239
(0584) 
(0585)     or    [Port_2_Data_SHADE],LCD_RW                            ; Raise RW to signify Read operation
    0609: 2E 00 40 OR    [0],64
(0586)     mov   A,[Port_2_Data_SHADE]
    060C: 51 00    MOV   A,[0]
(0587)     mov   reg[LCD_Port],A
    060E: 60 08    MOV   REG[8],A
(0588)     NOP
    0610: 40       NOP   
(0589) 
(0590) LCD_RDY_LOOP:
(0591)     or    [Port_2_Data_SHADE], LCD_CNTL_READ                    ; Raise E to start cycle
    0611: 2E 00 50 OR    [0],80
(0592)     mov   A,[Port_2_Data_SHADE]
    0614: 51 00    MOV   A,[0]
(0593)     mov   reg[LCD_Port],A
    0616: 60 08    MOV   REG[8],A
(0594) 
(0595)     nop                                                         ; Wait 2 nops to make sure data is ready
    0618: 40       NOP   
(0596)     nop
    0619: 40       NOP   
(0597)     mov   A,reg[LCD_Port]
    061A: 5D 08    MOV   A,REG[8]
(0598) 
(0599) ; The code below is used to work around the async read issue with the ICE with the 
(0600) ; 25/26xxx family of devices.  It will help to eliminate "Invalid memory reference" 
(0601) ; errors.  It is not required when running without the ICE or when using any other 
(0602) ; family besides the 25/26xxx family. If not using the ICE or with any other family
(0603) ; the ICE_PORT_SYNC flag should be set to 0.
(0604) IF(ICE_PORT_SYNC)                          
(0605)     mov   reg[ 0xfa], A                    
(0606)     mov   A, reg[0xfa]                     
(0607) ENDIF   
(0608)                                    
(0609)     push  A
    061C: 08       PUSH  A
(0610)     and   [Port_2_Data_SHADE],(~LCD_PORT_MASK | LCD_RW)         ; Lower E signal
    061D: 26 00 C0 AND   [0],192
(0611)     mov   A,[Port_2_Data_SHADE]
    0620: 51 00    MOV   A,[0]
(0612)     mov   reg[LCD_Port],A
    0622: 60 08    MOV   REG[8],A
(0613) 
(0614)     nop                                    ; Add delay for the slowest part and the
    0624: 40       NOP   
(0615)     nop                                    ; fastest PSoC
    0625: 40       NOP   
(0616)     nop
    0626: 40       NOP   
(0617)                                                                 ; Get the LSBs
(0618)     or    [Port_2_Data_SHADE],LCD_CNTL_READ                     ; Raise E to start cycle
    0627: 2E 00 50 OR    [0],80
(0619)     mov   A,[Port_2_Data_SHADE]
    062A: 51 00    MOV   A,[0]
(0620)     mov   reg[LCD_Port],A
    062C: 60 08    MOV   REG[8],A
(0621) 
(0622)     nop
    062E: 40       NOP   
(0623)     nop
    062F: 40       NOP   
(0624) 
(0625)     and   [Port_2_Data_SHADE],(~LCD_PORT_MASK | LCD_RW)         ; Lower E signal
    0630: 26 00 C0 AND   [0],192
(0626)     mov   A,[Port_2_Data_SHADE]
    0633: 51 00    MOV   A,[0]
(0627)     mov   reg[LCD_Port],A
    0635: 60 08    MOV   REG[8],A
(0628) 
(0629)     pop   A
    0637: 18       POP   A
(0630)     and   A,LCD_READY_BIT                                       ; Check busy
    0638: 21 08    AND   A,8
(0631)     jnz   LCD_RDY_LOOP                                          ; If LCD still busy, read again
    063A: BF D6    JNZ   0x0611
(0632) 
(0633)     or    [Port_2_DriveMode_0_SHADE],LCD_PORT_WRITE             ; Revert Data bit to Write mode
    063C: 2E 01 7F OR    [1],127
(0634)     mov   A,[Port_2_DriveMode_0_SHADE]
    063F: 51 01    MOV   A,[1]
(0635)     M8C_SetBank1
    0641: 71 10    OR    F,16
(0636)     mov   reg[LCD_PortMode0],A                                  ; Setup LCD Port for writing
    0643: 60 08    MOV   REG[8],A
(0637)     M8C_SetBank0
    0645: 70 EF    AND   F,239
(0638)     pop   A
    0647: 18       POP   A
(0639)     RAM_EPILOGUE RAM_USE_CLASS_4                                     ; Restore Accumulator
(0640)     ret
    0648: 7F       RET   
(0641) .ENDSECTION
(0642) 
(0643) .SECTION
(0644) ;-----------------------------------------------------------------------------
(0645) ;  FUNCTION NAME: LCD_1_Start
(0646) ;  FUNCTION NAME: LCD_1_Init
(0647) ;
(0648) ;  DESCRIPTION:
(0649) ;     Initialize LCD
(0650) ;
(0651) ;-----------------------------------------------------------------------------
(0652) ;
(0653) ;  ARGUMENTS: none
(0654) ;
(0655) ;  RETURNS: none
(0656) ;
(0657) ;  SIDE EFFECTS:
(0658) ;    The A and X registers may be modified by this or future implementations
(0659) ;    of this function.  The same is true for all RAM page pointer registers in
(0660) ;    the Large Memory Model.  When necessary, it is the calling function's
(0661) ;    responsibility to perserve their values across calls to fastcall16 
(0662) ;    functions.
(0663) ;          
(0664) ;    Currently only the page pointer registers listed below are modified: 
(0665) ;          CUR_PP
(0666) ;
(0667) ;  THEORY of OPERATION or PROCEDURE:
(0668) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0669) ;    This initialization is a bit long, but it should work for
(0670) ;    most 2 and 4 line LCDs.
(0671) ;
(0672)  LCD_1_Start:
(0673) _LCD_1_Start:
(0674)  LCD_1_Init:
(0675) _LCD_1_Init:
(0676)     RAM_PROLOGUE RAM_USE_CLASS_4
(0677)     RAM_SETPAGE_CUR >Port_2_Data_SHADE          ; Set CUR_PP to LCD variable address
    0649: 62 D0 00 MOV   REG[208],0
(0678) 
(0679)     and   [Port_2_DriveMode_0_SHADE],~LCD_PORT_MASK             ; Mask off LCD bits
    064C: 26 01 80 AND   [1],128
(0680)     or    [Port_2_DriveMode_0_SHADE],LCD_PORT_WRITE             ; Set LCD port for writing
    064F: 2E 01 7F OR    [1],127
(0681)     and   [Port_2_DriveMode_1_SHADE],~LCD_PORT_MASK             ; Mask off LCD bits
    0652: 26 02 80 AND   [2],128
(0682) 
(0683)     mov   A,[Port_2_DriveMode_0_SHADE]
    0655: 51 01    MOV   A,[1]
(0684)     M8C_SetBank1
    0657: 71 10    OR    F,16
(0685)     mov   reg[LCD_PortMode0],A                                  ; Setup LCD Port for writing
    0659: 60 08    MOV   REG[8],A
(0686)     mov   A,[Port_2_DriveMode_1_SHADE]
    065B: 51 02    MOV   A,[2]
(0687)     mov   reg[LCD_PortMode1],A
    065D: 60 09    MOV   REG[9],A
(0688)     M8C_SetBank0
    065F: 70 EF    AND   F,239
(0689) 
(0690)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
    0661: 50 FA    MOV   A,250
(0691)     call  LCD_1_Delay50uTimes
    0663: 90 67    CALL  0x06CC
(0692)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
    0665: 50 FA    MOV   A,250
(0693)     call  LCD_1_Delay50uTimes
    0667: 90 63    CALL  0x06CC
(0694) 
(0695)     mov   A,03h
    0669: 50 03    MOV   A,3
(0696)     call  LCD_WCNTL_Nibble
    066B: 9F 47    CALL  0x05B4
(0697) 
(0698)     mov   A,82                              ; Delay for 4.1 mSec (82 * 50uSec)
    066D: 50 52    MOV   A,82
(0699)     call  LCD_1_Delay50uTimes
    066F: 90 5B    CALL  0x06CC
(0700) 
(0701)     mov   A,03h
    0671: 50 03    MOV   A,3
(0702)     call  LCD_WCNTL_Nibble
    0673: 9F 3F    CALL  0x05B4
(0703) 
(0704)     call  LCD_1_Delay50u
    0675: 90 63    CALL  0x06DA
(0705)     call  LCD_1_Delay50u
    0677: 90 61    CALL  0x06DA
(0706)     call  LCD_1_Delay50u
    0679: 90 5F    CALL  0x06DA
(0707) 
(0708)     mov   A,03h
    067B: 50 03    MOV   A,3
(0709)     call  LCD_WCNTL_Nibble
    067D: 9F 35    CALL  0x05B4
(0710) 
(0711)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
    067F: 50 5A    MOV   A,90
(0712)     call  LCD_1_Delay50uTimes
    0681: 90 49    CALL  0x06CC
(0713) 
(0714)     mov   A,02h
    0683: 50 02    MOV   A,2
(0715)     call  LCD_WCNTL_Nibble
    0685: 9F 2D    CALL  0x05B4
(0716) 
(0717)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
    0687: 50 5A    MOV   A,90
(0718)     call  LCD_1_Delay50uTimes
    0689: 90 41    CALL  0x06CC
(0719) 
(0720)     mov   A,08h
    068B: 50 08    MOV   A,8
(0721)     call  LCD_1_Control
    068D: 9F 11    CALL  0x05A0
(0722)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
    068F: 50 5A    MOV   A,90
(0723)     call  LCD_1_Delay50uTimes
    0691: 90 39    CALL  0x06CC
(0724) 
(0725)     mov   A,01h
    0693: 50 01    MOV   A,1
(0726)     call  LCD_1_Control
    0695: 9F 09    CALL  0x05A0
(0727)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
    0697: 50 5A    MOV   A,90
(0728)     call  LCD_1_Delay50uTimes
    0699: 90 31    CALL  0x06CC
(0729) 
(0730)     mov   A,06h
    069B: 50 06    MOV   A,6
(0731)     call  LCD_1_Control
    069D: 9F 01    CALL  0x05A0
(0732) 
(0733)     mov   A,0Eh
    069F: 50 0E    MOV   A,14
(0734)     call  LCD_1_Control
    06A1: 9E FD    CALL  0x05A0
(0735) 
(0736)     mov   A,LCD_4BIT_2LINE                  ; Setup for 4 bit interface, 2 line
    06A3: 50 2C    MOV   A,44
(0737)     call  LCD_1_Control
    06A5: 9E F9    CALL  0x05A0
(0738) 
(0739)     mov   A,DISP_OFF
    06A7: 50 08    MOV   A,8
(0740)     call  LCD_1_Control
    06A9: 9E F5    CALL  0x05A0
(0741) 
(0742)     mov   A,DISP_ON
    06AB: 50 0C    MOV   A,12
(0743)     call  LCD_1_Control
    06AD: 9E F1    CALL  0x05A0
(0744) 
(0745)     mov   A,DISP_INC
    06AF: 50 03    MOV   A,3
(0746)     call  LCD_1_Control
    06B1: 9E ED    CALL  0x05A0
(0747) 
(0748)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
    06B3: 50 5A    MOV   A,90
(0749)     call  LCD_1_Delay50uTimes
    06B5: 90 15    CALL  0x06CC
(0750)     RAM_EPILOGUE RAM_USE_CLASS_4
(0751)     ret
    06B7: 7F       RET   
    06B8: 80 C0    JMP   0x0779
    06BA: 94 D4    CALL  0x0B90
(0752) .ENDSECTION
(0753) 
(0754) ;-----------------------------------------------------------------------------
(0755) ;  FUNCTION NAME: LCD_1_Position
(0756) ;
(0757) ;  DESCRIPTION:
(0758) ;     Position Cursor at Row and Col location
(0759) ;
(0760) ;-----------------------------------------------------------------------------
(0761) ;
(0762) ;  ARGUMENTS:
(0763) ;     A => Row  0 to 3
(0764) ;     X => Col  0 to 39+
(0765) ;
(0766) ;  RETURNS:  none
(0767) ;
(0768) ;  SIDE EFFECTS:
(0769) ;    The A and X registers may be modified by this or future implementations
(0770) ;    of this function.  The same is true for all RAM page pointer registers in
(0771) ;    the Large Memory Model.  When necessary, it is the calling function's
(0772) ;    responsibility to perserve their values across calls to fastcall16 
(0773) ;    functions.
(0774) ;
(0775) .LITERAL
(0776) LCD_ROW_OFFSET::
(0777)      DB    LCD_ROW1_OFFSET, LCD_ROW2_OFFSET, LCD_ROW3_OFFSET, LCD_ROW4_OFFSET
(0778) .ENDLITERAL
(0779) 
(0780) .SECTION
(0781)  LCD_1_Position:
(0782) _LCD_1_Position:
(0783)     RAM_PROLOGUE RAM_USE_CLASS_2
(0784)     and   A,03h                        ; Mask off 2 bits for row address 0 to 3
    06BC: 21 03    AND   A,3
(0785)     push  X                            ; Store COL
    06BE: 10       PUSH  X
(0786)     index LCD_ROW_OFFSET               ; Get ROW memory offset from table
    06BF: FF F7    INDEX 0x06B8
(0787)     mov   X,SP                         ; Get Stack pointer
    06C1: 4F       MOV   X,SP
(0788)     add   A,[X+(-1)]                   ; Add the COL to the display pointer
    06C2: 03 FF    ADD   A,[X-1]
(0789)     pop   X
    06C4: 20       POP   X
(0790) 
(0791) LCD_POS_IT:
(0792)     call  LCD_1_Control                ; Write control byte
    06C5: 9E D9    CALL  0x05A0
    06C7: 70 3F    AND   F,63
(0793)     RAM_EPILOGUE RAM_USE_CLASS_2
    06C9: 71 C0    OR    F,192
(0794)     ret
    06CB: 7F       RET   
(0795) .ENDSECTION
(0796) 
(0797) .SECTION
(0798) ;-----------------------------------------------------------------------------
(0799) ;  FUNCTION NAME: LCD_1_Delay50uTimes
(0800) ;
(0801) ;  DESCRIPTION:
(0802) ;     Delay increments of 50uSeconds
(0803) ;
(0804) ;-----------------------------------------------------------------------------
(0805) ;
(0806) ;  ARGUMENTS:
(0807) ;     A contains the delay multiplier
(0808) ;
(0809) ;  RETURNS:
(0810) ;
(0811) ;  SIDE EFFECTS:
(0812) ;    The A and X registers may be modified by this or future implementations
(0813) ;    of this function.  The same is true for all RAM page pointer registers in
(0814) ;    the Large Memory Model.  When necessary, it is the calling function's
(0815) ;    responsibility to perserve their values across calls to fastcall16 
(0816) ;    functions.
(0817) ;
(0818) ;
(0819)  LCD_1_Delay50uTimes:
(0820) _LCD_1_Delay50uTimes:
(0821)     RAM_PROLOGUE RAM_USE_CLASS_1
(0822)     call  LCD_1_Delay50u
    06CC: 90 0C    CALL  0x06DA
(0823)     dec   A
    06CE: 78       DEC   A
(0824)     jnz   LCD_1_Delay50uTimes
    06CF: BF FC    JNZ   0x06CC
(0825)     RAM_EPILOGUE RAM_USE_CLASS_1
(0826)     ret
    06D1: 7F       RET   
    06D2: 08       PUSH  A
    06D3: 19 3A    SBB   A,58
    06D5: 7C 01 01 LCALL 0x0101
    06D8: 01 01    ADD   A,1
(0827) 
(0828) .ENDSECTION
(0829) 
(0830) ;-----------------------------------------------------------------------------
(0831) ;  FUNCTION NAME: LCD_1_Delay50u
(0832) ;
(0833) ;  DESCRIPTION:
(0834) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
(0835) ;     Slower clock frequencies the delay will be;
(0836) ;           1.5
(0837) ;        -------------- * 50uSec
(0838) ;        clock_freq(MHz)
(0839) ;
(0840) ;
(0841) ;-----------------------------------------------------------------------------
(0842) ;
(0843) ;  ARGUMENTS: none
(0844) ;
(0845) ;  RETURNS: none
(0846) ;
(0847) ;  SIDE EFFECTS:
(0848) ;    The A and X registers may be modified by this or future implementations
(0849) ;    of this function.  The same is true for all RAM page pointer registers in
(0850) ;    the Large Memory Model.  When necessary, it is the calling function's
(0851) ;    responsibility to perserve their values across calls to fastcall16 
(0852) ;    functions.
(0853) ;
(0854) ;  THEORY of OPERATION or PROCEDURE:
(0855) ;
(0856) .LITERAL
(0857)  Delay50u_Table::
(0858)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
(0859) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
(0860) .ENDLITERAL
(0861) .SECTION
(0862) 
(0863)   LCD_1_Delay50u:
(0864)  _LCD_1_Delay50u:                      ; [11]  Call
(0865)     RAM_PROLOGUE RAM_USE_CLASS_1
(0866)     push  A
    06DA: 08       PUSH  A
(0867)     M8C_SetBank1                       ; [4]
    06DB: 71 10    OR    F,16
(0868)     mov   A, reg[OSC_CR0]              ; [6] Get delay value
    06DD: 5D E0    MOV   A,REG[224]
(0869)     M8C_SetBank0                       ; [4]
    06DF: 70 EF    AND   F,239
(0870)     and   A,07h                        ; [4] Mask off only the clock bits
    06E1: 21 07    AND   A,7
(0871)     cmp   A,05h
    06E3: 39 05    CMP   A,5
(0872)     jnc   Delay50u_End
    06E5: D0 06    JNC   0x06EC
(0873)     index Delay50u_Table               ; [13] Get delay value
    06E7: FF E9    INDEX 0x06D2
(0874) Delay50u_Loop:                         ;
(0875)     dec   A                            ; [4]
    06E9: 78       DEC   A
(0876)     jnz   Delay50u_Loop                ; [5]
    06EA: BF FE    JNZ   0x06E9
(0877) Delay50u_End:
(0878)     pop   A
    06EC: 18       POP   A
(0879)     RAM_EPILOGUE RAM_USE_CLASS_1
(0880)     ret
    06ED: 7F       RET   
(0881) .ENDSECTION
(0882) 
(0883) 
(0884) ;-----------------------------------------------------------------------------
(0885) ;      If bargraph is not enabled, the following functions are not required.
(0886) ;-----------------------------------------------------------------------------
(0887) 
(0888) IF (LCD_1_BARGRAPH_ENABLE)
(0889) 
(0890) IF SYSTEM_SMALL_MEMORY_MODEL
(0891) .SECTION
(0892) ;-----------------------------------------------------------------------------
(0893) ;  FUNCTION NAME: LCD_1_DrawBG
(0894) ;
(0895) ;  DESCRIPTION:
(0896) ;  This legacy fastcall version are provided only to support existing small
(0897) ;  memory model assembly language code---it does not work in the large memory
(0898) ;  model.
(0899) ;
(0900) ;  ** This legacy fastcall version is provided on a temporary basis to
(0901) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
(0902) ;  ** deprecated and its status is "No Further Maintenance". If you call this
(0903) ;  ** function in assembly you should convert to _LCD_1_DrawVBG
(0904) ;  ** (with a leading underscore) and the fastcall16 interface
(0905) ;
(0906) ;  Draw a horizontal bargraph on the LCD with the given parameters.  This
(0907) ;  is a legacy function that is intended to support existing Assembly
(0908) ;  language programs that call this function.  This should not be used for
(0909) ;  new code or with Large Memory Model programs.
(0910) ;-----------------------------------------------------------------------------
(0911) ;
(0912) ;  LEGACY FASTCALL ARGUMENTS:
(0913) ;    A    => Starting row for bargraph 0 to 3
(0914) ;   [X]   => Starting Column for bargraph 0 to 39+
(0915) ;   [x-1] => Length of bargraph in chars 1 to 40+
(0916) ;   [X-2] => Position of pointer in segments 5 times Length
(0917) ;
(0918) ;
(0919) ;  RETURNS:  none
(0920) ;
(0921) ;  SIDE EFFECTS:
(0922) ;    The A and X registers may be modified by this or future implementations
(0923) ;    of this function.  The same is true for all RAM page pointer registers in
(0924) ;    the Large Memory Model.  When necessary, it is the calling function's
(0925) ;    responsibility to perserve their values across calls to fastcall16 
(0926) ;    functions.
(0927) ;
(0928) ;    If LCD_1_Init is not called before this function, the
(0929) ;    bargraph will not be drawn properly.
(0930) ;
(0931) ; Stack offset constants
(0932) BG_COLX:       equ  0                   ; Stack position of Column
(0933) BG_CHAR_LENX:  equ -1                   ; Stack position of Length
(0934) BG_LENGTHX:    equ -2                   ; Stack postion of bargraph pointer position
(0935) 
(0936) 
(0937) LCD_1_DrawBG:
(0938)     push  X
(0939)     mov   X,[X+BG_COLX]                 ; Row in A, Col in X
(0940)     call  LCD_1_Position               ; Set cursor position
(0941)     pop   X                            ; Restore pointer
(0942) 
(0943) LCD_BG_LOOP1X:
(0944)     cmp   [X+BG_LENGTHX],00h            ; Check for past end of BG
(0945)     jnz   LCD_CHECK1X
(0946)     mov   A,00h                        ; Load empty character
(0947)     jmp   LCD_BG_DOITX                  ;
(0948) 
(0949) LCD_CHECK1X:
(0950)     cmp   [X+BG_LENGTHX],06h            ; Check if BG pointer is at this character
(0951)     jnc   LCD_CHECK2X                   ; Note yet, use full character
(0952)     mov   A,[X+BG_LENGTHX]
(0953)     sub   [X+BG_LENGTHX],A
(0954)     jmp   LCD_BG_DOITX
(0955) 
(0956) LCD_CHECK2X:                            ; Put index to full character
(0957)     mov   A, 06h
(0958)     sub   [X+BG_LENGTHX],05h            ; Subtract another 5 positions
(0959) 
(0960) LCD_BG_DOITX:
(0961)     call  LCD_1_WriteData              ; Display BG character
(0962) 
(0963)     dec   [X+BG_CHAR_LENX]              ; Dec Char count
(0964)     jnz   LCD_BG_LOOP1X                 ; Do it all over again
(0965)     ret
(0966) .ENDSECTION
(0967) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
(0968) 
(0969) .SECTION
(0970) ;-----------------------------------------------------------------------------
(0971) ;  FUNCTION NAME: LCD_1_DrawBG
(0972) ;
(0973) ;  DESCRIPTION:
(0974) ;     Draw a horizontal bargraph on the LCD with the given parameters.
(0975) ;
(0976) ;
(0977) ;-----------------------------------------------------------------------------
(0978) ;
(0979) ;  FASTCALL16 ARGUMENTS:
(0980) ;   [SP-3] => Starting row for bargraph 0 to 3
(0981) ;   [SP-4] => Starting Column for bargraph 0 to 39+
(0982) ;   [SP-5] => Length of bargraph in chars 1 to 40+
(0983) ;   [SP-6] => Position of pointer in segments 5 times Length
(0984) ;
(0985) ;
(0986) ;  RETURNS:  none
(0987) ;
(0988) ;  SIDE EFFECTS:
(0989) ;    The A and X registers may be modified by this or future implementations
(0990) ;    of this function.  The same is true for all RAM page pointer registers in
(0991) ;    the Large Memory Model.  When necessary, it is the calling function's
(0992) ;    responsibility to perserve their values across calls to fastcall16 
(0993) ;    functions.
(0994) ;          
(0995) ;    Currently only the page pointer registers listed below are modified: 
(0996) ;          CUR_PP
(0997) ;
(0998) ;    If LCD_1_Init is not called before this function, the
(0999) ;    bargraph will not be drawn properly.
(1000) ;
(1001) ; Stack offset constants
(1002) BG_ROW:       equ -3
(1003) BG_COL:       equ -4                   ; Stack position of Column
(1004) BG_CHAR_LEN:  equ -5                   ; Stack position of Length
(1005) BG_LENGTH:    equ -6                   ; Stack postion of bargraph pointer position
(1006) 
(1007) 
(1008) _LCD_1_DrawBG:
(1009)     RAM_PROLOGUE RAM_USE_CLASS_2
(1010)     mov   X, SP
    06EE: 4F       MOV   X,SP
(1011)     push  X
    06EF: 10       PUSH  X
(1012)     mov   A,[X+BG_ROW]                 ; Row in A
    06F0: 52 FD    MOV   A,[X-3]
(1013)     mov   X,[X+BG_COL]                 ; Col in X
    06F2: 59 FC    MOV   X,[X-4]
(1014)     call  LCD_1_Position               ; Set cursor position
    06F4: 9F C6    CALL  0x06BC
(1015)     pop  X
    06F6: 20       POP   X
(1016) 
(1017) LCD_BG_LOOP1:
(1018)     cmp   [X+BG_LENGTH],00h            ; Check for past end of BG
    06F7: 3D FA 00 CMP   [X-6],0
(1019)     jnz   LCD_CHECK1
    06FA: B0 05    JNZ   0x0700
(1020)     mov   A,00h                        ; Load empty character
    06FC: 50 00    MOV   A,0
(1021)     jmp   LCD_BG_DOIT                  ;
    06FE: 80 11    JMP   0x0710
(1022) 
(1023) LCD_CHECK1:
(1024)     cmp   [X+BG_LENGTH],06h            ; Check if BG pointer is at this character
    0700: 3D FA 06 CMP   [X-6],6
(1025)     jnc   LCD_CHECK2                   ; Note yet, use full character
    0703: D0 07    JNC   0x070B
(1026)     mov   A,[X+BG_LENGTH]
    0705: 52 FA    MOV   A,[X-6]
(1027)     sub   [X+BG_LENGTH],A
    0707: 15 FA    SUB   [X-6],A
(1028)     jmp   LCD_BG_DOIT
    0709: 80 06    JMP   0x0710
(1029) 
(1030) LCD_CHECK2:                            ; Put index to full character
(1031)     mov   A, 06h
    070B: 50 06    MOV   A,6
(1032)     sub   [X+BG_LENGTH],05h            ; Subtract another 5 positions
    070D: 17 FA 05 SUB   [X-6],5
(1033) 
(1034) LCD_BG_DOIT:
(1035)     call  LCD_1_WriteData              ; Display BG character
    0710: 9E 7A    CALL  0x058C
(1036) 
(1037)     dec   [X+BG_CHAR_LEN]              ; Dec Char count
    0712: 7B FB    DEC   [X-5]
(1038)     jnz   LCD_BG_LOOP1                 ; Do it all over again
    0714: BF E2    JNZ   0x06F7
    0716: 70 3F    AND   F,63
(1039)     RAM_EPILOGUE RAM_USE_CLASS_2
    0718: 71 C0    OR    F,192
(1040)     ret
    071A: 7F       RET   
(1041) .ENDSECTION
(1042) 
(1043) IF SYSTEM_SMALL_MEMORY_MODEL
(1044) .SECTION
(1045) ;-----------------------------------------------------------------------------
(1046) ;  FUNCTION NAME: LCD_1_DrawVBG
(1047) ;
(1048) ;  DESCRIPTION:
(1049) ;  This legacy fastcall version are provided only to support existing small
(1050) ;  memory model assembly language code---it does not work in the large memory
(1051) ;  model.
(1052) ;
(1053) ;  ** This legacy fastcall version is provided on a temporary basis to
(1054) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
(1055) ;  ** deprecated and its status is "No Further Maintenance". If you call this
(1056) ;  ** function in assembly you should convert to _LCD_1_DrawVBG
(1057) ;  ** (with a leading underscore) and the fastcall16 interface
(1058) ;
(1059) ;  Draw a vertical bargraph on the LCD with the given parameters. This
(1060) ;  is a legacy function that is intended to support existing Assembly
(1061) ;  language programs that call this function.  This should not be used for
(1062) ;  new code or with Large Memory Model programs.
(1063) ;-----------------------------------------------------------------------------
(1064) ;
(1065) ;  LEGACY FASTCALL ARGUMENTS:
(1066) ;    A    => Starting row for bargraph 0 to 3
(1067) ;   [X]   => Starting Column for bargraph 0 to 40+
(1068) ;   [x-1] => Height of bargraph in chars 1 - 4
(1069) ;   [X-2] => Position of pointer in segments 8 times height
(1070) ;  RETURNS:
(1071) ;
(1072) ;  SIDE EFFECTS:
(1073) ;    The A and X registers may be modified by this or future implementations
(1074) ;    of this function.  The same is true for all RAM page pointer registers in
(1075) ;    the Large Memory Model.  When necessary, it is the calling function's
(1076) ;    responsibility to perserve their values across calls to fastcall16 
(1077) ;    functions.
(1078) ;    
(1079) ;    If LCD_1_Init is not called before this function, the
(1080) ;    bargraph will not be drawn properly.
(1081) ;
(1082) ; Stack offset constants
(1083) VBG_COLX:            equ  0
(1084) VBG_CHAR_HEIGHTX:    equ -1
(1085) VBG_SEG_HEIGHTX:     equ -2
(1086) 
(1087) LCD_1_DrawVBG:
(1088) 
(1089)     and   A,03h                        ; Make sure only rows 0 - 3 are valid
(1090) VBG_LOOPX:
(1091)     push  A
(1092)     index LCD_ROW_OFFSET               ; Get row offset
(1093)     add   A,[X+VBG_COLX]                ; Add column offset to position
(1094)     call  LCD_1_Control                ; Position Cursor
(1095)     cmp   [X+VBG_SEG_HEIGHTX],00h       ; Check for zero segs
(1096)     jnz   VBG_NZ_SEGX
(1097)     mov   A,' '                        ; Load space character
(1098)     jmp   VBG_WRITE_CHARX
(1099) VBG_NZ_SEGX:
(1100)     cmp   [X+VBG_SEG_HEIGHTX],09h       ; Check for full segment
(1101)     jnc   VBG_FULL_SEGX
(1102)                                        ; Partial segment between 1 and 8
(1103)     mov   A,[X+VBG_SEG_HEIGHTX]
(1104)     dec   A
(1105)     mov   [X+VBG_SEG_HEIGHTX],00h       ; Zero segment height
(1106)     jmp   VBG_WRITE_CHARX
(1107) 
(1108) VBG_FULL_SEGX:                          ; Bargaph
(1109)     sub   [X+VBG_SEG_HEIGHTX],08h       ; Subtract full segment
(1110)     mov   A,07h                        ; Load full segment
(1111) 
(1112) VBG_WRITE_CHARX:                        ; Write character to display
(1113)     call  LCD_1_WriteData              ; Write value
(1114)     pop   A
(1115)     dec   A
(1116)     dec   [X+VBG_CHAR_HEIGHTX]
(1117)     jnz   VBG_LOOPX
(1118)     ret
(1119) .ENDSECTION
(1120) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
(1121) 
(1122) .SECTION
(1123) ;-----------------------------------------------------------------------------
(1124) ;  FUNCTION NAME: LCD_1_DrawVBG
(1125) ;
(1126) ;  DESCRIPTION:
(1127) ;     Draw a vertical bargraph on the LCD with the given parameters.
(1128) ;
(1129) ;
(1130) ;-----------------------------------------------------------------------------
(1131) ;
(1132) ;  FASTCALL16 ARGUMENTS:
(1133) ;
(1134) ;   [SP-3] => Starting row for bargraph 0 to 3
(1135) ;   [SP-4] => Starting Column for bargraph 0 to 40+
(1136) ;   [SP-5] => Height of bargraph in chars 1 - 4
(1137) ;   [SP-6] => Position of pointer in segments 8 times height
(1138) ;  RETURNS:
(1139) ;
(1140) ;  SIDE EFFECTS:
(1141) ;    The A and X registers may be modified by this or future implementations
(1142) ;    of this function.  The same is true for all RAM page pointer registers in
(1143) ;    the Large Memory Model.  When necessary, it is the calling function's
(1144) ;    responsibility to perserve their values across calls to fastcall16 
(1145) ;    functions.
(1146) ;          
(1147) ;    Currently only the page pointer registers listed below are modified: 
(1148) ;          CUR_PP
(1149) ;
(1150) ;    If LCD_1_Init is not called before this function, the
(1151) ;    bargraph will not be drawn properly.
(1152) ;
(1153) ; Stack offset constants
(1154) VBG_ROW:        equ -3
(1155) VBG_COL:            equ -4
(1156) VBG_CHAR_HEIGHT:    equ -5
(1157) VBG_SEG_HEIGHT:     equ -6
(1158) 
(1159) _LCD_1_DrawVBG:
(1160)     RAM_PROLOGUE RAM_USE_CLASS_2
(1161)     mov   X, SP
    071B: 4F       MOV   X,SP
(1162)     mov   A, [X+VBG_ROW]
    071C: 52 FD    MOV   A,[X-3]
(1163)     and   A,03h                        ; Make sure only rows 0 - 3 are valid
    071E: 21 03    AND   A,3
(1164) VBG_LOOP:
(1165)     push  A
    0720: 08       PUSH  A
(1166)     index LCD_ROW_OFFSET               ; Get row offset
    0721: FF 95    INDEX 0x06B8
(1167)     add   A,[X+VBG_COL]                ; Add column offset to position
    0723: 03 FC    ADD   A,[X-4]
(1168)     call  LCD_1_Control                ; Position Cursor
    0725: 9E 79    CALL  0x05A0
(1169)     cmp   [X+VBG_SEG_HEIGHT],00h       ; Check for zero segs
    0727: 3D FA 00 CMP   [X-6],0
(1170)     jnz   VBG_NZ_SEG
    072A: B0 05    JNZ   0x0730
(1171)     mov   A,' '                        ; Load space character
    072C: 50 20    MOV   A,32
(1172)     jmp   VBG_WRITE_CHAR
    072E: 80 13    JMP   0x0742
(1173) VBG_NZ_SEG:
(1174)     cmp   [X+VBG_SEG_HEIGHT],09h       ; Check for full segment
    0730: 3D FA 09 CMP   [X-6],9
(1175)     jnc   VBG_FULL_SEG
    0733: D0 09    JNC   0x073D
(1176)                                        ; Partial segment between 1 and 8
(1177)     mov   A,[X+VBG_SEG_HEIGHT]
    0735: 52 FA    MOV   A,[X-6]
(1178)     dec   A
    0737: 78       DEC   A
(1179)     mov   [X+VBG_SEG_HEIGHT],00h       ; Zero segment height
    0738: 56 FA 00 MOV   [X-6],0
(1180)     jmp   VBG_WRITE_CHAR
    073B: 80 06    JMP   0x0742
(1181) 
(1182) VBG_FULL_SEG:                          ; Bargaph
(1183)     sub   [X+VBG_SEG_HEIGHT],08h       ; Subtract full segment
    073D: 17 FA 08 SUB   [X-6],8
(1184)     mov   A,07h                        ; Load full segment
    0740: 50 07    MOV   A,7
(1185) 
(1186) VBG_WRITE_CHAR:                        ; Write character to display
(1187)     call  LCD_1_WriteData              ; Write value
    0742: 9E 48    CALL  0x058C
(1188)     pop   A
    0744: 18       POP   A
(1189)     dec   A
    0745: 78       DEC   A
(1190)     dec   [X+VBG_CHAR_HEIGHT]
    0746: 7B FB    DEC   [X-5]
(1191)     jnz   VBG_LOOP
    0748: BF D7    JNZ   0x0720
    074A: 70 3F    AND   F,63
(1192)     RAM_EPILOGUE RAM_USE_CLASS_2
    074C: 71 C0    OR    F,192
(1193)     ret
    074E: 7F       RET   
(1194) .ENDSECTION
(1195) 
(1196) .SECTION
(1197) ;-----------------------------------------------------------------------------
(1198) ;  FUNCTION NAME: LCD_1_InitVBG
(1199) ;
(1200) ;  DESCRIPTION:
(1201) ;     Initialize the vertical bargraph characters.
(1202) ;
(1203) ;-----------------------------------------------------------------------------
(1204) ;
(1205) ;  ARGUMENTS:  none
(1206) ;
(1207) ;  RETURNS:  none
(1208) ;
(1209) ;  SIDE EFFECTS:
(1210) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(1211) ;    Only one type of bargraph (horizontal or vertical) may be used
(1212) ;    at a time since they each require their own set of characters.
(1213) ;
(1214) ;  SIDE EFFECTS:
(1215) ;    The A and X registers may be modified by this or future implementations
(1216) ;    of this function.  The same is true for all RAM page pointer registers in
(1217) ;    the Large Memory Model.  When necessary, it is the calling function's
(1218) ;    responsibility to perserve their values across calls to fastcall16 
(1219) ;    functions.
(1220) ;          
(1221) ;    Currently only the page pointer registers listed below are modified: 
(1222) ;          CUR_PP
(1223) ;
(1224) ; Stack offset constants
(1225) VBGDATA_CTR:      equ    00h           ; Char data count stack offset
(1226) VBG_BYTES:        equ    01h           ; Byte counter stack offset
(1227) 
(1228)  LCD_1_InitVBG:
(1229) _LCD_1_InitVBG:
(1230)     RAM_PROLOGUE RAM_USE_CLASS_2
(1231)     mov   X,SP                         ; Get location of stack
    074F: 4F       MOV   X,SP
(1232)     push  A                            ; Create 2 locations
    0750: 08       PUSH  A
(1233)     push  A
    0751: 08       PUSH  A
(1234) 
(1235)     mov   A,CG_RAM_OFFSET              ; Setup pointer
    0752: 50 40    MOV   A,64
(1236)     call  LCD_1_Control                ; Position the CG pointer
    0754: 9E 4A    CALL  0x05A0
(1237)     mov   [X+VBGDATA_CTR],01h          ; Reset data counter
    0756: 56 00 01 MOV   [X+0],1
(1238) 
(1239)  VBG_Loop1:                            ; loop once for each 8 characters
(1240)     mov   [X+VBG_BYTES],08h            ; Load cycle pointer
    0759: 56 01 08 MOV   [X+1],8
(1241)  VBG_Loop2:                            ; Loop once for each line in character (8 times)
(1242)     mov   A,[X+VBGDATA_CTR]
    075C: 52 00    MOV   A,[X+0]
(1243)     cmp   A,[X+VBG_BYTES]
    075E: 3B 01    CMP   A,[X+1]
(1244)     jnc   VBG_SOLID
    0760: D0 05    JNC   0x0766
(1245)     mov   A,00h                        ; Empty line
    0762: 50 00    MOV   A,0
(1246)     jmp   VBG_Load                     ; Jump to load the bargraph
    0764: 80 03    JMP   0x0768
(1247) VBG_SOLID:
(1248)     mov   A,FFh                        ; Load solid line
    0766: 50 FF    MOV   A,255
(1249) VBG_Load:
(1250)     call  LCD_1_WriteData              ; character data
    0768: 9E 22    CALL  0x058C
(1251)     dec   [X+VBG_BYTES]                ; Dec byte counter
    076A: 7B 01    DEC   [X+1]
(1252)     jnz   VBG_Loop2                    ; End Loop 2
    076C: BF EF    JNZ   0x075C
(1253)     inc   [X+VBGDATA_CTR]
    076E: 77 00    INC   [X+0]
(1254)     cmp   [X+VBGDATA_CTR],09h
    0770: 3D 00 09 CMP   [X+0],9
(1255)     jnz   VBG_Loop1                    ; End Loop1
    0773: BF E5    JNZ   0x0759
(1256) 
(1257)     pop  A
    0775: 18       POP   A
(1258)     pop  A
    0776: 18       POP   A
(1259)     mov  A,DISP_ON                    ; Turn on display, don't really
    0777: 50 0C    MOV   A,12
(1260)     call LCD_1_Control                 ; need this.
    0779: 9E 25    CALL  0x05A0
    077B: 70 3F    AND   F,63
(1261)     RAM_EPILOGUE RAM_USE_CLASS_2
    077D: 71 C0    OR    F,192
(1262)     ret
    077F: 7F       RET   
    0780: 00       SWI   
    0781: 10       PUSH  X
    0782: 18       POP   A
    0783: 1C 1E    SBB   [zero+2],A
    0785: 1F 1F 00 SBB   [X+31],0
    0788: 10       PUSH  X
    0789: 08       PUSH  A
    078A: 04 02    ADD   [2],A
    078C: 01 00    ADD   A,0
(1263) .ENDSECTION
(1264) 
(1265) ;-----------------------------------------------------------------------------
(1266) ;  FUNCTION NAME: LCD_1_InitBG
(1267) ;
(1268) ;  DESCRIPTION:
(1269) ;     Initialize horizontal bargraph characters
(1270) ;
(1271) ;-----------------------------------------------------------------------------
(1272) ;
(1273) ;  ARGUMENTS:
(1274) ;     A = type  0 = full                   |||||||||........
(1275) ;               1 = single vertical line   ..........|......
(1276) ;
(1277) ;  RETURNS:
(1278) ;
(1279) ;  SIDE EFFECTS:
(1280) ;    The A and X registers may be modified by this or future implementations
(1281) ;    of this function.  The same is true for all RAM page pointer registers in
(1282) ;    the Large Memory Model.  When necessary, it is the calling function's
(1283) ;    responsibility to perserve their values across calls to fastcall16 
(1284) ;    functions.
(1285) ;          
(1286) ;    Currently only the page pointer registers listed below are modified: 
(1287) ;          CUR_PP
(1288) ;
(1289) ;    Only one type of bargraph (horizontal or vertical) may be used
(1290) ;    at a time since they each require their own set of characters.
(1291) ;
(1292) ;  THEORY of OPERATION or PROCEDURE:
(1293) ;    This function writes to the LCD character RAM to generate 8 custom
(1294) ;    characters used to generated one of two horizontal bargraphs.
(1295) ;
(1296) .LITERAL
(1297)  BG_TYPE1:: ; ....., |...., ||..., |||.., ||||., |||||, |||||
(1298)      DB    00h, 10h, 18h, 1Ch, 1Eh, 1Fh, 1Fh
(1299)  BG_TYPE2:: ; ....., |...., .|..., ..|.., ...|., ....|, .....
(1300)     DB  00h, 10h, 08h, 04h, 02h, 01h, 00h
(1301) .ENDLITERAL
(1302) 
(1303) .SECTION
(1304) ; Stack offset constants
(1305) BGDATA_PTR:   equ    00h               ; Stack offsets
(1306) BGCHARS:      equ    01h
(1307) BGTYPE:       equ    02h
(1308) 
(1309)  LCD_1_InitBG:
(1310) _LCD_1_InitBG:
(1311)     RAM_PROLOGUE RAM_USE_CLASS_2
(1312)     mov   X,SP                         ; Get location of stack
    078E: 4F       MOV   X,SP
(1313)     add   SP,3
    078F: 38 03    ADD   SP,3
(1314)     mov   [X+BGTYPE],A                 ; Store the bargraph type
    0791: 54 02    MOV   [X+2],A
(1315) 
(1316)     mov   A,CG_RAM_OFFSET              ; Setup pointer
    0793: 50 40    MOV   A,64
(1317)     call  LCD_1_Control                ; Position the CG pointer
    0795: 9E 09    CALL  0x05A0
(1318)     mov   [X+BGDATA_PTR],00h           ; Reset pointer to BG data
    0797: 56 00 00 MOV   [X+0],0
(1319) 
(1320)  BG_Loop1:
(1321)     mov   [X+BGCHARS],08h              ; Load cycle pointer
    079A: 56 01 08 MOV   [X+1],8
(1322)  BG_Loop2:
(1323)     mov   A,[X+BGDATA_PTR]
    079D: 52 00    MOV   A,[X+0]
(1324)     cmp   [X+BGTYPE],00h               ; Check which bargraph
    079F: 3D 02 00 CMP   [X+2],0
(1325)     jnz   BG_OTHER
    07A2: B0 05    JNZ   0x07A8
(1326)     index BG_TYPE1
    07A4: FF DA    INDEX 0x0780
(1327)     jmp   BG_Load
    07A6: 80 03    JMP   0x07AA
(1328)  BG_OTHER:
(1329)     index BG_TYPE2
    07A8: FF DD    INDEX 0x0787
(1330)  BG_Load:
(1331)     call  LCD_1_WriteData
    07AA: 9D E0    CALL  0x058C
(1332)     dec   [X+BGCHARS]                  ; Character builder counter
    07AC: 7B 01    DEC   [X+1]
(1333)     jnz   BG_Loop2
    07AE: BF EE    JNZ   0x079D
(1334)     inc   [X+BGDATA_PTR]               ; Advance to next character
    07B0: 77 00    INC   [X+0]
(1335)     cmp   [X+BGDATA_PTR],07h
    07B2: 3D 00 07 CMP   [X+0],7
(1336)     jnz   BG_Loop1
    07B5: BF E4    JNZ   0x079A
(1337) 
(1338)     add   SP,-3
    07B7: 38 FD    ADD   SP,253
(1339)     mov   A,DISP_ON
    07B9: 50 0C    MOV   A,12
(1340)     call  LCD_1_Control
    07BB: 9D E3    CALL  0x05A0
    07BD: 70 3F    AND   F,63
(1341)     RAM_EPILOGUE RAM_USE_CLASS_2
    07BF: 71 C0    OR    F,192
(1342)     ret
    07C1: 7F       RET   
FILE: lib\delsig11_1int.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  FILENAME: DELSIG11_1INT.asm
(0004) ;;   Version: 3.2, Updated on 2005/10/05 at 11:41:06
(0005) ;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0006) ;;
(0007) ;;  DESCRIPTION: Assembler interrupt service routine for the 11-bit Delta-
(0008) ;;               Sigma A/D Converter User Module. This code works for both
(0009) ;;               the first and second-order modulator topologies.
(0010) ;;-----------------------------------------------------------------------------
(0011) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
(0012) ;;*****************************************************************************
(0013) ;;*****************************************************************************
(0014) 
(0015) include "m8c.inc"
(0016) include "memory.inc"
(0017) include "DELSIG11_1.inc"
(0018) 
(0019) 
(0020) ;-----------------------------------------------
(0021) ;  Global Symbols
(0022) ;-----------------------------------------------
(0023) 
(0024) export _DELSIG11_1_ADConversion_ISR
(0025) export  DELSIG11_1_fState
(0026) 
(0027) IF (DELSIG11_1_POLL_ENABLE)
(0028) export _DELSIG11_1_iResult
(0029) export  DELSIG11_1_iResult
(0030) export _DELSIG11_1_bfStatus
(0031) export  DELSIG11_1_bfStatus
(0032) ENDIF
(0033) 
(0034) 
(0035) ;-----------------------------------------------
(0036) ; Variable Allocation
(0037) ;-----------------------------------------------
(0038) AREA InterruptRAM (RAM, REL, CON)
(0039) 
(0040) iOut:    BLK  2  ; Decimate by 7 bit answer
(0041) iTmp2:   BLK  2  ; z^-2
(0042) iTmp1:   BLK  2  ; z^-1
(0043) iAns:    BLK  2  ; Final answer calculated from  iOut + 2iOut(-1) + iOut(-2)
(0044) 
(0045) DELSIG11_1_fState: BLK 1   ; Current state
(0046) 
(0047) IF (DELSIG11_1_POLL_ENABLE)
(0048) _DELSIG11_1_iResult:
(0049)  DELSIG11_1_iResult:       BLK   2  ;A/D value
(0050) _DELSIG11_1_bfStatus:
(0051)  DELSIG11_1_bfStatus:      BLK   1  ;Data Valid Flag
(0052) ENDIF
(0053) 
(0054) 
(0055) ;-----------------------------------------------
(0056) ;  Private Symbols
(0057) ;-----------------------------------------------
(0058) MSB:                   equ  0
(0059) LSB:                   equ  1
(0060) 
(0061) 
(0062) ;@PSoC_UserCode_INIT@ (Do not change this line.)
(0063) ;---------------------------------------------------
(0064) ; Insert your custom declarations below this banner
(0065) ;---------------------------------------------------
(0066) 
(0067) ;------------------------
(0068) ; Includes
(0069) ;------------------------
(0070) 
(0071) 	
(0072) ;------------------------
(0073) ;  Constant Definitions
(0074) ;------------------------
(0075) 
(0076) 
(0077) ;------------------------
(0078) ; Variable Allocation
(0079) ;------------------------
(0080) 
(0081) 
(0082) ;---------------------------------------------------
(0083) ; Insert your custom declarations above this banner
(0084) ;---------------------------------------------------
(0085) ;@PSoC_UserCode_END@ (Do not change this line.)
(0086) 
(0087) 
(0088) AREA UserModules (ROM, REL)
(0089) 
(0090) ;;-----------------------------------------------------------------------------
(0091) ;;  FUNCTION NAME: _DELSIG11_1_ADConversion_ISR:
(0092) ;;
(0093) ;;  DESCRIPTION:   Implements a state machine that takes data from the hardware
(0094) ;;                 decimator and completes the calculation of a sinc^2 filter
(0095) ;;                 to produce an 11-bit result.
(0096) ;;-----------------------------------------------------------------------------
(0097) ;;  
(0098) ;;  state 1   calculate first half of iOut
(0099) ;;  state 2   calculate rest of iOut, calculate middle of iAns
(0100) ;;  state 3   calculate first half of iOut
(0101) ;;  state 4   calculate rest of iOut, calculate rest of iAns and
(0102) ;;              start of new iAns get this data.
(0103) 
(0104) _DELSIG11_1_ADConversion_ISR:
(0105)    inc   [DELSIG11_1_fState]           ; Advance to next state
    07C2: 76 0B    INC   [11]
(0106)    tst   [DELSIG11_1_fState], 01h
    07C4: 47 0B 01 TST   [11],1
(0107)    jz    .State2_State4_Entry
    07C7: A0 0E    JZ    0x07D6
(0108) 
(0109)    ; State 1 or State 3: calculate half of iOut
(0110)                      ;  Variables:       Out              Tmp2     Tmp1   Deci
(0111)                      ;  Initial state:   (x3-x2)-(x2-x1)  (x2-x1)  x1     x0
(0112) 
(0113)                                        ; Out = Tmp2
(0114)    mov   [iOut+LSB], [iTmp2+LSB]       ; Out              Tmp2     Tmp1   Deci
    07C9: 5F 04 06 MOV   [4],[6]
(0115)    mov   [iOut+MSB], [iTmp2+MSB]       ; (x2-x1)          (x2-x1)  x1     x0
    07CC: 5F 03 05 MOV   [3],[5]
(0116) 
(0117)                                        ; Tmp2 = Tmp1
(0118)    mov   [iTmp2+LSB], [iTmp1+LSB]      ; Out              Tmp2     Tmp1   Deci
    07CF: 5F 06 08 MOV   [6],[8]
(0119)    mov   [iTmp2+MSB], [iTmp1+MSB]      ; (x2-x1)          x1       x1     x0
    07D2: 5F 05 07 MOV   [5],[7]
(0120)    reti                                ; End of State 1 & State 3 process
    07D5: 7E       RETI  
(0121) 
(0122) 
(0123) .State2_State4_Entry:
(0124)    push  A           ;  Variables:       Out              Tmp2     Tmp1   Deci
    07D6: 08       PUSH  A
(0125)                      ;  Initial state:   (x3-x2)-(x2-x1)  (x2-x1)  x1     x0
(0126) 
(0127)    mov   A, reg[DEC_DL]                ;
    07D7: 5D E5    MOV   A,REG[229]
(0128)    mov   [iTmp1+LSB], A                ; Tmp1  = Deci
    07D9: 53 08    MOV   [8],A
(0129)    sub   [iTmp2+LSB], A                ; Tmp2 -= Deci
    07DB: 14 06    SUB   [6],A
(0130)    mov   A, reg[DEC_DH]                ;
    07DD: 5D E4    MOV   A,REG[228]
(0131)    mov   [iTmp1+MSB], A                ; Out              Tmp2     Tmp1   Deci
    07DF: 53 07    MOV   [7],A
(0132)    sbb   [iTmp2+MSB], A                ; (x2-x1)          x1-x0    x0     x0
    07E1: 1C 05    SBB   [5],A
(0133) 
(0134)    mov   A, [iTmp2+LSB]                ; --> Subtract Tmp2 from iOut:
    07E3: 51 06    MOV   A,[6]
(0135)    sub   [iOut+LSB], A                 ;
    07E5: 14 04    SUB   [4],A
(0136)    mov   A, [iTmp2+MSB]                ; Out              Tmp2     Tmp1   Deci
    07E7: 51 05    MOV   A,[5]
(0137)    sbb   [iOut+MSB], A                 ; (x2-x1)-(x1-x0)  x1-x0    x0     x0
    07E9: 1C 03    SBB   [3],A
(0138) 
(0139)    tst [DELSIG11_1_fState], 04h
    07EB: 47 0B 04 TST   [11],4
(0140)    jnz .State4_Continuation
    07EE: B0 0B    JNZ   0x07FA
(0141) 
(0142)    ; State 2: calculate the 'middle' of iAns
(0143)    ;
(0144)    mov   A, [iOut+LSB]
    07F0: 51 04    MOV   A,[4]
(0145)    add   [iAns+LSB], A
    07F2: 04 0A    ADD   [10],A
(0146)    mov   A, [iOut+MSB]
    07F4: 51 03    MOV   A,[3]
(0147)    adc   [iAns+MSB], A
    07F6: 0C 09    ADC   [9],A
(0148)    pop   A
    07F8: 18       POP   A
(0149)    reti
    07F9: 7E       RETI  
(0150) 
(0151)    ; State4: calculate rest of iOut, calculate rest of iAns
(0152)    ;
(0153) .State4_Continuation:
(0154)    mov   [DELSIG11_1_fState], 0  ; Reset state machine for next cycle
    07FA: 55 0B 00 MOV   [11],0
(0155)    push  X
    07FD: 10       PUSH  X
(0156) 
(0157)    asr   [iOut+MSB]                    ; iOut is always an even value, so divide
    07FE: 68 03    ASR   [3]
(0158)    rrc   [iOut+LSB]                    ;   by two to allow an extra bit of range
    0800: 6E 04    RRC   [4]
(0159) 
(0160)    mov A, [iOut+LSB]
    0802: 51 04    MOV   A,[4]
(0161)    add [iAns+LSB], A
    0804: 04 0A    ADD   [10],A
(0162)    mov A, [iOut+MSB]
    0806: 51 03    MOV   A,[3]
(0163)    adc [iAns+MSB], A
    0808: 0C 09    ADC   [9],A
(0164) 
(0165) IF DELSIG11_1_LEFTJUSTIFIED
(0166)    jc  .LessThanFullScale              ;
    080A: C0 0C    JC    0x0817
(0167)    cmp [iAns+MSB], 80h                 ; Is the value less than full scale?
    080C: 3C 09 80 CMP   [9],128
(0168)    jnz .LessThanFullScale              ;    Yes, go set it up
    080F: B0 07    JNZ   0x0817
(0169)    mov X, 7fh                          ;     No, Limit the value to plus full-scale
    0811: 57 7F    MOV   X,127
(0170)    mov A, ffh                          ;         range
    0813: 50 FF    MOV   A,255
(0171)    jmp   .ConversionReady
    0815: 80 05    JMP   0x081B
(0172) 
(0173) .LessThanFullScale:
(0174)    mov X, [iAns+MSB]                   ; Final result in [X,A]
    0817: 58 09    MOV   X,[9]
(0175)    mov A, [iAns+LSB]                   ; Fall through to .ConversionReady
    0819: 51 0A    MOV   A,[10]
(0176) ENDIF
(0177) 
(0178) IF DELSIG11_1_RIGHTJUSTIFIED
(0179)    jc    .LessThanFullScale            ;
(0180)    cmp   [iAns+MSB], 80h               ; Is the value less than full scale?
(0181)    jnz   .LessThanFullScale            ;    Yes, go set it up
(0182)    mov   X, 03h                        ;     No, Limit the value to plus full-scale
(0183)    mov   A, ffh                        ;         range
(0184)    jmp   .ConversionReady
(0185) 
(0186) .LessThanFullScale:
(0187)    mov   A, [iAns+LSB]                 ; set up and shift the data...
(0188)    asr   [iAns+MSB]
(0189)    rrc   A
(0190)    asr   [iAns+MSB]
(0191)    rrc   A
(0192)    asr   [iAns+MSB]
(0193)    rrc   A
(0194)    asr   [iAns+MSB]
(0195)    rrc   A
(0196)    asr   [iAns+MSB]
(0197)    rrc   A
(0198)    mov   X, [iAns+MSB]
(0199) ENDIF
(0200) 
(0201) .ConversionReady:
(0202) 
(0203)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
(0204)    ;---------------------------------------------------
(0205)    ; Insert your custom code below this banner
(0206)    ;---------------------------------------------------
(0207)    ;  data is now in X, A
(0208)    ;  This interrupt service routine has already
(0209)    ;  preserved the values of the A and X CPU registers
(0210)    ;  and will restore them before returning control...
(0211) 
(0212) IF (DELSIG11_1_POLL_ENABLE)
(0213)     mov [DELSIG11_1_iResult+LSB], A              ; Save result in iResult
    081B: 53 0D    MOV   [13],A
(0214)     mov [DELSIG11_1_iResult+MSB], X
    081D: 5A 0C    MOV   [12],X
(0215)     mov [DELSIG11_1_bfStatus], DELSIG11_1_DATA_READY_BIT; Set valid data flag
    081F: 55 0E 10 MOV   [14],16
(0216) ENDIF
(0217) 
(0218) 
(0219)    ;---------------------------------------------------
(0220)    ; Insert your custom code above this banner
(0221)    ;---------------------------------------------------
(0222)    ;@PSoC_UserCode_END@ (Do not change this line.)
(0223) 
(0224)    mov [iAns+LSB], [iOut+LSB]         ;start next answer
    0822: 5F 0A 04 MOV   [10],[4]
(0225)    mov [iAns+MSB], [iOut+MSB]
    0825: 5F 09 03 MOV   [9],[3]
(0226)    pop X
    0828: 20       POP   X
(0227)    pop A
    0829: 18       POP   A
(0228)    reti
    082A: 7E       RETI  
FILE: lib\delsig11_1.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  FILENAME: DELSIG11_1.asm
(0004) ;;   Version: 3.2, Updated on 2005/10/05 at 11:41:06
(0005) ;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
(0006) ;;
(0007) ;;  DESCRIPTION: Assembler source for the 11-bit Delta-Sigma A/D Converter
(0008) ;;               User Module with 1st-order modulator.
(0009) ;;
(0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
(0011) ;;        arguments and observe the associated "Registers are volatile" policy.
(0012) ;;        This means it is the caller's responsibility to preserve any values
(0013) ;;        in the X and A registers that are still needed after the API functions
(0014) ;;        returns. For Large Memory Model devices it is also the caller's 
(0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
(0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
(0017) ;;        now, there is no guarantee that will remain the case in future releases.
(0018) ;;-----------------------------------------------------------------------------
(0019) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
(0020) ;;*****************************************************************************
(0021) ;;*****************************************************************************
(0022) 
(0023) include "m8c.inc"
(0024) include "memory.inc"                ; see this for RAM use & proxy classes
(0025) include "DELSIG11_1.inc"
(0026) 
(0027) 
(0028) ;-----------------------------------------------
(0029) ;  Global Symbols
(0030) ;-----------------------------------------------
(0031) export  DELSIG11_1_Start
(0032) export _DELSIG11_1_Start
(0033) export  DELSIG11_1_SetPower
(0034) export _DELSIG11_1_SetPower
(0035) export  DELSIG11_1_Stop
(0036) export _DELSIG11_1_Stop
(0037) export  DELSIG11_1_StartAD
(0038) export _DELSIG11_1_StartAD
(0039) export  DELSIG11_1_StopAD
(0040) export _DELSIG11_1_StopAD
(0041) 
(0042) IF (DELSIG11_1_POLL_ENABLE)
(0043) export  DELSIG11_1_fIsDataAvailable:
(0044) export _DELSIG11_1_fIsDataAvailable:
(0045) export  DELSIG11_1_iGetDataClearFlag:
(0046) export _DELSIG11_1_iGetDataClearFlag:
(0047) export  DELSIG11_1_iGetData:
(0048) export _DELSIG11_1_iGetData:
(0049) export  DELSIG11_1_ClearFlag:
(0050) export _DELSIG11_1_ClearFlag:
(0051) ENDIF
(0052) 
(0053) 
(0054) ;-----------------------------------------------
(0055) ;  Constant Definitions
(0056) ;-----------------------------------------------
(0057) 
(0058) CONTROL_REG_ENABLE_BIT:                    equ  01h     ; Control register start bit
(0059) POWERMASK:                                 equ  03h     ; Analog PSoC Block Power bits
(0060) NOAZ:                                      equ  1       ;
(0061) SC_AZ_MASK:                                equ  20h     ; Switched Cap Auto Zero bit
(0062) SC_FSW0_MASK:                              equ  10h     ; Switched Cap Feedback '0' switch
(0063) 
(0064) 
(0065) AREA UserModules (ROM, REL)
(0066) 
(0067) .SECTION
(0068) ;-----------------------------------------------------------------------------
(0069) ;  FUNCTION NAME: DELSIG11_1_Start
(0070) ;  FUNCTION NAME: DELSIG11_1_SetPower
(0071) ;
(0072) ;  DESCRIPTION: Applies power setting to the module's analog PSoc block.
(0073) ;-----------------------------------------------------------------------------
(0074) ;
(0075) ;  ARGUMENTS:    The A register contains the power setting.
(0076) ;  RETURNS:      Nothing.
(0077) ;  SIDE EFFECTS: 
(0078) ;    The A and X registers may be modified by this or future implementations
(0079) ;    of this function.  The same is true for all RAM page pointer registers in
(0080) ;    the Large Memory Model.  When necessary, it is the calling function's
(0081) ;    responsibility to perserve their values across calls to fastcall16 
(0082) ;    functions.
(0083) ;
(0084)  DELSIG11_1_Start:
(0085) _DELSIG11_1_Start:
(0086)  DELSIG11_1_SetPower:
(0087) _DELSIG11_1_SetPower:
(0088)    RAM_PROLOGUE   RAM_USE_CLASS_2
(0089)    mov  X, SP                                    ; Set up Stack frame
    082B: 4F       MOV   X,SP
(0090)    and  A, POWERMASK                             ; Ensure value is legal
    082C: 21 03    AND   A,3
(0091)    push A
    082E: 08       PUSH  A
(0092)    mov  A, reg[DELSIG11_1_AtoDcr3]               ; First SC block:
    082F: 5D 87    MOV   A,REG[135]
(0093)    and  A, ~POWERMASK                            ;   clear power bits to zero
    0831: 21 FC    AND   A,252
(0094)    or   A, [ X ]                                 ;   establish new value
    0833: 2B 00    OR    A,[X+0]
(0095)    mov  reg[DELSIG11_1_AtoDcr3], A               ;   change the actual setting
    0835: 60 87    MOV   REG[135],A
(0096)    pop  A
    0837: 18       POP   A
    0838: 70 3F    AND   F,63
(0097)    RAM_EPILOGUE  RAM_USE_CLASS_2
    083A: 71 C0    OR    F,192
(0098)    ret
    083C: 7F       RET   
(0099) .ENDSECTION
(0100) 
(0101) 
(0102) .SECTION
(0103) ;-----------------------------------------------------------------------------
(0104) ;  FUNCTION NAME: DELSIG11_1_Stop
(0105) ;
(0106) ;  DESCRIPTION:   Removes power from the module's analog PSoc block.
(0107) ;-----------------------------------------------------------------------------
(0108) ;
(0109) ;  ARGUMENTS:     None.
(0110) ;  RETURNS:       Nothing.
(0111) ;  SIDE EFFECTS: 
(0112) ;    The A and X registers may be modified by this or future implementations
(0113) ;    of this function.  The same is true for all RAM page pointer registers in
(0114) ;    the Large Memory Model.  When necessary, it is the calling function's
(0115) ;    responsibility to perserve their values across calls to fastcall16 
(0116) ;    functions.
(0117) ;
(0118)  DELSIG11_1_Stop:
(0119) _DELSIG11_1_Stop:
(0120)    RAM_PROLOGUE   RAM_USE_CLASS_1
(0121)    and  reg[DELSIG11_1_AtoDcr3], ~POWERMASK
    083D: 41 87 FC AND   REG[135],252
(0122)    RAM_EPILOGUE  RAM_USE_CLASS_1
(0123)    ret
    0840: 7F       RET   
(0124) .ENDSECTION
(0125) 
(0126) 
(0127) .SECTION
(0128) ;-----------------------------------------------------------------------------
(0129) ;  FUNCTION NAME: DELSIG11_1_StartAD
(0130) ;
(0131) ;  DESCRIPTION: Activates interrupts for this user module and begins sampling.
(0132) ;-----------------------------------------------------------------------------
(0133) ;
(0134) ;  ARGUMENTS:    None.
(0135) ;  RETURNS:      Nothing.
(0136) ;  SIDE EFFECTS: 
(0137) ;    The A and X registers may be modified by this or future implementations
(0138) ;    of this function.  The same is true for all RAM page pointer registers in
(0139) ;    the Large Memory Model.  When necessary, it is the calling function's
(0140) ;    responsibility to perserve their values across calls to fastcall16 
(0141) ;    functions.
(0142) ;          
(0143) ;    Currently only the page pointer registers listed below are modified:
(0144) ;       CUR_PP
(0145) ;
(0146)  DELSIG11_1_StartAD:
(0147) _DELSIG11_1_StartAD:
(0148)    RAM_PROLOGUE   RAM_USE_CLASS_4
(0149)    RAM_SETPAGE_CUR >DELSIG11_1_fState
    0841: 62 D0 00 MOV   REG[208],0
(0150) 
(0151)    M8C_SetBank1
    0844: 71 10    OR    F,16
(0152)    and reg[E7h], 3Fh             ; if we are in 29xxx then this sets decimator to comp mode   
    0846: 41 E7 3F AND   REG[231],63
(0153)    M8C_SetBank0
    0849: 70 EF    AND   F,239
(0154) 
(0155)    mov [DELSIG11_1_fState], 0                        ; Reset state machine
    084B: 55 0B 00 MOV   [11],0
(0156)    M8C_EnableIntMask DELSIG11_1_INT_REG, DELSIG11_1_INT_MASK          ; Enable timer interrupt
    084E: 43 E1 10 OR    REG[225],16
(0157)    and  reg[DELSIG11_1_AtoDcr3], ~SC_FSW0_MASK       ; Enable the Integrator ...
    0851: 41 87 EF AND   REG[135],239
(0158) 
(0159) IF NOAZ
(0160)    and  reg[DELSIG11_1_AtoDcr2], ~SC_AZ_MASK         ; Turn off AutoZero
    0854: 41 86 DF AND   REG[134],223
(0161) ENDIF
(0162)                                                      ; Initialize Timer ...
(0163)    mov  reg[DELSIG11_1_TimerDR1], FFh                ;   set period = 256
    0857: 62 31 FF MOV   REG[49],255
(0164)    mov  reg[DELSIG11_1_TimerCR0], CONTROL_REG_ENABLE_BIT
    085A: 62 33 01 MOV   REG[51],1
(0165)    RAM_EPILOGUE  RAM_USE_CLASS_4
(0166)    ret
    085D: 7F       RET   
(0167) .ENDSECTION
(0168) 
(0169) 
(0170) .SECTION
(0171) ;-----------------------------------------------------------------------------
(0172) ;  FUNCTION NAME: DELSIG11_1_StopAD
(0173) ;
(0174) ;  DESCRIPTION: Shuts down the A/D is an orderly manner.  The Timer stops
(0175) ;               operating and it's interrupt is disabled. Analog power is
(0176) ;               still supplied to the analog block, however.
(0177) ;-----------------------------------------------------------------------------
(0178) ;
(0179) ;  ARGUMENTS:    None.
(0180) ;  RETURNS:      Nothing.
(0181) ;  SIDE EFFECTS: 
(0182) ;    The A and X registers may be modified by this or future implementations
(0183) ;    of this function.  The same is true for all RAM page pointer registers in
(0184) ;    the Large Memory Model.  When necessary, it is the calling function's
(0185) ;    responsibility to perserve their values across calls to fastcall16 
(0186) ;    functions.
(0187) ;
(0188)  DELSIG11_1_StopAD:
(0189) _DELSIG11_1_StopAD:
(0190)    RAM_PROLOGUE   RAM_USE_CLASS_1
(0191) 
(0192)    M8C_SetBank1
    085E: 71 10    OR    F,16
(0193)    or  reg[E7h], 80h             ; if we are in 29xxx then this sets decimator to full alg. mode   
    0860: 43 E7 80 OR    REG[231],128
(0194)    M8C_SetBank0
    0863: 70 EF    AND   F,239
(0195) 
(0196)    mov  reg[DELSIG11_1_TimerCR0], 00h                ; Disable the Timer
    0865: 62 33 00 MOV   REG[51],0
(0197)    M8C_DisableIntMask DELSIG11_1_INT_REG, DELSIG11_1_INT_MASK         ; Disable its interrupt
    0868: 41 E1 EF AND   REG[225],239
(0198) IF NOAZ
(0199)    or   reg[DELSIG11_1_AtoDcr2], SC_AZ_MASK          ; Force the Integrator into reset
    086B: 43 86 20 OR    REG[134],32
(0200) ENDIF
(0201)    or   reg[DELSIG11_1_AtoDcr3], SC_FSW0_MASK        ; Reset Integrator
    086E: 43 87 10 OR    REG[135],16
(0202)    RAM_EPILOGUE  RAM_USE_CLASS_1
(0203)    ret
    0871: 7F       RET   
(0204) .ENDSECTION
(0205) 
(0206) 
(0207) IF (DELSIG11_1_POLL_ENABLE)
(0208) 
(0209) .SECTION
(0210) ;-----------------------------------------------------------------------------
(0211) ;  FUNCTION NAME: DELSIG11_1_fIsDataAvailable
(0212) ;
(0213) ;  DESCRIPTION: Returns the status of the A/D Data
(0214) ;-----------------------------------------------------------------------------
(0215) ;  ARGUMENTS:    None.
(0216) ;  RETURNS:      fastcall16 BOOL DataAvailable returned in the A register
(0217) ;  SIDE EFFECTS:
(0218) ;    The A and X registers may be modified by this or future implementations
(0219) ;    of this function.  The same is true for all RAM page pointer registers in
(0220) ;    the Large Memory Model.  When necessary, it is the calling function's
(0221) ;    responsibility to perserve their values across calls to fastcall16 
(0222) ;    functions.
(0223) ;          
(0224) ;    Currently only the page pointer registers listed below are modified:
(0225) ;          CUR_PP
(0226) ;
(0227)  DELSIG11_1_fIsDataAvailable:
(0228) _DELSIG11_1_fIsDataAvailable:
(0229)    RAM_PROLOGUE   RAM_USE_CLASS_4
(0230)    RAM_SETPAGE_CUR >DELSIG11_1_bfStatus
    0872: 62 D0 00 MOV   REG[208],0
(0231)    mov  A, [DELSIG11_1_bfStatus]
    0875: 51 0E    MOV   A,[14]
(0232)    RAM_EPILOGUE  RAM_USE_CLASS_4
(0233)    ret
    0877: 7F       RET   
(0234) .ENDSECTION
(0235) 
(0236) 
(0237) .SECTION
(0238) ;-----------------------------------------------------------------------------
(0239) ;  FUNCTION NAME:  DELSIG11_1_iGetDataClearFlag
(0240) ;
(0241) ;  DESCRIPTION:    Returns the data from the A/D.  Does not check if data is
(0242) ;                  available. Also clears the DATA_READY flag.
(0243) ;-----------------------------------------------------------------------------
(0244) ;  ARGUMENTS:    None.
(0245) ;  RETURNS:      fastcall16 INT iData (LSB in A, MSB in X)
(0246) ;  SIDE EFFECTS:
(0247) ;    The A and X registers may be modified by this or future implementations
(0248) ;    of this function.  The same is true for all RAM page pointer registers in
(0249) ;    the Large Memory Model.  When necessary, it is the calling function's
(0250) ;    responsibility to perserve their values across calls to fastcall16 
(0251) ;    functions.
(0252) ;          
(0253) ;    Currently only the page pointer registers listed below are modified:
(0254) ;          CUR_PP
(0255) ;
(0256) ;    Timer interrupts are momentarily halted and restarted to
(0257) ;    ensure data integrity.
(0258) ;
(0259)  DELSIG11_1_iGetDataClearFlag:
(0260) _DELSIG11_1_iGetDataClearFlag:
(0261)    RAM_PROLOGUE   RAM_USE_CLASS_4
(0262)    RAM_SETPAGE_CUR >DELSIG11_1_bfStatus
    0878: 62 D0 00 MOV   REG[208],0
(0263)    and  [DELSIG11_1_bfStatus], ~DELSIG11_1_DATA_READY_BIT
    087B: 26 0E EF AND   [14],239
(0264)    M8C_DisableIntMask DELSIG11_1_INT_REG, DELSIG11_1_INT_MASK         ; Disable its interrupt
    087E: 41 E1 EF AND   REG[225],239
(0265)    mov  X, [DELSIG11_1_iResult + HIGHBYTE]
    0881: 58 0C    MOV   X,[12]
(0266)    mov  A, [DELSIG11_1_iResult + LOWBYTE]
    0883: 51 0D    MOV   A,[13]
(0267)    M8C_EnableIntMask DELSIG11_1_INT_REG, DELSIG11_1_INT_MASK          ; Enable timer interrupt
    0885: 43 E1 10 OR    REG[225],16
(0268)    RAM_EPILOGUE  RAM_USE_CLASS_4
(0269)    ret
    0888: 7F       RET   
(0270) .ENDSECTION
(0271) 
(0272) 
(0273) .SECTION
(0274) ;-----------------------------------------------------------------------------
(0275) ;  FUNCTION NAME:  DELSIG11_1_iGetData:
(0276) ;
(0277) ;  DESCRIPTION:     Returns the data from the A/D.  Does not check if data is
(0278) ;                   available.
(0279) ;-----------------------------------------------------------------------------
(0280) ;  ARGUMENTS:    None.
(0281) ;  RETURNS:      fastcall16 INT iData (LSB in A, MSB in X)
(0282) ;  SIDE EFFECTS:
(0283) ;    The A and X registers may be modified by this or future implementations
(0284) ;    of this function.  The same is true for all RAM page pointer registers in
(0285) ;    the Large Memory Model.  When necessary, it is the calling function's
(0286) ;    responsibility to perserve their values across calls to fastcall16 
(0287) ;    functions.
(0288) ;          
(0289) ;    Currently only the page pointer registers listed below are modified:
(0290) ;          CUR_PP
(0291) ;
(0292) ;    Timer interrupts are momentarily halted and restarted to
(0293) ;    ensure data integrity.
(0294) ;
(0295)  DELSIG11_1_iGetData:
(0296) _DELSIG11_1_iGetData:
(0297)    RAM_PROLOGUE   RAM_USE_CLASS_4
(0298)    RAM_SETPAGE_CUR >DELSIG11_1_iResult
    0889: 62 D0 00 MOV   REG[208],0
(0299)    M8C_DisableIntMask DELSIG11_1_INT_REG, DELSIG11_1_INT_MASK         ; Disable its interrupt
    088C: 41 E1 EF AND   REG[225],239
(0300)    mov  X, [DELSIG11_1_iResult + HIGHBYTE]
    088F: 58 0C    MOV   X,[12]
(0301)    mov  A, [DELSIG11_1_iResult + LOWBYTE]
    0891: 51 0D    MOV   A,[13]
(0302)    M8C_EnableIntMask DELSIG11_1_INT_REG, DELSIG11_1_INT_MASK          ; Enable timer interrupt
    0893: 43 E1 10 OR    REG[225],16
(0303)    RAM_EPILOGUE  RAM_USE_CLASS_4
(0304)    ret
    0896: 7F       RET   
(0305) .ENDSECTION
(0306) 
(0307) 
(0308) .SECTION
(0309) ;-----------------------------------------------------------------------------
(0310) ;  FUNCTION NAME: DELSIG11_1_ClearFlag
(0311) ;
(0312) ;  DESCRIPTION: Clears the data ready flag.
(0313) ;-----------------------------------------------------------------------------
(0314) ;  ARGUMENTS:    None.
(0315) ;  RETURNS:      Nothing.
(0316) ;  SIDE EFFECTS:
(0317) ;    The A and X registers may be modified by this or future implementations
(0318) ;    of this function.  The same is true for all RAM page pointer registers in
(0319) ;    the Large Memory Model.  When necessary, it is the calling function's
(0320) ;    responsibility to perserve their values across calls to fastcall16 
(0321) ;    functions.
(0322) ;          
(0323) ;    Currently only the page pointer registers listed below are modified:
(0324) ;          CUR_PP
(0325) ;
(0326)  DELSIG11_1_ClearFlag:
(0327) _DELSIG11_1_ClearFlag:
(0328)    RAM_PROLOGUE   RAM_USE_CLASS_4
(0329)    RAM_SETPAGE_CUR >DELSIG11_1_bfStatus
    0897: 62 D0 00 MOV   REG[208],0
(0330)    and  [DELSIG11_1_bfStatus], ~DELSIG11_1_DATA_READY_BIT
    089A: 26 0E EF AND   [14],239
(0331)    RAM_EPILOGUE  RAM_USE_CLASS_4
(0332)    ret
    089D: 7F       RET   
FILE: .\fft.h
(0001) #include "math.h"				 //mathematical library
(0002) 
(0003) // FFT parameters
(0004) #define N_points 64              //number of points				
(0005) #define exponent log(64)/log(2)  //log2(N_points); for N_points=64 -> exponent=6
(0006) 
(0007) // FFT variables
(0008) double mod[N_points]={0};        //arrays
(0009) double data_re[N_points]={0};
(0010) double data_imm[N_points]={0};
(0011) 
(0012) // FFT function
(0013) short FFT(int dir,long m,double *x,double *y)
(0014) {
_FFT:
  ty                   --> X+68
  tx                   --> X+64
  i2                   --> X+60
  l                    --> X+56
  z                    --> X+52
  c2                   --> X+48
  c1                   --> X+44
  k                    --> X+40
  j                    --> X+36
  l2                   --> X+32
  n                    --> X+28
  l1                   --> X+24
  u2                   --> X+20
  u1                   --> X+16
  t2                   --> X+12
  t1                   --> X+8
  i1                   --> X+4
  i                    --> X+0
  y                    --> X-13
  x                    --> X-11
  m                    --> X-9
  dir                  --> X-5
__text_start:
    089E: 10       PUSH  X
    089F: 4F       MOV   X,SP
    08A0: 38 4A    ADD   SP,74
(0015)    // dir:  forward (=1) o inverse (!=1) transform; 
(0016)    // m exponent;
(0017)    
(0018)    long n,i,i1,j,k,i2,l,l1,l2;
(0019)    double c1,c2,tx,ty,t1,t2,u1,u2,z;
(0020) 
(0021)    /* Calculate the number of points */
(0022)    n = 1;
    08A2: 56 1C 00 MOV   [X+28],0
    08A5: 56 1D 00 MOV   [X+29],0
    08A8: 56 1E 00 MOV   [X+30],0
    08AB: 56 1F 01 MOV   [X+31],1
(0023)    for (i=0;i<m;i++) 
    08AE: 56 00 00 MOV   [X+0],0
    08B1: 56 01 00 MOV   [X+1],0
    08B4: 56 02 00 MOV   [X+2],0
    08B7: 56 03 00 MOV   [X+3],0
    08BA: 80 15    JMP   0x08D0
(0024)       n *= 2;
    08BC: 66 1F    ASL   [X+31]
    08BE: 6C 1E    RLC   [X+30]
    08C0: 6C 1D    RLC   [X+29]
    08C2: 6C 1C    RLC   [X+28]
    08C4: 07 03 01 ADD   [X+3],1
    08C7: 0F 02 00 ADC   [X+2],0
    08CA: 0F 01 00 ADC   [X+1],0
    08CD: 0F 00 00 ADC   [X+0],0
    08D0: 52 03    MOV   A,[X+3]
    08D2: 13 FA    SUB   A,[X-6]
    08D4: 52 02    MOV   A,[X+2]
    08D6: 1B F9    SBB   A,[X-7]
    08D8: 52 01    MOV   A,[X+1]
    08DA: 1B F8    SBB   A,[X-8]
    08DC: 52 F7    MOV   A,[X-9]
    08DE: 31 80    XOR   A,128
    08E0: 62 D0 00 MOV   REG[208],0
    08E3: 53 0F    MOV   [__rX],A
    08E5: 52 00    MOV   A,[X+0]
    08E7: 31 80    XOR   A,128
    08E9: 1A 0F    SBB   A,[__rX]
    08EB: CF D0    JC    0x08BC
(0025) 
(0026)    /* Do the bit reversal */
(0027)    i2 = n >> 1;
    08ED: 62 D0 00 MOV   REG[208],0
    08F0: 52 1C    MOV   A,[X+28]
    08F2: 53 1B    MOV   [__r0],A
    08F4: 52 1D    MOV   A,[X+29]
    08F6: 53 1A    MOV   [__r1],A
    08F8: 52 1E    MOV   A,[X+30]
    08FA: 53 19    MOV   [__r2],A
    08FC: 52 1F    MOV   A,[X+31]
    08FE: 53 18    MOV   [__r3],A
    0900: 68 1B    ASR   [__r0]
    0902: 6E 1A    RRC   [__r1]
    0904: 6E 19    RRC   [__r2]
    0906: 6E 18    RRC   [__r3]
    0908: 51 1B    MOV   A,[__r0]
    090A: 54 3C    MOV   [X+60],A
    090C: 51 1A    MOV   A,[__r1]
    090E: 54 3D    MOV   [X+61],A
    0910: 51 19    MOV   A,[__r2]
    0912: 54 3E    MOV   [X+62],A
    0914: 51 18    MOV   A,[__r3]
    0916: 54 3F    MOV   [X+63],A
(0028)    j = 0;
    0918: 56 24 00 MOV   [X+36],0
    091B: 56 25 00 MOV   [X+37],0
    091E: 56 26 00 MOV   [X+38],0
    0921: 56 27 00 MOV   [X+39],0
(0029)    for (i=0;i<n-1;i++) {
    0924: 56 00 00 MOV   [X+0],0
    0927: 56 01 00 MOV   [X+1],0
    092A: 56 02 00 MOV   [X+2],0
    092D: 56 03 00 MOV   [X+3],0
    0930: 82 A4    JMP   0x0BD5
(0030)       if (i < j) {
    0932: 52 03    MOV   A,[X+3]
    0934: 13 27    SUB   A,[X+39]
    0936: 52 02    MOV   A,[X+2]
    0938: 1B 26    SBB   A,[X+38]
    093A: 52 01    MOV   A,[X+1]
    093C: 1B 25    SBB   A,[X+37]
    093E: 52 24    MOV   A,[X+36]
    0940: 31 80    XOR   A,128
    0942: 62 D0 00 MOV   REG[208],0
    0945: 53 0F    MOV   [__rX],A
    0947: 52 00    MOV   A,[X+0]
    0949: 31 80    XOR   A,128
    094B: 1A 0F    SBB   A,[__rX]
    094D: D2 24    JNC   0x0B72
(0031)          tx = x[i];
    094F: 62 D0 00 MOV   REG[208],0
    0952: 52 00    MOV   A,[X+0]
    0954: 53 1B    MOV   [__r0],A
    0956: 52 01    MOV   A,[X+1]
    0958: 53 1A    MOV   [__r1],A
    095A: 52 02    MOV   A,[X+2]
    095C: 53 19    MOV   [__r2],A
    095E: 52 03    MOV   A,[X+3]
    0960: 53 18    MOV   [__r3],A
    0962: 50 02    MOV   A,2
    0964: 62 D0 00 MOV   REG[208],0
    0967: 65 18    ASL   [__r3]
    0969: 6B 19    RLC   [__r2]
    096B: 6B 1A    RLC   [__r1]
    096D: 6B 1B    RLC   [__r0]
    096F: 78       DEC   A
    0970: BF F3    JNZ   0x0964
    0972: 51 18    MOV   A,[__r3]
    0974: 53 1A    MOV   [__r1],A
    0976: 51 19    MOV   A,[__r2]
    0978: 53 1B    MOV   [__r0],A
    097A: 52 F6    MOV   A,[X-10]
    097C: 04 1A    ADD   [__r1],A
    097E: 52 F5    MOV   A,[X-11]
    0980: 0C 1B    ADC   [__r0],A
    0982: 51 1B    MOV   A,[__r0]
    0984: 60 D4    MOV   REG[212],A
    0986: 3E 1A    MVI   A,[__r1]
    0988: 54 40    MOV   [X+64],A
    098A: 3E 1A    MVI   A,[__r1]
    098C: 54 41    MOV   [X+65],A
    098E: 3E 1A    MVI   A,[__r1]
    0990: 54 42    MOV   [X+66],A
    0992: 3E 1A    MVI   A,[__r1]
    0994: 54 43    MOV   [X+67],A
(0032)          ty = y[i];
    0996: 52 00    MOV   A,[X+0]
    0998: 53 1B    MOV   [__r0],A
    099A: 52 01    MOV   A,[X+1]
    099C: 53 1A    MOV   [__r1],A
    099E: 52 02    MOV   A,[X+2]
    09A0: 53 19    MOV   [__r2],A
    09A2: 52 03    MOV   A,[X+3]
    09A4: 53 18    MOV   [__r3],A
    09A6: 50 02    MOV   A,2
    09A8: 62 D0 00 MOV   REG[208],0
    09AB: 65 18    ASL   [__r3]
    09AD: 6B 19    RLC   [__r2]
    09AF: 6B 1A    RLC   [__r1]
    09B1: 6B 1B    RLC   [__r0]
    09B3: 78       DEC   A
    09B4: BF F3    JNZ   0x09A8
    09B6: 51 18    MOV   A,[__r3]
    09B8: 53 1A    MOV   [__r1],A
    09BA: 51 19    MOV   A,[__r2]
    09BC: 53 1B    MOV   [__r0],A
    09BE: 52 F4    MOV   A,[X-12]
    09C0: 04 1A    ADD   [__r1],A
    09C2: 52 F3    MOV   A,[X-13]
    09C4: 0C 1B    ADC   [__r0],A
    09C6: 51 1B    MOV   A,[__r0]
    09C8: 60 D4    MOV   REG[212],A
    09CA: 3E 1A    MVI   A,[__r1]
    09CC: 54 44    MOV   [X+68],A
    09CE: 3E 1A    MVI   A,[__r1]
    09D0: 54 45    MOV   [X+69],A
    09D2: 3E 1A    MVI   A,[__r1]
    09D4: 54 46    MOV   [X+70],A
    09D6: 3E 1A    MVI   A,[__r1]
    09D8: 54 47    MOV   [X+71],A
(0033)          x[i] = x[j];
    09DA: 52 24    MOV   A,[X+36]
    09DC: 53 1B    MOV   [__r0],A
    09DE: 52 25    MOV   A,[X+37]
    09E0: 53 1A    MOV   [__r1],A
    09E2: 52 26    MOV   A,[X+38]
    09E4: 53 19    MOV   [__r2],A
    09E6: 52 27    MOV   A,[X+39]
    09E8: 53 18    MOV   [__r3],A
    09EA: 50 02    MOV   A,2
    09EC: 62 D0 00 MOV   REG[208],0
    09EF: 65 18    ASL   [__r3]
    09F1: 6B 19    RLC   [__r2]
    09F3: 6B 1A    RLC   [__r1]
    09F5: 6B 1B    RLC   [__r0]
    09F7: 78       DEC   A
    09F8: BF F3    JNZ   0x09EC
    09FA: 51 18    MOV   A,[__r3]
    09FC: 53 1A    MOV   [__r1],A
    09FE: 51 19    MOV   A,[__r2]
    0A00: 53 1B    MOV   [__r0],A
    0A02: 52 F6    MOV   A,[X-10]
    0A04: 04 1A    ADD   [__r1],A
    0A06: 52 F5    MOV   A,[X-11]
    0A08: 0C 1B    ADC   [__r0],A
    0A0A: 51 1B    MOV   A,[__r0]
    0A0C: 60 D4    MOV   REG[212],A
    0A0E: 3E 1A    MVI   A,[__r1]
    0A10: 53 17    MOV   [__r4],A
    0A12: 3E 1A    MVI   A,[__r1]
    0A14: 53 16    MOV   [__r5],A
    0A16: 3E 1A    MVI   A,[__r1]
    0A18: 53 15    MOV   [__r6],A
    0A1A: 3E 1A    MVI   A,[__r1]
    0A1C: 53 14    MOV   [__r7],A
    0A1E: 52 00    MOV   A,[X+0]
    0A20: 53 1B    MOV   [__r0],A
    0A22: 52 01    MOV   A,[X+1]
    0A24: 53 1A    MOV   [__r1],A
    0A26: 52 02    MOV   A,[X+2]
    0A28: 53 19    MOV   [__r2],A
    0A2A: 52 03    MOV   A,[X+3]
    0A2C: 53 18    MOV   [__r3],A
    0A2E: 50 02    MOV   A,2
    0A30: 62 D0 00 MOV   REG[208],0
    0A33: 65 18    ASL   [__r3]
    0A35: 6B 19    RLC   [__r2]
    0A37: 6B 1A    RLC   [__r1]
    0A39: 6B 1B    RLC   [__r0]
    0A3B: 78       DEC   A
    0A3C: BF F3    JNZ   0x0A30
    0A3E: 51 18    MOV   A,[__r3]
    0A40: 53 1A    MOV   [__r1],A
    0A42: 51 19    MOV   A,[__r2]
    0A44: 53 1B    MOV   [__r0],A
    0A46: 52 F6    MOV   A,[X-10]
    0A48: 04 1A    ADD   [__r1],A
    0A4A: 52 F5    MOV   A,[X-11]
    0A4C: 0C 1B    ADC   [__r0],A
    0A4E: 51 1B    MOV   A,[__r0]
    0A50: 60 D5    MOV   REG[213],A
    0A52: 51 17    MOV   A,[__r4]
    0A54: 3F 1A    MVI   [__r1],A
    0A56: 51 16    MOV   A,[__r5]
    0A58: 3F 1A    MVI   [__r1],A
    0A5A: 51 15    MOV   A,[__r6]
    0A5C: 3F 1A    MVI   [__r1],A
    0A5E: 51 14    MOV   A,[__r7]
    0A60: 3F 1A    MVI   [__r1],A
(0034)          y[i] = y[j];
    0A62: 52 24    MOV   A,[X+36]
    0A64: 53 1B    MOV   [__r0],A
    0A66: 52 25    MOV   A,[X+37]
    0A68: 53 1A    MOV   [__r1],A
    0A6A: 52 26    MOV   A,[X+38]
    0A6C: 53 19    MOV   [__r2],A
    0A6E: 52 27    MOV   A,[X+39]
    0A70: 53 18    MOV   [__r3],A
    0A72: 50 02    MOV   A,2
    0A74: 62 D0 00 MOV   REG[208],0
    0A77: 65 18    ASL   [__r3]
    0A79: 6B 19    RLC   [__r2]
    0A7B: 6B 1A    RLC   [__r1]
    0A7D: 6B 1B    RLC   [__r0]
    0A7F: 78       DEC   A
    0A80: BF F3    JNZ   0x0A74
    0A82: 51 18    MOV   A,[__r3]
    0A84: 53 1A    MOV   [__r1],A
    0A86: 51 19    MOV   A,[__r2]
    0A88: 53 1B    MOV   [__r0],A
    0A8A: 52 F4    MOV   A,[X-12]
    0A8C: 04 1A    ADD   [__r1],A
    0A8E: 52 F3    MOV   A,[X-13]
    0A90: 0C 1B    ADC   [__r0],A
    0A92: 51 1B    MOV   A,[__r0]
    0A94: 60 D4    MOV   REG[212],A
    0A96: 3E 1A    MVI   A,[__r1]
    0A98: 53 17    MOV   [__r4],A
    0A9A: 3E 1A    MVI   A,[__r1]
    0A9C: 53 16    MOV   [__r5],A
    0A9E: 3E 1A    MVI   A,[__r1]
    0AA0: 53 15    MOV   [__r6],A
    0AA2: 3E 1A    MVI   A,[__r1]
    0AA4: 53 14    MOV   [__r7],A
    0AA6: 52 00    MOV   A,[X+0]
    0AA8: 53 1B    MOV   [__r0],A
    0AAA: 52 01    MOV   A,[X+1]
    0AAC: 53 1A    MOV   [__r1],A
    0AAE: 52 02    MOV   A,[X+2]
    0AB0: 53 19    MOV   [__r2],A
    0AB2: 52 03    MOV   A,[X+3]
    0AB4: 53 18    MOV   [__r3],A
    0AB6: 50 02    MOV   A,2
    0AB8: 62 D0 00 MOV   REG[208],0
    0ABB: 65 18    ASL   [__r3]
    0ABD: 6B 19    RLC   [__r2]
    0ABF: 6B 1A    RLC   [__r1]
    0AC1: 6B 1B    RLC   [__r0]
    0AC3: 78       DEC   A
    0AC4: BF F3    JNZ   0x0AB8
    0AC6: 51 18    MOV   A,[__r3]
    0AC8: 53 1A    MOV   [__r1],A
    0ACA: 51 19    MOV   A,[__r2]
    0ACC: 53 1B    MOV   [__r0],A
    0ACE: 52 F4    MOV   A,[X-12]
    0AD0: 04 1A    ADD   [__r1],A
    0AD2: 52 F3    MOV   A,[X-13]
    0AD4: 0C 1B    ADC   [__r0],A
    0AD6: 51 1B    MOV   A,[__r0]
    0AD8: 60 D5    MOV   REG[213],A
    0ADA: 51 17    MOV   A,[__r4]
    0ADC: 3F 1A    MVI   [__r1],A
    0ADE: 51 16    MOV   A,[__r5]
    0AE0: 3F 1A    MVI   [__r1],A
    0AE2: 51 15    MOV   A,[__r6]
    0AE4: 3F 1A    MVI   [__r1],A
    0AE6: 51 14    MOV   A,[__r7]
    0AE8: 3F 1A    MVI   [__r1],A
(0035)          x[j] = tx;
    0AEA: 52 24    MOV   A,[X+36]
    0AEC: 53 1B    MOV   [__r0],A
    0AEE: 52 25    MOV   A,[X+37]
    0AF0: 53 1A    MOV   [__r1],A
    0AF2: 52 26    MOV   A,[X+38]
    0AF4: 53 19    MOV   [__r2],A
    0AF6: 52 27    MOV   A,[X+39]
    0AF8: 53 18    MOV   [__r3],A
    0AFA: 50 02    MOV   A,2
    0AFC: 62 D0 00 MOV   REG[208],0
    0AFF: 65 18    ASL   [__r3]
    0B01: 6B 19    RLC   [__r2]
    0B03: 6B 1A    RLC   [__r1]
    0B05: 6B 1B    RLC   [__r0]
    0B07: 78       DEC   A
    0B08: BF F3    JNZ   0x0AFC
    0B0A: 51 18    MOV   A,[__r3]
    0B0C: 53 1A    MOV   [__r1],A
    0B0E: 51 19    MOV   A,[__r2]
    0B10: 53 1B    MOV   [__r0],A
    0B12: 52 F6    MOV   A,[X-10]
    0B14: 04 1A    ADD   [__r1],A
    0B16: 52 F5    MOV   A,[X-11]
    0B18: 0C 1B    ADC   [__r0],A
    0B1A: 51 1B    MOV   A,[__r0]
    0B1C: 60 D5    MOV   REG[213],A
    0B1E: 52 40    MOV   A,[X+64]
    0B20: 3F 1A    MVI   [__r1],A
    0B22: 52 41    MOV   A,[X+65]
    0B24: 3F 1A    MVI   [__r1],A
    0B26: 52 42    MOV   A,[X+66]
    0B28: 3F 1A    MVI   [__r1],A
    0B2A: 52 43    MOV   A,[X+67]
    0B2C: 3F 1A    MVI   [__r1],A
(0036)          y[j] = ty;
    0B2E: 52 24    MOV   A,[X+36]
    0B30: 53 1B    MOV   [__r0],A
    0B32: 52 25    MOV   A,[X+37]
    0B34: 53 1A    MOV   [__r1],A
    0B36: 52 26    MOV   A,[X+38]
    0B38: 53 19    MOV   [__r2],A
    0B3A: 52 27    MOV   A,[X+39]
    0B3C: 53 18    MOV   [__r3],A
    0B3E: 50 02    MOV   A,2
    0B40: 62 D0 00 MOV   REG[208],0
    0B43: 65 18    ASL   [__r3]
    0B45: 6B 19    RLC   [__r2]
    0B47: 6B 1A    RLC   [__r1]
    0B49: 6B 1B    RLC   [__r0]
    0B4B: 78       DEC   A
    0B4C: BF F3    JNZ   0x0B40
    0B4E: 51 18    MOV   A,[__r3]
    0B50: 53 1A    MOV   [__r1],A
    0B52: 51 19    MOV   A,[__r2]
    0B54: 53 1B    MOV   [__r0],A
    0B56: 52 F4    MOV   A,[X-12]
    0B58: 04 1A    ADD   [__r1],A
    0B5A: 52 F3    MOV   A,[X-13]
    0B5C: 0C 1B    ADC   [__r0],A
    0B5E: 51 1B    MOV   A,[__r0]
    0B60: 60 D5    MOV   REG[213],A
    0B62: 52 44    MOV   A,[X+68]
    0B64: 3F 1A    MVI   [__r1],A
    0B66: 52 45    MOV   A,[X+69]
    0B68: 3F 1A    MVI   [__r1],A
    0B6A: 52 46    MOV   A,[X+70]
    0B6C: 3F 1A    MVI   [__r1],A
    0B6E: 52 47    MOV   A,[X+71]
    0B70: 3F 1A    MVI   [__r1],A
(0037)       }
(0038)       k = i2;
    0B72: 52 3C    MOV   A,[X+60]
    0B74: 54 28    MOV   [X+40],A
    0B76: 52 3D    MOV   A,[X+61]
    0B78: 54 29    MOV   [X+41],A
    0B7A: 52 3E    MOV   A,[X+62]
    0B7C: 54 2A    MOV   [X+42],A
    0B7E: 52 3F    MOV   A,[X+63]
    0B80: 54 2B    MOV   [X+43],A
    0B82: 80 19    JMP   0x0B9C
(0039)       while (k <= j) {
(0040)          j -= k;
    0B84: 52 2B    MOV   A,[X+43]
    0B86: 15 27    SUB   [X+39],A
    0B88: 52 2A    MOV   A,[X+42]
    0B8A: 1D 26    SBB   [X+38],A
    0B8C: 52 29    MOV   A,[X+41]
    0B8E: 1D 25    SBB   [X+37],A
    0B90: 52 28    MOV   A,[X+40]
    0B92: 1D 24    SBB   [X+36],A
(0041)          k >>= 1;
    0B94: 69 28    ASR   [X+40]
    0B96: 6F 29    RRC   [X+41]
    0B98: 6F 2A    RRC   [X+42]
    0B9A: 6F 2B    RRC   [X+43]
    0B9C: 52 27    MOV   A,[X+39]
    0B9E: 13 2B    SUB   A,[X+43]
    0BA0: 52 26    MOV   A,[X+38]
    0BA2: 1B 2A    SBB   A,[X+42]
    0BA4: 52 25    MOV   A,[X+37]
    0BA6: 1B 29    SBB   A,[X+41]
    0BA8: 52 28    MOV   A,[X+40]
    0BAA: 31 80    XOR   A,128
    0BAC: 62 D0 00 MOV   REG[208],0
    0BAF: 53 0F    MOV   [__rX],A
    0BB1: 52 24    MOV   A,[X+36]
    0BB3: 31 80    XOR   A,128
    0BB5: 1A 0F    SBB   A,[__rX]
    0BB7: DF CC    JNC   0x0B84
(0042)       }
(0043)       j += k;
    0BB9: 52 2B    MOV   A,[X+43]
    0BBB: 05 27    ADD   [X+39],A
    0BBD: 52 2A    MOV   A,[X+42]
    0BBF: 0D 26    ADC   [X+38],A
    0BC1: 52 29    MOV   A,[X+41]
    0BC3: 0D 25    ADC   [X+37],A
    0BC5: 52 28    MOV   A,[X+40]
    0BC7: 0D 24    ADC   [X+36],A
    0BC9: 07 03 01 ADD   [X+3],1
    0BCC: 0F 02 00 ADC   [X+2],0
    0BCF: 0F 01 00 ADC   [X+1],0
    0BD2: 0F 00 00 ADC   [X+0],0
    0BD5: 62 D0 00 MOV   REG[208],0
    0BD8: 52 1F    MOV   A,[X+31]
    0BDA: 11 01    SUB   A,1
    0BDC: 53 18    MOV   [__r3],A
    0BDE: 52 1E    MOV   A,[X+30]
    0BE0: 19 00    SBB   A,0
    0BE2: 53 19    MOV   [__r2],A
    0BE4: 52 1D    MOV   A,[X+29]
    0BE6: 19 00    SBB   A,0
    0BE8: 53 1A    MOV   [__r1],A
    0BEA: 52 1C    MOV   A,[X+28]
    0BEC: 19 00    SBB   A,0
    0BEE: 53 1B    MOV   [__r0],A
    0BF0: 52 03    MOV   A,[X+3]
    0BF2: 12 18    SUB   A,[__r3]
    0BF4: 52 02    MOV   A,[X+2]
    0BF6: 1A 19    SBB   A,[__r2]
    0BF8: 52 01    MOV   A,[X+1]
    0BFA: 1A 1A    SBB   A,[__r1]
    0BFC: 51 1B    MOV   A,[__r0]
    0BFE: 31 80    XOR   A,128
    0C00: 53 0F    MOV   [__rX],A
    0C02: 52 00    MOV   A,[X+0]
    0C04: 31 80    XOR   A,128
    0C06: 1A 0F    SBB   A,[__rX]
    0C08: CD 29    JC    0x0932
(0044)    }
(0045) 
(0046)    /* Compute the FFT */
(0047)    c1 = -1.0; 
    0C0A: 56 2C BF MOV   [X+44],191
    0C0D: 56 2D 80 MOV   [X+45],128
    0C10: 56 2E 00 MOV   [X+46],0
    0C13: 56 2F 00 MOV   [X+47],0
(0048)    c2 = 0.0;
    0C16: 56 30 00 MOV   [X+48],0
    0C19: 56 31 00 MOV   [X+49],0
    0C1C: 56 32 00 MOV   [X+50],0
    0C1F: 56 33 00 MOV   [X+51],0
(0049)    l2 = 1;
    0C22: 56 20 00 MOV   [X+32],0
    0C25: 56 21 00 MOV   [X+33],0
    0C28: 56 22 00 MOV   [X+34],0
    0C2B: 56 23 01 MOV   [X+35],1
(0050)    for (l=0;l<m;l++) {
    0C2E: 56 38 00 MOV   [X+56],0
    0C31: 56 39 00 MOV   [X+57],0
    0C34: 56 3A 00 MOV   [X+58],0
    0C37: 56 3B 00 MOV   [X+59],0
    0C3A: 86 E2    JMP   0x131D
(0051)       l1 = l2;
    0C3C: 52 20    MOV   A,[X+32]
    0C3E: 54 18    MOV   [X+24],A
    0C40: 52 21    MOV   A,[X+33]
    0C42: 54 19    MOV   [X+25],A
    0C44: 52 22    MOV   A,[X+34]
    0C46: 54 1A    MOV   [X+26],A
    0C48: 52 23    MOV   A,[X+35]
    0C4A: 54 1B    MOV   [X+27],A
(0052)       l2 <<= 1;
    0C4C: 66 23    ASL   [X+35]
    0C4E: 6C 22    RLC   [X+34]
    0C50: 6C 21    RLC   [X+33]
    0C52: 6C 20    RLC   [X+32]
(0053)       u1 = 1.0; 
    0C54: 56 10 3F MOV   [X+16],63
    0C57: 56 11 80 MOV   [X+17],128
    0C5A: 56 12 00 MOV   [X+18],0
    0C5D: 56 13 00 MOV   [X+19],0
(0054)       u2 = 0.0;
    0C60: 56 14 00 MOV   [X+20],0
    0C63: 56 15 00 MOV   [X+21],0
    0C66: 56 16 00 MOV   [X+22],0
    0C69: 56 17 00 MOV   [X+23],0
(0055)       for (j=0;j<l1;j++) {
    0C6C: 56 24 00 MOV   [X+36],0
    0C6F: 56 25 00 MOV   [X+37],0
    0C72: 56 26 00 MOV   [X+38],0
    0C75: 56 27 00 MOV   [X+39],0
    0C78: 85 90    JMP   0x1209
(0056)          for (i=j;i<n;i+=l2) {
    0C7A: 52 24    MOV   A,[X+36]
    0C7C: 54 00    MOV   [X+0],A
    0C7E: 52 25    MOV   A,[X+37]
    0C80: 54 01    MOV   [X+1],A
    0C82: 52 26    MOV   A,[X+38]
    0C84: 54 02    MOV   [X+2],A
    0C86: 52 27    MOV   A,[X+39]
    0C88: 54 03    MOV   [X+3],A
    0C8A: 84 4C    JMP   0x10D7
(0057)             i1 = i + l1;
    0C8C: 52 03    MOV   A,[X+3]
    0C8E: 03 1B    ADD   A,[X+27]
    0C90: 54 07    MOV   [X+7],A
    0C92: 52 02    MOV   A,[X+2]
    0C94: 0B 1A    ADC   A,[X+26]
    0C96: 54 06    MOV   [X+6],A
    0C98: 52 01    MOV   A,[X+1]
    0C9A: 0B 19    ADC   A,[X+25]
    0C9C: 54 05    MOV   [X+5],A
    0C9E: 52 00    MOV   A,[X+0]
    0CA0: 0B 18    ADC   A,[X+24]
    0CA2: 54 04    MOV   [X+4],A
(0058)             t1 = u1 * x[i1] - u2 * y[i1];
    0CA4: 62 D0 00 MOV   REG[208],0
    0CA7: 52 04    MOV   A,[X+4]
    0CA9: 53 1B    MOV   [__r0],A
    0CAB: 52 05    MOV   A,[X+5]
    0CAD: 53 1A    MOV   [__r1],A
    0CAF: 52 06    MOV   A,[X+6]
    0CB1: 53 19    MOV   [__r2],A
    0CB3: 52 07    MOV   A,[X+7]
    0CB5: 53 18    MOV   [__r3],A
    0CB7: 50 02    MOV   A,2
    0CB9: 62 D0 00 MOV   REG[208],0
    0CBC: 65 18    ASL   [__r3]
    0CBE: 6B 19    RLC   [__r2]
    0CC0: 6B 1A    RLC   [__r1]
    0CC2: 6B 1B    RLC   [__r0]
    0CC4: 78       DEC   A
    0CC5: BF F3    JNZ   0x0CB9
    0CC7: 51 18    MOV   A,[__r3]
    0CC9: 53 1A    MOV   [__r1],A
    0CCB: 51 19    MOV   A,[__r2]
    0CCD: 53 1B    MOV   [__r0],A
    0CCF: 51 1A    MOV   A,[__r1]
    0CD1: 03 F4    ADD   A,[X-12]
    0CD3: 53 18    MOV   [__r3],A
    0CD5: 51 1B    MOV   A,[__r0]
    0CD7: 0B F3    ADC   A,[X-13]
    0CD9: 60 D4    MOV   REG[212],A
    0CDB: 3E 18    MVI   A,[__r3]
    0CDD: 53 17    MOV   [__r4],A
    0CDF: 3E 18    MVI   A,[__r3]
    0CE1: 53 16    MOV   [__r5],A
    0CE3: 3E 18    MVI   A,[__r3]
    0CE5: 53 15    MOV   [__r6],A
    0CE7: 3E 18    MVI   A,[__r3]
    0CE9: 53 14    MOV   [__r7],A
    0CEB: 51 17    MOV   A,[__r4]
    0CED: 08       PUSH  A
    0CEE: 51 16    MOV   A,[__r5]
    0CF0: 08       PUSH  A
    0CF1: 51 15    MOV   A,[__r6]
    0CF3: 08       PUSH  A
    0CF4: 51 14    MOV   A,[__r7]
    0CF6: 08       PUSH  A
    0CF7: 52 14    MOV   A,[X+20]
    0CF9: 08       PUSH  A
    0CFA: 52 15    MOV   A,[X+21]
    0CFC: 08       PUSH  A
    0CFD: 52 16    MOV   A,[X+22]
    0CFF: 08       PUSH  A
    0D00: 52 17    MOV   A,[X+23]
    0D02: 08       PUSH  A
    0D03: 7C 21 9A LCALL __fpmul
    0D06: 18       POP   A
    0D07: 53 14    MOV   [__r7],A
    0D09: 18       POP   A
    0D0A: 53 15    MOV   [__r6],A
    0D0C: 18       POP   A
    0D0D: 53 16    MOV   [__r5],A
    0D0F: 18       POP   A
    0D10: 53 17    MOV   [__r4],A
    0D12: 38 FC    ADD   SP,252
    0D14: 52 F6    MOV   A,[X-10]
    0D16: 04 1A    ADD   [__r1],A
    0D18: 52 F5    MOV   A,[X-11]
    0D1A: 0C 1B    ADC   [__r0],A
    0D1C: 51 1B    MOV   A,[__r0]
    0D1E: 60 D4    MOV   REG[212],A
    0D20: 3E 1A    MVI   A,[__r1]
    0D22: 53 13    MOV   [__r8],A
    0D24: 3E 1A    MVI   A,[__r1]
    0D26: 53 12    MOV   [__r9],A
    0D28: 3E 1A    MVI   A,[__r1]
    0D2A: 53 11    MOV   [__r10],A
    0D2C: 3E 1A    MVI   A,[__r1]
    0D2E: 53 10    MOV   [__r11],A
    0D30: 51 13    MOV   A,[__r8]
    0D32: 08       PUSH  A
    0D33: 51 12    MOV   A,[__r9]
    0D35: 08       PUSH  A
    0D36: 51 11    MOV   A,[__r10]
    0D38: 08       PUSH  A
    0D39: 51 10    MOV   A,[__r11]
    0D3B: 08       PUSH  A
    0D3C: 52 10    MOV   A,[X+16]
    0D3E: 08       PUSH  A
    0D3F: 52 11    MOV   A,[X+17]
    0D41: 08       PUSH  A
    0D42: 52 12    MOV   A,[X+18]
    0D44: 08       PUSH  A
    0D45: 52 13    MOV   A,[X+19]
    0D47: 08       PUSH  A
    0D48: 7C 21 9A LCALL __fpmul
    0D4B: 18       POP   A
    0D4C: 53 18    MOV   [__r3],A
    0D4E: 18       POP   A
    0D4F: 53 19    MOV   [__r2],A
    0D51: 18       POP   A
    0D52: 53 1A    MOV   [__r1],A
    0D54: 18       POP   A
    0D55: 53 1B    MOV   [__r0],A
    0D57: 38 FC    ADD   SP,252
    0D59: 51 17    MOV   A,[__r4]
    0D5B: 08       PUSH  A
    0D5C: 51 16    MOV   A,[__r5]
    0D5E: 08       PUSH  A
    0D5F: 51 15    MOV   A,[__r6]
    0D61: 08       PUSH  A
    0D62: 51 14    MOV   A,[__r7]
    0D64: 08       PUSH  A
    0D65: 51 1B    MOV   A,[__r0]
    0D67: 08       PUSH  A
    0D68: 51 1A    MOV   A,[__r1]
    0D6A: 08       PUSH  A
    0D6B: 51 19    MOV   A,[__r2]
    0D6D: 08       PUSH  A
    0D6E: 51 18    MOV   A,[__r3]
    0D70: 08       PUSH  A
    0D71: 7C 20 A8 LCALL __fpsub
    0D74: 18       POP   A
    0D75: 54 0B    MOV   [X+11],A
    0D77: 18       POP   A
    0D78: 54 0A    MOV   [X+10],A
    0D7A: 18       POP   A
    0D7B: 54 09    MOV   [X+9],A
    0D7D: 18       POP   A
    0D7E: 54 08    MOV   [X+8],A
    0D80: 38 FC    ADD   SP,252
(0059)             t2 = u1 * y[i1] + u2 * x[i1];
    0D82: 52 04    MOV   A,[X+4]
    0D84: 53 1B    MOV   [__r0],A
    0D86: 52 05    MOV   A,[X+5]
    0D88: 53 1A    MOV   [__r1],A
    0D8A: 52 06    MOV   A,[X+6]
    0D8C: 53 19    MOV   [__r2],A
    0D8E: 52 07    MOV   A,[X+7]
    0D90: 53 18    MOV   [__r3],A
    0D92: 50 02    MOV   A,2
    0D94: 62 D0 00 MOV   REG[208],0
    0D97: 65 18    ASL   [__r3]
    0D99: 6B 19    RLC   [__r2]
    0D9B: 6B 1A    RLC   [__r1]
    0D9D: 6B 1B    RLC   [__r0]
    0D9F: 78       DEC   A
    0DA0: BF F3    JNZ   0x0D94
    0DA2: 51 18    MOV   A,[__r3]
    0DA4: 53 1A    MOV   [__r1],A
    0DA6: 51 19    MOV   A,[__r2]
    0DA8: 53 1B    MOV   [__r0],A
    0DAA: 51 1A    MOV   A,[__r1]
    0DAC: 03 F6    ADD   A,[X-10]
    0DAE: 53 18    MOV   [__r3],A
    0DB0: 51 1B    MOV   A,[__r0]
    0DB2: 0B F5    ADC   A,[X-11]
    0DB4: 60 D4    MOV   REG[212],A
    0DB6: 3E 18    MVI   A,[__r3]
    0DB8: 53 17    MOV   [__r4],A
    0DBA: 3E 18    MVI   A,[__r3]
    0DBC: 53 16    MOV   [__r5],A
    0DBE: 3E 18    MVI   A,[__r3]
    0DC0: 53 15    MOV   [__r6],A
    0DC2: 3E 18    MVI   A,[__r3]
    0DC4: 53 14    MOV   [__r7],A
    0DC6: 51 17    MOV   A,[__r4]
    0DC8: 08       PUSH  A
    0DC9: 51 16    MOV   A,[__r5]
    0DCB: 08       PUSH  A
    0DCC: 51 15    MOV   A,[__r6]
    0DCE: 08       PUSH  A
    0DCF: 51 14    MOV   A,[__r7]
    0DD1: 08       PUSH  A
    0DD2: 52 14    MOV   A,[X+20]
    0DD4: 08       PUSH  A
    0DD5: 52 15    MOV   A,[X+21]
    0DD7: 08       PUSH  A
    0DD8: 52 16    MOV   A,[X+22]
    0DDA: 08       PUSH  A
    0DDB: 52 17    MOV   A,[X+23]
    0DDD: 08       PUSH  A
    0DDE: 7C 21 9A LCALL __fpmul
    0DE1: 18       POP   A
    0DE2: 53 14    MOV   [__r7],A
    0DE4: 18       POP   A
    0DE5: 53 15    MOV   [__r6],A
    0DE7: 18       POP   A
    0DE8: 53 16    MOV   [__r5],A
    0DEA: 18       POP   A
    0DEB: 53 17    MOV   [__r4],A
    0DED: 38 FC    ADD   SP,252
    0DEF: 52 F4    MOV   A,[X-12]
    0DF1: 04 1A    ADD   [__r1],A
    0DF3: 52 F3    MOV   A,[X-13]
    0DF5: 0C 1B    ADC   [__r0],A
    0DF7: 51 1B    MOV   A,[__r0]
    0DF9: 60 D4    MOV   REG[212],A
    0DFB: 3E 1A    MVI   A,[__r1]
    0DFD: 53 13    MOV   [__r8],A
    0DFF: 3E 1A    MVI   A,[__r1]
    0E01: 53 12    MOV   [__r9],A
    0E03: 3E 1A    MVI   A,[__r1]
    0E05: 53 11    MOV   [__r10],A
    0E07: 3E 1A    MVI   A,[__r1]
    0E09: 53 10    MOV   [__r11],A
    0E0B: 51 13    MOV   A,[__r8]
    0E0D: 08       PUSH  A
    0E0E: 51 12    MOV   A,[__r9]
    0E10: 08       PUSH  A
    0E11: 51 11    MOV   A,[__r10]
    0E13: 08       PUSH  A
    0E14: 51 10    MOV   A,[__r11]
    0E16: 08       PUSH  A
    0E17: 52 10    MOV   A,[X+16]
    0E19: 08       PUSH  A
    0E1A: 52 11    MOV   A,[X+17]
    0E1C: 08       PUSH  A
    0E1D: 52 12    MOV   A,[X+18]
    0E1F: 08       PUSH  A
    0E20: 52 13    MOV   A,[X+19]
    0E22: 08       PUSH  A
    0E23: 7C 21 9A LCALL __fpmul
    0E26: 18       POP   A
    0E27: 53 18    MOV   [__r3],A
    0E29: 18       POP   A
    0E2A: 53 19    MOV   [__r2],A
    0E2C: 18       POP   A
    0E2D: 53 1A    MOV   [__r1],A
    0E2F: 18       POP   A
    0E30: 53 1B    MOV   [__r0],A
    0E32: 38 FC    ADD   SP,252
    0E34: 51 17    MOV   A,[__r4]
    0E36: 08       PUSH  A
    0E37: 51 16    MOV   A,[__r5]
    0E39: 08       PUSH  A
    0E3A: 51 15    MOV   A,[__r6]
    0E3C: 08       PUSH  A
    0E3D: 51 14    MOV   A,[__r7]
    0E3F: 08       PUSH  A
    0E40: 51 1B    MOV   A,[__r0]
    0E42: 08       PUSH  A
    0E43: 51 1A    MOV   A,[__r1]
    0E45: 08       PUSH  A
    0E46: 51 19    MOV   A,[__r2]
    0E48: 08       PUSH  A
    0E49: 51 18    MOV   A,[__r3]
    0E4B: 08       PUSH  A
    0E4C: 7C 20 B6 LCALL __fpadd
    0E4F: 18       POP   A
    0E50: 54 0F    MOV   [X+15],A
    0E52: 18       POP   A
    0E53: 54 0E    MOV   [X+14],A
    0E55: 18       POP   A
    0E56: 54 0D    MOV   [X+13],A
    0E58: 18       POP   A
    0E59: 54 0C    MOV   [X+12],A
    0E5B: 38 FC    ADD   SP,252
(0060)             x[i1] = x[i] - t1; 
    0E5D: 52 00    MOV   A,[X+0]
    0E5F: 53 1B    MOV   [__r0],A
    0E61: 52 01    MOV   A,[X+1]
    0E63: 53 1A    MOV   [__r1],A
    0E65: 52 02    MOV   A,[X+2]
    0E67: 53 19    MOV   [__r2],A
    0E69: 52 03    MOV   A,[X+3]
    0E6B: 53 18    MOV   [__r3],A
    0E6D: 50 02    MOV   A,2
    0E6F: 62 D0 00 MOV   REG[208],0
    0E72: 65 18    ASL   [__r3]
    0E74: 6B 19    RLC   [__r2]
    0E76: 6B 1A    RLC   [__r1]
    0E78: 6B 1B    RLC   [__r0]
    0E7A: 78       DEC   A
    0E7B: BF F3    JNZ   0x0E6F
    0E7D: 51 18    MOV   A,[__r3]
    0E7F: 53 1A    MOV   [__r1],A
    0E81: 51 19    MOV   A,[__r2]
    0E83: 53 1B    MOV   [__r0],A
    0E85: 52 F6    MOV   A,[X-10]
    0E87: 04 1A    ADD   [__r1],A
    0E89: 52 F5    MOV   A,[X-11]
    0E8B: 0C 1B    ADC   [__r0],A
    0E8D: 51 1B    MOV   A,[__r0]
    0E8F: 60 D4    MOV   REG[212],A
    0E91: 3E 1A    MVI   A,[__r1]
    0E93: 53 17    MOV   [__r4],A
    0E95: 3E 1A    MVI   A,[__r1]
    0E97: 53 16    MOV   [__r5],A
    0E99: 3E 1A    MVI   A,[__r1]
    0E9B: 53 15    MOV   [__r6],A
    0E9D: 3E 1A    MVI   A,[__r1]
    0E9F: 53 14    MOV   [__r7],A
    0EA1: 52 08    MOV   A,[X+8]
    0EA3: 08       PUSH  A
    0EA4: 52 09    MOV   A,[X+9]
    0EA6: 08       PUSH  A
    0EA7: 52 0A    MOV   A,[X+10]
    0EA9: 08       PUSH  A
    0EAA: 52 0B    MOV   A,[X+11]
    0EAC: 08       PUSH  A
    0EAD: 51 17    MOV   A,[__r4]
    0EAF: 08       PUSH  A
    0EB0: 51 16    MOV   A,[__r5]
    0EB2: 08       PUSH  A
    0EB3: 51 15    MOV   A,[__r6]
    0EB5: 08       PUSH  A
    0EB6: 51 14    MOV   A,[__r7]
    0EB8: 08       PUSH  A
    0EB9: 7C 20 A8 LCALL __fpsub
    0EBC: 18       POP   A
    0EBD: 53 18    MOV   [__r3],A
    0EBF: 18       POP   A
    0EC0: 53 19    MOV   [__r2],A
    0EC2: 18       POP   A
    0EC3: 53 1A    MOV   [__r1],A
    0EC5: 18       POP   A
    0EC6: 53 1B    MOV   [__r0],A
    0EC8: 38 FC    ADD   SP,252
    0ECA: 52 04    MOV   A,[X+4]
    0ECC: 53 17    MOV   [__r4],A
    0ECE: 52 05    MOV   A,[X+5]
    0ED0: 53 16    MOV   [__r5],A
    0ED2: 52 06    MOV   A,[X+6]
    0ED4: 53 15    MOV   [__r6],A
    0ED6: 52 07    MOV   A,[X+7]
    0ED8: 53 14    MOV   [__r7],A
    0EDA: 50 02    MOV   A,2
    0EDC: 62 D0 00 MOV   REG[208],0
    0EDF: 65 14    ASL   [__r7]
    0EE1: 6B 15    RLC   [__r6]
    0EE3: 6B 16    RLC   [__r5]
    0EE5: 6B 17    RLC   [__r4]
    0EE7: 78       DEC   A
    0EE8: BF F3    JNZ   0x0EDC
    0EEA: 51 14    MOV   A,[__r7]
    0EEC: 53 16    MOV   [__r5],A
    0EEE: 51 15    MOV   A,[__r6]
    0EF0: 53 17    MOV   [__r4],A
    0EF2: 52 F6    MOV   A,[X-10]
    0EF4: 04 16    ADD   [__r5],A
    0EF6: 52 F5    MOV   A,[X-11]
    0EF8: 0C 17    ADC   [__r4],A
    0EFA: 51 17    MOV   A,[__r4]
    0EFC: 60 D5    MOV   REG[213],A
    0EFE: 51 1B    MOV   A,[__r0]
    0F00: 3F 16    MVI   [__r5],A
    0F02: 51 1A    MOV   A,[__r1]
    0F04: 3F 16    MVI   [__r5],A
    0F06: 51 19    MOV   A,[__r2]
    0F08: 3F 16    MVI   [__r5],A
    0F0A: 51 18    MOV   A,[__r3]
    0F0C: 3F 16    MVI   [__r5],A
(0061)             y[i1] = y[i] - t2;
    0F0E: 52 00    MOV   A,[X+0]
    0F10: 53 1B    MOV   [__r0],A
    0F12: 52 01    MOV   A,[X+1]
    0F14: 53 1A    MOV   [__r1],A
    0F16: 52 02    MOV   A,[X+2]
    0F18: 53 19    MOV   [__r2],A
    0F1A: 52 03    MOV   A,[X+3]
    0F1C: 53 18    MOV   [__r3],A
    0F1E: 50 02    MOV   A,2
    0F20: 62 D0 00 MOV   REG[208],0
    0F23: 65 18    ASL   [__r3]
    0F25: 6B 19    RLC   [__r2]
    0F27: 6B 1A    RLC   [__r1]
    0F29: 6B 1B    RLC   [__r0]
    0F2B: 78       DEC   A
    0F2C: BF F3    JNZ   0x0F20
    0F2E: 51 18    MOV   A,[__r3]
    0F30: 53 1A    MOV   [__r1],A
    0F32: 51 19    MOV   A,[__r2]
    0F34: 53 1B    MOV   [__r0],A
    0F36: 52 F4    MOV   A,[X-12]
    0F38: 04 1A    ADD   [__r1],A
    0F3A: 52 F3    MOV   A,[X-13]
    0F3C: 0C 1B    ADC   [__r0],A
    0F3E: 51 1B    MOV   A,[__r0]
    0F40: 60 D4    MOV   REG[212],A
    0F42: 3E 1A    MVI   A,[__r1]
    0F44: 53 17    MOV   [__r4],A
    0F46: 3E 1A    MVI   A,[__r1]
    0F48: 53 16    MOV   [__r5],A
    0F4A: 3E 1A    MVI   A,[__r1]
    0F4C: 53 15    MOV   [__r6],A
    0F4E: 3E 1A    MVI   A,[__r1]
    0F50: 53 14    MOV   [__r7],A
    0F52: 52 0C    MOV   A,[X+12]
    0F54: 08       PUSH  A
    0F55: 52 0D    MOV   A,[X+13]
    0F57: 08       PUSH  A
    0F58: 52 0E    MOV   A,[X+14]
    0F5A: 08       PUSH  A
    0F5B: 52 0F    MOV   A,[X+15]
    0F5D: 08       PUSH  A
    0F5E: 51 17    MOV   A,[__r4]
    0F60: 08       PUSH  A
    0F61: 51 16    MOV   A,[__r5]
    0F63: 08       PUSH  A
    0F64: 51 15    MOV   A,[__r6]
    0F66: 08       PUSH  A
    0F67: 51 14    MOV   A,[__r7]
    0F69: 08       PUSH  A
    0F6A: 7C 20 A8 LCALL __fpsub
    0F6D: 18       POP   A
    0F6E: 53 18    MOV   [__r3],A
    0F70: 18       POP   A
    0F71: 53 19    MOV   [__r2],A
    0F73: 18       POP   A
    0F74: 53 1A    MOV   [__r1],A
    0F76: 18       POP   A
    0F77: 53 1B    MOV   [__r0],A
    0F79: 38 FC    ADD   SP,252
    0F7B: 52 04    MOV   A,[X+4]
    0F7D: 53 17    MOV   [__r4],A
    0F7F: 52 05    MOV   A,[X+5]
    0F81: 53 16    MOV   [__r5],A
    0F83: 52 06    MOV   A,[X+6]
    0F85: 53 15    MOV   [__r6],A
    0F87: 52 07    MOV   A,[X+7]
    0F89: 53 14    MOV   [__r7],A
    0F8B: 50 02    MOV   A,2
    0F8D: 62 D0 00 MOV   REG[208],0
    0F90: 65 14    ASL   [__r7]
    0F92: 6B 15    RLC   [__r6]
    0F94: 6B 16    RLC   [__r5]
    0F96: 6B 17    RLC   [__r4]
    0F98: 78       DEC   A
    0F99: BF F3    JNZ   0x0F8D
    0F9B: 51 14    MOV   A,[__r7]
    0F9D: 53 16    MOV   [__r5],A
    0F9F: 51 15    MOV   A,[__r6]
    0FA1: 53 17    MOV   [__r4],A
    0FA3: 52 F4    MOV   A,[X-12]
    0FA5: 04 16    ADD   [__r5],A
    0FA7: 52 F3    MOV   A,[X-13]
    0FA9: 0C 17    ADC   [__r4],A
    0FAB: 51 17    MOV   A,[__r4]
    0FAD: 60 D5    MOV   REG[213],A
    0FAF: 51 1B    MOV   A,[__r0]
    0FB1: 3F 16    MVI   [__r5],A
    0FB3: 51 1A    MOV   A,[__r1]
    0FB5: 3F 16    MVI   [__r5],A
    0FB7: 51 19    MOV   A,[__r2]
    0FB9: 3F 16    MVI   [__r5],A
    0FBB: 51 18    MOV   A,[__r3]
    0FBD: 3F 16    MVI   [__r5],A
(0062)             x[i] += t1;
    0FBF: 52 00    MOV   A,[X+0]
    0FC1: 53 1B    MOV   [__r0],A
    0FC3: 52 01    MOV   A,[X+1]
    0FC5: 53 1A    MOV   [__r1],A
    0FC7: 52 02    MOV   A,[X+2]
    0FC9: 53 19    MOV   [__r2],A
    0FCB: 52 03    MOV   A,[X+3]
    0FCD: 53 18    MOV   [__r3],A
    0FCF: 50 02    MOV   A,2
    0FD1: 62 D0 00 MOV   REG[208],0
    0FD4: 65 18    ASL   [__r3]
    0FD6: 6B 19    RLC   [__r2]
    0FD8: 6B 1A    RLC   [__r1]
    0FDA: 6B 1B    RLC   [__r0]
    0FDC: 78       DEC   A
    0FDD: BF F3    JNZ   0x0FD1
    0FDF: 51 18    MOV   A,[__r3]
    0FE1: 53 1A    MOV   [__r1],A
    0FE3: 51 19    MOV   A,[__r2]
    0FE5: 53 1B    MOV   [__r0],A
    0FE7: 52 F6    MOV   A,[X-10]
    0FE9: 04 1A    ADD   [__r1],A
    0FEB: 52 F5    MOV   A,[X-11]
    0FED: 0C 1B    ADC   [__r0],A
    0FEF: 51 1B    MOV   A,[__r0]
    0FF1: 60 D4    MOV   REG[212],A
    0FF3: 3E 1A    MVI   A,[__r1]
    0FF5: 53 17    MOV   [__r4],A
    0FF7: 3E 1A    MVI   A,[__r1]
    0FF9: 53 16    MOV   [__r5],A
    0FFB: 3E 1A    MVI   A,[__r1]
    0FFD: 53 15    MOV   [__r6],A
    0FFF: 3E 1A    MVI   A,[__r1]
    1001: 16 1A 04 SUB   [__r1],4
    1004: 53 14    MOV   [__r7],A
    1006: 52 08    MOV   A,[X+8]
    1008: 08       PUSH  A
    1009: 52 09    MOV   A,[X+9]
    100B: 08       PUSH  A
    100C: 52 0A    MOV   A,[X+10]
    100E: 08       PUSH  A
    100F: 52 0B    MOV   A,[X+11]
    1011: 08       PUSH  A
    1012: 51 17    MOV   A,[__r4]
    1014: 08       PUSH  A
    1015: 51 16    MOV   A,[__r5]
    1017: 08       PUSH  A
    1018: 51 15    MOV   A,[__r6]
    101A: 08       PUSH  A
    101B: 51 14    MOV   A,[__r7]
    101D: 08       PUSH  A
    101E: 7C 20 B6 LCALL __fpadd
    1021: 18       POP   A
    1022: 53 14    MOV   [__r7],A
    1024: 18       POP   A
    1025: 53 15    MOV   [__r6],A
    1027: 18       POP   A
    1028: 53 16    MOV   [__r5],A
    102A: 18       POP   A
    102B: 53 17    MOV   [__r4],A
    102D: 38 FC    ADD   SP,252
    102F: 51 1B    MOV   A,[__r0]
    1031: 60 D5    MOV   REG[213],A
    1033: 51 17    MOV   A,[__r4]
    1035: 3F 1A    MVI   [__r1],A
    1037: 51 16    MOV   A,[__r5]
    1039: 3F 1A    MVI   [__r1],A
    103B: 51 15    MOV   A,[__r6]
    103D: 3F 1A    MVI   [__r1],A
    103F: 51 14    MOV   A,[__r7]
    1041: 3F 1A    MVI   [__r1],A
(0063)             y[i] += t2;
    1043: 52 00    MOV   A,[X+0]
    1045: 53 1B    MOV   [__r0],A
    1047: 52 01    MOV   A,[X+1]
    1049: 53 1A    MOV   [__r1],A
    104B: 52 02    MOV   A,[X+2]
    104D: 53 19    MOV   [__r2],A
    104F: 52 03    MOV   A,[X+3]
    1051: 53 18    MOV   [__r3],A
    1053: 50 02    MOV   A,2
    1055: 62 D0 00 MOV   REG[208],0
    1058: 65 18    ASL   [__r3]
    105A: 6B 19    RLC   [__r2]
    105C: 6B 1A    RLC   [__r1]
    105E: 6B 1B    RLC   [__r0]
    1060: 78       DEC   A
    1061: BF F3    JNZ   0x1055
    1063: 51 18    MOV   A,[__r3]
    1065: 53 1A    MOV   [__r1],A
    1067: 51 19    MOV   A,[__r2]
    1069: 53 1B    MOV   [__r0],A
    106B: 52 F4    MOV   A,[X-12]
    106D: 04 1A    ADD   [__r1],A
    106F: 52 F3    MOV   A,[X-13]
    1071: 0C 1B    ADC   [__r0],A
    1073: 51 1B    MOV   A,[__r0]
    1075: 60 D4    MOV   REG[212],A
    1077: 3E 1A    MVI   A,[__r1]
    1079: 53 17    MOV   [__r4],A
    107B: 3E 1A    MVI   A,[__r1]
    107D: 53 16    MOV   [__r5],A
    107F: 3E 1A    MVI   A,[__r1]
    1081: 53 15    MOV   [__r6],A
    1083: 3E 1A    MVI   A,[__r1]
    1085: 16 1A 04 SUB   [__r1],4
    1088: 53 14    MOV   [__r7],A
    108A: 52 0C    MOV   A,[X+12]
    108C: 08       PUSH  A
    108D: 52 0D    MOV   A,[X+13]
    108F: 08       PUSH  A
    1090: 52 0E    MOV   A,[X+14]
    1092: 08       PUSH  A
    1093: 52 0F    MOV   A,[X+15]
    1095: 08       PUSH  A
    1096: 51 17    MOV   A,[__r4]
    1098: 08       PUSH  A
    1099: 51 16    MOV   A,[__r5]
    109B: 08       PUSH  A
    109C: 51 15    MOV   A,[__r6]
    109E: 08       PUSH  A
    109F: 51 14    MOV   A,[__r7]
    10A1: 08       PUSH  A
    10A2: 7C 20 B6 LCALL __fpadd
    10A5: 18       POP   A
    10A6: 53 14    MOV   [__r7],A
    10A8: 18       POP   A
    10A9: 53 15    MOV   [__r6],A
    10AB: 18       POP   A
    10AC: 53 16    MOV   [__r5],A
    10AE: 18       POP   A
    10AF: 53 17    MOV   [__r4],A
    10B1: 38 FC    ADD   SP,252
    10B3: 51 1B    MOV   A,[__r0]
    10B5: 60 D5    MOV   REG[213],A
    10B7: 51 17    MOV   A,[__r4]
    10B9: 3F 1A    MVI   [__r1],A
    10BB: 51 16    MOV   A,[__r5]
    10BD: 3F 1A    MVI   [__r1],A
    10BF: 51 15    MOV   A,[__r6]
    10C1: 3F 1A    MVI   [__r1],A
    10C3: 51 14    MOV   A,[__r7]
    10C5: 3F 1A    MVI   [__r1],A
    10C7: 52 23    MOV   A,[X+35]
    10C9: 05 03    ADD   [X+3],A
    10CB: 52 22    MOV   A,[X+34]
    10CD: 0D 02    ADC   [X+2],A
    10CF: 52 21    MOV   A,[X+33]
    10D1: 0D 01    ADC   [X+1],A
    10D3: 52 20    MOV   A,[X+32]
    10D5: 0D 00    ADC   [X+0],A
    10D7: 52 03    MOV   A,[X+3]
    10D9: 13 1F    SUB   A,[X+31]
    10DB: 52 02    MOV   A,[X+2]
    10DD: 1B 1E    SBB   A,[X+30]
    10DF: 52 01    MOV   A,[X+1]
    10E1: 1B 1D    SBB   A,[X+29]
    10E3: 52 1C    MOV   A,[X+28]
    10E5: 31 80    XOR   A,128
    10E7: 62 D0 00 MOV   REG[208],0
    10EA: 53 0F    MOV   [__rX],A
    10EC: 52 00    MOV   A,[X+0]
    10EE: 31 80    XOR   A,128
    10F0: 1A 0F    SBB   A,[__rX]
    10F2: CB 99    JC    0x0C8C
(0064)          }
(0065)          z =  u1 * c1 - u2 * c2;
    10F4: 62 D0 00 MOV   REG[208],0
    10F7: 52 30    MOV   A,[X+48]
    10F9: 08       PUSH  A
    10FA: 52 31    MOV   A,[X+49]
    10FC: 08       PUSH  A
    10FD: 52 32    MOV   A,[X+50]
    10FF: 08       PUSH  A
    1100: 52 33    MOV   A,[X+51]
    1102: 08       PUSH  A
    1103: 52 14    MOV   A,[X+20]
    1105: 08       PUSH  A
    1106: 52 15    MOV   A,[X+21]
    1108: 08       PUSH  A
    1109: 52 16    MOV   A,[X+22]
    110B: 08       PUSH  A
    110C: 52 17    MOV   A,[X+23]
    110E: 08       PUSH  A
    110F: 7C 21 9A LCALL __fpmul
    1112: 18       POP   A
    1113: 53 18    MOV   [__r3],A
    1115: 18       POP   A
    1116: 53 19    MOV   [__r2],A
    1118: 18       POP   A
    1119: 53 1A    MOV   [__r1],A
    111B: 18       POP   A
    111C: 53 1B    MOV   [__r0],A
    111E: 38 FC    ADD   SP,252
    1120: 52 2C    MOV   A,[X+44]
    1122: 08       PUSH  A
    1123: 52 2D    MOV   A,[X+45]
    1125: 08       PUSH  A
    1126: 52 2E    MOV   A,[X+46]
    1128: 08       PUSH  A
    1129: 52 2F    MOV   A,[X+47]
    112B: 08       PUSH  A
    112C: 52 10    MOV   A,[X+16]
    112E: 08       PUSH  A
    112F: 52 11    MOV   A,[X+17]
    1131: 08       PUSH  A
    1132: 52 12    MOV   A,[X+18]
    1134: 08       PUSH  A
    1135: 52 13    MOV   A,[X+19]
    1137: 08       PUSH  A
    1138: 7C 21 9A LCALL __fpmul
    113B: 18       POP   A
    113C: 53 14    MOV   [__r7],A
    113E: 18       POP   A
    113F: 53 15    MOV   [__r6],A
    1141: 18       POP   A
    1142: 53 16    MOV   [__r5],A
    1144: 18       POP   A
    1145: 53 17    MOV   [__r4],A
    1147: 38 FC    ADD   SP,252
    1149: 51 1B    MOV   A,[__r0]
    114B: 08       PUSH  A
    114C: 51 1A    MOV   A,[__r1]
    114E: 08       PUSH  A
    114F: 51 19    MOV   A,[__r2]
    1151: 08       PUSH  A
    1152: 51 18    MOV   A,[__r3]
    1154: 08       PUSH  A
    1155: 51 17    MOV   A,[__r4]
    1157: 08       PUSH  A
    1158: 51 16    MOV   A,[__r5]
    115A: 08       PUSH  A
    115B: 51 15    MOV   A,[__r6]
    115D: 08       PUSH  A
    115E: 51 14    MOV   A,[__r7]
    1160: 08       PUSH  A
    1161: 7C 20 A8 LCALL __fpsub
    1164: 18       POP   A
    1165: 54 37    MOV   [X+55],A
    1167: 18       POP   A
    1168: 54 36    MOV   [X+54],A
    116A: 18       POP   A
    116B: 54 35    MOV   [X+53],A
    116D: 18       POP   A
    116E: 54 34    MOV   [X+52],A
    1170: 38 FC    ADD   SP,252
(0066)          u2 = u1 * c2 + u2 * c1;
    1172: 52 2C    MOV   A,[X+44]
    1174: 08       PUSH  A
    1175: 52 2D    MOV   A,[X+45]
    1177: 08       PUSH  A
    1178: 52 2E    MOV   A,[X+46]
    117A: 08       PUSH  A
    117B: 52 2F    MOV   A,[X+47]
    117D: 08       PUSH  A
    117E: 52 14    MOV   A,[X+20]
    1180: 08       PUSH  A
    1181: 52 15    MOV   A,[X+21]
    1183: 08       PUSH  A
    1184: 52 16    MOV   A,[X+22]
    1186: 08       PUSH  A
    1187: 52 17    MOV   A,[X+23]
    1189: 08       PUSH  A
    118A: 7C 21 9A LCALL __fpmul
    118D: 18       POP   A
    118E: 53 18    MOV   [__r3],A
    1190: 18       POP   A
    1191: 53 19    MOV   [__r2],A
    1193: 18       POP   A
    1194: 53 1A    MOV   [__r1],A
    1196: 18       POP   A
    1197: 53 1B    MOV   [__r0],A
    1199: 38 FC    ADD   SP,252
    119B: 52 30    MOV   A,[X+48]
    119D: 08       PUSH  A
    119E: 52 31    MOV   A,[X+49]
    11A0: 08       PUSH  A
    11A1: 52 32    MOV   A,[X+50]
    11A3: 08       PUSH  A
    11A4: 52 33    MOV   A,[X+51]
    11A6: 08       PUSH  A
    11A7: 52 10    MOV   A,[X+16]
    11A9: 08       PUSH  A
    11AA: 52 11    MOV   A,[X+17]
    11AC: 08       PUSH  A
    11AD: 52 12    MOV   A,[X+18]
    11AF: 08       PUSH  A
    11B0: 52 13    MOV   A,[X+19]
    11B2: 08       PUSH  A
    11B3: 7C 21 9A LCALL __fpmul
    11B6: 18       POP   A
    11B7: 53 14    MOV   [__r7],A
    11B9: 18       POP   A
    11BA: 53 15    MOV   [__r6],A
    11BC: 18       POP   A
    11BD: 53 16    MOV   [__r5],A
    11BF: 18       POP   A
    11C0: 53 17    MOV   [__r4],A
    11C2: 38 FC    ADD   SP,252
    11C4: 51 1B    MOV   A,[__r0]
    11C6: 08       PUSH  A
    11C7: 51 1A    MOV   A,[__r1]
    11C9: 08       PUSH  A
    11CA: 51 19    MOV   A,[__r2]
    11CC: 08       PUSH  A
    11CD: 51 18    MOV   A,[__r3]
    11CF: 08       PUSH  A
    11D0: 51 17    MOV   A,[__r4]
    11D2: 08       PUSH  A
    11D3: 51 16    MOV   A,[__r5]
    11D5: 08       PUSH  A
    11D6: 51 15    MOV   A,[__r6]
    11D8: 08       PUSH  A
    11D9: 51 14    MOV   A,[__r7]
    11DB: 08       PUSH  A
    11DC: 7C 20 B6 LCALL __fpadd
    11DF: 18       POP   A
    11E0: 54 17    MOV   [X+23],A
    11E2: 18       POP   A
    11E3: 54 16    MOV   [X+22],A
    11E5: 18       POP   A
    11E6: 54 15    MOV   [X+21],A
    11E8: 18       POP   A
    11E9: 54 14    MOV   [X+20],A
    11EB: 38 FC    ADD   SP,252
(0067)          u1 = z;
    11ED: 52 34    MOV   A,[X+52]
    11EF: 54 10    MOV   [X+16],A
    11F1: 52 35    MOV   A,[X+53]
    11F3: 54 11    MOV   [X+17],A
    11F5: 52 36    MOV   A,[X+54]
    11F7: 54 12    MOV   [X+18],A
    11F9: 52 37    MOV   A,[X+55]
    11FB: 54 13    MOV   [X+19],A
    11FD: 07 27 01 ADD   [X+39],1
    1200: 0F 26 00 ADC   [X+38],0
    1203: 0F 25 00 ADC   [X+37],0
    1206: 0F 24 00 ADC   [X+36],0
    1209: 52 27    MOV   A,[X+39]
    120B: 13 1B    SUB   A,[X+27]
    120D: 52 26    MOV   A,[X+38]
    120F: 1B 1A    SBB   A,[X+26]
    1211: 52 25    MOV   A,[X+37]
    1213: 1B 19    SBB   A,[X+25]
    1215: 52 18    MOV   A,[X+24]
    1217: 31 80    XOR   A,128
    1219: 62 D0 00 MOV   REG[208],0
    121C: 53 0F    MOV   [__rX],A
    121E: 52 24    MOV   A,[X+36]
    1220: 31 80    XOR   A,128
    1222: 1A 0F    SBB   A,[__rX]
    1224: CA 55    JC    0x0C7A
(0068)       }
(0069)       c2 = sqrt((1.0 - c1) / 2.0);
    1226: 62 D0 00 MOV   REG[208],0
    1229: 52 2C    MOV   A,[X+44]
    122B: 08       PUSH  A
    122C: 52 2D    MOV   A,[X+45]
    122E: 08       PUSH  A
    122F: 52 2E    MOV   A,[X+46]
    1231: 08       PUSH  A
    1232: 52 2F    MOV   A,[X+47]
    1234: 08       PUSH  A
    1235: 50 3F    MOV   A,63
    1237: 08       PUSH  A
    1238: 50 80    MOV   A,128
    123A: 08       PUSH  A
    123B: 50 00    MOV   A,0
    123D: 08       PUSH  A
    123E: 08       PUSH  A
    123F: 7C 20 A8 LCALL __fpsub
    1242: 18       POP   A
    1243: 53 18    MOV   [__r3],A
    1245: 18       POP   A
    1246: 53 19    MOV   [__r2],A
    1248: 18       POP   A
    1249: 53 1A    MOV   [__r1],A
    124B: 18       POP   A
    124C: 53 1B    MOV   [__r0],A
    124E: 38 FC    ADD   SP,252
    1250: 50 40    MOV   A,64
    1252: 08       PUSH  A
    1253: 50 00    MOV   A,0
    1255: 08       PUSH  A
    1256: 08       PUSH  A
    1257: 08       PUSH  A
    1258: 51 1B    MOV   A,[__r0]
    125A: 08       PUSH  A
    125B: 51 1A    MOV   A,[__r1]
    125D: 08       PUSH  A
    125E: 51 19    MOV   A,[__r2]
    1260: 08       PUSH  A
    1261: 51 18    MOV   A,[__r3]
    1263: 08       PUSH  A
    1264: 7C 22 83 LCALL __fpdiv
    1267: 18       POP   A
    1268: 53 18    MOV   [__r3],A
    126A: 18       POP   A
    126B: 53 19    MOV   [__r2],A
    126D: 18       POP   A
    126E: 53 1A    MOV   [__r1],A
    1270: 18       POP   A
    1271: 38 FC    ADD   SP,252
    1273: 08       PUSH  A
    1274: 51 1A    MOV   A,[__r1]
    1276: 08       PUSH  A
    1277: 51 19    MOV   A,[__r2]
    1279: 08       PUSH  A
    127A: 51 18    MOV   A,[__r3]
    127C: 08       PUSH  A
    127D: 7C 29 C9 LCALL _sqrt
    1280: 38 FC    ADD   SP,252
    1282: 62 D0 00 MOV   REG[208],0
    1285: 51 1B    MOV   A,[__r0]
    1287: 54 30    MOV   [X+48],A
    1289: 51 1A    MOV   A,[__r1]
    128B: 54 31    MOV   [X+49],A
    128D: 51 19    MOV   A,[__r2]
    128F: 54 32    MOV   [X+50],A
    1291: 51 18    MOV   A,[__r3]
    1293: 54 33    MOV   [X+51],A
(0070)       if (dir == 1) 
    1295: 3D FB 00 CMP   [X-5],0
    1298: B0 09    JNZ   0x12A2
    129A: 3D FC 01 CMP   [X-4],1
    129D: B0 04    JNZ   0x12A2
(0071)          c2 = -c2;
    129F: 37 30 80 XOR   [X+48],128
(0072)       c1 = sqrt((1.0 + c1) / 2.0);
    12A2: 62 D0 00 MOV   REG[208],0
    12A5: 50 3F    MOV   A,63
    12A7: 08       PUSH  A
    12A8: 50 80    MOV   A,128
    12AA: 08       PUSH  A
    12AB: 50 00    MOV   A,0
    12AD: 08       PUSH  A
    12AE: 08       PUSH  A
    12AF: 52 2C    MOV   A,[X+44]
    12B1: 08       PUSH  A
    12B2: 52 2D    MOV   A,[X+45]
    12B4: 08       PUSH  A
    12B5: 52 2E    MOV   A,[X+46]
    12B7: 08       PUSH  A
    12B8: 52 2F    MOV   A,[X+47]
    12BA: 08       PUSH  A
    12BB: 7C 20 B6 LCALL __fpadd
    12BE: 18       POP   A
    12BF: 53 18    MOV   [__r3],A
    12C1: 18       POP   A
    12C2: 53 19    MOV   [__r2],A
    12C4: 18       POP   A
    12C5: 53 1A    MOV   [__r1],A
    12C7: 18       POP   A
    12C8: 53 1B    MOV   [__r0],A
    12CA: 38 FC    ADD   SP,252
    12CC: 50 40    MOV   A,64
    12CE: 08       PUSH  A
    12CF: 50 00    MOV   A,0
    12D1: 08       PUSH  A
    12D2: 08       PUSH  A
    12D3: 08       PUSH  A
    12D4: 51 1B    MOV   A,[__r0]
    12D6: 08       PUSH  A
    12D7: 51 1A    MOV   A,[__r1]
    12D9: 08       PUSH  A
    12DA: 51 19    MOV   A,[__r2]
    12DC: 08       PUSH  A
    12DD: 51 18    MOV   A,[__r3]
    12DF: 08       PUSH  A
    12E0: 7C 22 83 LCALL __fpdiv
    12E3: 18       POP   A
    12E4: 53 18    MOV   [__r3],A
    12E6: 18       POP   A
    12E7: 53 19    MOV   [__r2],A
    12E9: 18       POP   A
    12EA: 53 1A    MOV   [__r1],A
    12EC: 18       POP   A
    12ED: 38 FC    ADD   SP,252
    12EF: 08       PUSH  A
    12F0: 51 1A    MOV   A,[__r1]
    12F2: 08       PUSH  A
    12F3: 51 19    MOV   A,[__r2]
    12F5: 08       PUSH  A
    12F6: 51 18    MOV   A,[__r3]
    12F8: 08       PUSH  A
    12F9: 7C 29 C9 LCALL _sqrt
    12FC: 38 FC    ADD   SP,252
    12FE: 62 D0 00 MOV   REG[208],0
    1301: 51 1B    MOV   A,[__r0]
    1303: 54 2C    MOV   [X+44],A
    1305: 51 1A    MOV   A,[__r1]
    1307: 54 2D    MOV   [X+45],A
    1309: 51 19    MOV   A,[__r2]
    130B: 54 2E    MOV   [X+46],A
    130D: 51 18    MOV   A,[__r3]
    130F: 54 2F    MOV   [X+47],A
    1311: 07 3B 01 ADD   [X+59],1
    1314: 0F 3A 00 ADC   [X+58],0
    1317: 0F 39 00 ADC   [X+57],0
    131A: 0F 38 00 ADC   [X+56],0
    131D: 52 3B    MOV   A,[X+59]
    131F: 13 FA    SUB   A,[X-6]
    1321: 52 3A    MOV   A,[X+58]
    1323: 1B F9    SBB   A,[X-7]
    1325: 52 39    MOV   A,[X+57]
    1327: 1B F8    SBB   A,[X-8]
    1329: 52 F7    MOV   A,[X-9]
    132B: 31 80    XOR   A,128
    132D: 62 D0 00 MOV   REG[208],0
    1330: 53 0F    MOV   [__rX],A
    1332: 52 38    MOV   A,[X+56]
    1334: 31 80    XOR   A,128
    1336: 1A 0F    SBB   A,[__rX]
    1338: C9 03    JC    0x0C3C
(0073)    }
(0074) 
(0075)    /* Scaling factor for forward transform */
(0076)    if (dir == 1) {
    133A: 3D FB 00 CMP   [X-5],0
    133D: B1 7E    JNZ   0x14BC
    133F: 3D FC 01 CMP   [X-4],1
    1342: B1 79    JNZ   0x14BC
(0077)       for (i=0;i<n;i++) {
    1344: 56 00 00 MOV   [X+0],0
    1347: 56 01 00 MOV   [X+1],0
    134A: 56 02 00 MOV   [X+2],0
    134D: 56 03 00 MOV   [X+3],0
    1350: 81 4E    JMP   0x149F
(0078)          x[i] /= n;
    1352: 62 D0 00 MOV   REG[208],0
    1355: 52 00    MOV   A,[X+0]
    1357: 53 1B    MOV   [__r0],A
    1359: 52 01    MOV   A,[X+1]
    135B: 53 1A    MOV   [__r1],A
    135D: 52 02    MOV   A,[X+2]
    135F: 53 19    MOV   [__r2],A
    1361: 52 03    MOV   A,[X+3]
    1363: 53 18    MOV   [__r3],A
    1365: 50 02    MOV   A,2
    1367: 62 D0 00 MOV   REG[208],0
    136A: 65 18    ASL   [__r3]
    136C: 6B 19    RLC   [__r2]
    136E: 6B 1A    RLC   [__r1]
    1370: 6B 1B    RLC   [__r0]
    1372: 78       DEC   A
    1373: BF F3    JNZ   0x1367
    1375: 51 18    MOV   A,[__r3]
    1377: 53 1A    MOV   [__r1],A
    1379: 51 19    MOV   A,[__r2]
    137B: 53 1B    MOV   [__r0],A
    137D: 52 F6    MOV   A,[X-10]
    137F: 04 1A    ADD   [__r1],A
    1381: 52 F5    MOV   A,[X-11]
    1383: 0C 1B    ADC   [__r0],A
    1385: 52 1C    MOV   A,[X+28]
    1387: 08       PUSH  A
    1388: 52 1D    MOV   A,[X+29]
    138A: 08       PUSH  A
    138B: 52 1E    MOV   A,[X+30]
    138D: 08       PUSH  A
    138E: 52 1F    MOV   A,[X+31]
    1390: 08       PUSH  A
    1391: 7C 24 6D LCALL __long2fp
    1394: 18       POP   A
    1395: 53 14    MOV   [__r7],A
    1397: 18       POP   A
    1398: 53 15    MOV   [__r6],A
    139A: 18       POP   A
    139B: 53 16    MOV   [__r5],A
    139D: 18       POP   A
    139E: 53 17    MOV   [__r4],A
    13A0: 51 1B    MOV   A,[__r0]
    13A2: 60 D4    MOV   REG[212],A
    13A4: 3E 1A    MVI   A,[__r1]
    13A6: 53 13    MOV   [__r8],A
    13A8: 3E 1A    MVI   A,[__r1]
    13AA: 53 12    MOV   [__r9],A
    13AC: 3E 1A    MVI   A,[__r1]
    13AE: 53 11    MOV   [__r10],A
    13B0: 3E 1A    MVI   A,[__r1]
    13B2: 16 1A 04 SUB   [__r1],4
    13B5: 53 10    MOV   [__r11],A
    13B7: 51 17    MOV   A,[__r4]
    13B9: 08       PUSH  A
    13BA: 51 16    MOV   A,[__r5]
    13BC: 08       PUSH  A
    13BD: 51 15    MOV   A,[__r6]
    13BF: 08       PUSH  A
    13C0: 51 14    MOV   A,[__r7]
    13C2: 08       PUSH  A
    13C3: 51 13    MOV   A,[__r8]
    13C5: 08       PUSH  A
    13C6: 51 12    MOV   A,[__r9]
    13C8: 08       PUSH  A
    13C9: 51 11    MOV   A,[__r10]
    13CB: 08       PUSH  A
    13CC: 51 10    MOV   A,[__r11]
    13CE: 08       PUSH  A
    13CF: 7C 22 83 LCALL __fpdiv
    13D2: 18       POP   A
    13D3: 53 14    MOV   [__r7],A
    13D5: 18       POP   A
    13D6: 53 15    MOV   [__r6],A
    13D8: 18       POP   A
    13D9: 53 16    MOV   [__r5],A
    13DB: 18       POP   A
    13DC: 53 17    MOV   [__r4],A
    13DE: 38 FC    ADD   SP,252
    13E0: 51 1B    MOV   A,[__r0]
    13E2: 60 D5    MOV   REG[213],A
    13E4: 51 17    MOV   A,[__r4]
    13E6: 3F 1A    MVI   [__r1],A
    13E8: 51 16    MOV   A,[__r5]
    13EA: 3F 1A    MVI   [__r1],A
    13EC: 51 15    MOV   A,[__r6]
    13EE: 3F 1A    MVI   [__r1],A
    13F0: 51 14    MOV   A,[__r7]
    13F2: 3F 1A    MVI   [__r1],A
(0079)          y[i] /= n;
    13F4: 52 00    MOV   A,[X+0]
    13F6: 53 1B    MOV   [__r0],A
    13F8: 52 01    MOV   A,[X+1]
    13FA: 53 1A    MOV   [__r1],A
    13FC: 52 02    MOV   A,[X+2]
    13FE: 53 19    MOV   [__r2],A
    1400: 52 03    MOV   A,[X+3]
    1402: 53 18    MOV   [__r3],A
    1404: 50 02    MOV   A,2
    1406: 62 D0 00 MOV   REG[208],0
    1409: 65 18    ASL   [__r3]
    140B: 6B 19    RLC   [__r2]
    140D: 6B 1A    RLC   [__r1]
    140F: 6B 1B    RLC   [__r0]
    1411: 78       DEC   A
    1412: BF F3    JNZ   0x1406
    1414: 51 18    MOV   A,[__r3]
    1416: 53 1A    MOV   [__r1],A
    1418: 51 19    MOV   A,[__r2]
    141A: 53 1B    MOV   [__r0],A
    141C: 52 F4    MOV   A,[X-12]
    141E: 04 1A    ADD   [__r1],A
    1420: 52 F3    MOV   A,[X-13]
    1422: 0C 1B    ADC   [__r0],A
    1424: 52 1C    MOV   A,[X+28]
    1426: 08       PUSH  A
    1427: 52 1D    MOV   A,[X+29]
    1429: 08       PUSH  A
    142A: 52 1E    MOV   A,[X+30]
    142C: 08       PUSH  A
    142D: 52 1F    MOV   A,[X+31]
    142F: 08       PUSH  A
    1430: 7C 24 6D LCALL __long2fp
    1433: 18       POP   A
    1434: 53 14    MOV   [__r7],A
    1436: 18       POP   A
    1437: 53 15    MOV   [__r6],A
    1439: 18       POP   A
    143A: 53 16    MOV   [__r5],A
    143C: 18       POP   A
    143D: 53 17    MOV   [__r4],A
    143F: 51 1B    MOV   A,[__r0]
    1441: 60 D4    MOV   REG[212],A
    1443: 3E 1A    MVI   A,[__r1]
    1445: 53 13    MOV   [__r8],A
    1447: 3E 1A    MVI   A,[__r1]
    1449: 53 12    MOV   [__r9],A
    144B: 3E 1A    MVI   A,[__r1]
    144D: 53 11    MOV   [__r10],A
    144F: 3E 1A    MVI   A,[__r1]
    1451: 16 1A 04 SUB   [__r1],4
    1454: 53 10    MOV   [__r11],A
    1456: 51 17    MOV   A,[__r4]
    1458: 08       PUSH  A
    1459: 51 16    MOV   A,[__r5]
    145B: 08       PUSH  A
    145C: 51 15    MOV   A,[__r6]
    145E: 08       PUSH  A
    145F: 51 14    MOV   A,[__r7]
    1461: 08       PUSH  A
    1462: 51 13    MOV   A,[__r8]
    1464: 08       PUSH  A
    1465: 51 12    MOV   A,[__r9]
    1467: 08       PUSH  A
    1468: 51 11    MOV   A,[__r10]
    146A: 08       PUSH  A
    146B: 51 10    MOV   A,[__r11]
    146D: 08       PUSH  A
    146E: 7C 22 83 LCALL __fpdiv
    1471: 18       POP   A
    1472: 53 14    MOV   [__r7],A
    1474: 18       POP   A
    1475: 53 15    MOV   [__r6],A
    1477: 18       POP   A
    1478: 53 16    MOV   [__r5],A
    147A: 18       POP   A
    147B: 53 17    MOV   [__r4],A
    147D: 38 FC    ADD   SP,252
    147F: 51 1B    MOV   A,[__r0]
    1481: 60 D5    MOV   REG[213],A
    1483: 51 17    MOV   A,[__r4]
    1485: 3F 1A    MVI   [__r1],A
    1487: 51 16    MOV   A,[__r5]
    1489: 3F 1A    MVI   [__r1],A
    148B: 51 15    MOV   A,[__r6]
    148D: 3F 1A    MVI   [__r1],A
    148F: 51 14    MOV   A,[__r7]
    1491: 3F 1A    MVI   [__r1],A
    1493: 07 03 01 ADD   [X+3],1
    1496: 0F 02 00 ADC   [X+2],0
    1499: 0F 01 00 ADC   [X+1],0
    149C: 0F 00 00 ADC   [X+0],0
    149F: 52 03    MOV   A,[X+3]
    14A1: 13 1F    SUB   A,[X+31]
    14A3: 52 02    MOV   A,[X+2]
    14A5: 1B 1E    SBB   A,[X+30]
    14A7: 52 01    MOV   A,[X+1]
    14A9: 1B 1D    SBB   A,[X+29]
    14AB: 52 1C    MOV   A,[X+28]
    14AD: 31 80    XOR   A,128
    14AF: 62 D0 00 MOV   REG[208],0
    14B2: 53 0F    MOV   [__rX],A
    14B4: 52 00    MOV   A,[X+0]
    14B6: 31 80    XOR   A,128
    14B8: 1A 0F    SBB   A,[__rX]
    14BA: CE 97    JC    0x1352
(0080)       }
(0081)    }
(0082)    
(0083)    for(i=0;i<N_points;i++)
    14BC: 56 00 00 MOV   [X+0],0
    14BF: 56 01 00 MOV   [X+1],0
    14C2: 56 02 00 MOV   [X+2],0
    14C5: 56 03 00 MOV   [X+3],0
(0084)    /* Absolute value */
(0085)    mod[i]=sqrt((data_re[i]*data_re[i])+(data_imm[i]*data_imm[i]))/N_points;   
    14C8: 62 D0 00 MOV   REG[208],0
    14CB: 52 00    MOV   A,[X+0]
    14CD: 53 1B    MOV   [__r0],A
    14CF: 52 01    MOV   A,[X+1]
    14D1: 53 1A    MOV   [__r1],A
    14D3: 52 02    MOV   A,[X+2]
    14D5: 53 19    MOV   [__r2],A
    14D7: 52 03    MOV   A,[X+3]
    14D9: 53 18    MOV   [__r3],A
    14DB: 50 02    MOV   A,2
    14DD: 62 D0 00 MOV   REG[208],0
    14E0: 65 18    ASL   [__r3]
    14E2: 6B 19    RLC   [__r2]
    14E4: 6B 1A    RLC   [__r1]
    14E6: 6B 1B    RLC   [__r0]
    14E8: 78       DEC   A
    14E9: BF F3    JNZ   0x14DD
    14EB: 51 18    MOV   A,[__r3]
    14ED: 53 1A    MOV   [__r1],A
    14EF: 51 19    MOV   A,[__r2]
    14F1: 53 1B    MOV   [__r0],A
    14F3: 51 1A    MOV   A,[__r1]
    14F5: 54 49    MOV   [X+73],A
    14F7: 51 1B    MOV   A,[__r0]
    14F9: 54 48    MOV   [X+72],A
    14FB: 51 1A    MOV   A,[__r1]
    14FD: 01 00    ADD   A,0
    14FF: 53 18    MOV   [__r3],A
    1501: 51 1B    MOV   A,[__r0]
    1503: 09 03    ADC   A,3
    1505: 60 D4    MOV   REG[212],A
    1507: 3E 18    MVI   A,[__r3]
    1509: 53 17    MOV   [__r4],A
    150B: 3E 18    MVI   A,[__r3]
    150D: 53 16    MOV   [__r5],A
    150F: 3E 18    MVI   A,[__r3]
    1511: 53 15    MOV   [__r6],A
    1513: 3E 18    MVI   A,[__r3]
    1515: 53 14    MOV   [__r7],A
    1517: 51 1A    MOV   A,[__r1]
    1519: 01 00    ADD   A,0
    151B: 53 18    MOV   [__r3],A
    151D: 51 1B    MOV   A,[__r0]
    151F: 09 01    ADC   A,1
    1521: 60 D4    MOV   REG[212],A
    1523: 3E 18    MVI   A,[__r3]
    1525: 53 13    MOV   [__r8],A
    1527: 3E 18    MVI   A,[__r3]
    1529: 53 12    MOV   [__r9],A
    152B: 3E 18    MVI   A,[__r3]
    152D: 53 11    MOV   [__r10],A
    152F: 3E 18    MVI   A,[__r3]
    1531: 53 10    MOV   [__r11],A
    1533: 51 13    MOV   A,[__r8]
    1535: 08       PUSH  A
    1536: 51 12    MOV   A,[__r9]
    1538: 08       PUSH  A
    1539: 51 11    MOV   A,[__r10]
    153B: 08       PUSH  A
    153C: 51 10    MOV   A,[__r11]
    153E: 08       PUSH  A
    153F: 51 13    MOV   A,[__r8]
    1541: 08       PUSH  A
    1542: 51 12    MOV   A,[__r9]
    1544: 08       PUSH  A
    1545: 51 11    MOV   A,[__r10]
    1547: 08       PUSH  A
    1548: 51 10    MOV   A,[__r11]
    154A: 08       PUSH  A
    154B: 7C 21 9A LCALL __fpmul
    154E: 18       POP   A
    154F: 53 10    MOV   [__r11],A
    1551: 18       POP   A
    1552: 53 11    MOV   [__r10],A
    1554: 18       POP   A
    1555: 53 12    MOV   [__r9],A
    1557: 18       POP   A
    1558: 53 13    MOV   [__r8],A
    155A: 38 FC    ADD   SP,252
    155C: 51 17    MOV   A,[__r4]
    155E: 08       PUSH  A
    155F: 51 16    MOV   A,[__r5]
    1561: 08       PUSH  A
    1562: 51 15    MOV   A,[__r6]
    1564: 08       PUSH  A
    1565: 51 14    MOV   A,[__r7]
    1567: 08       PUSH  A
    1568: 51 17    MOV   A,[__r4]
    156A: 08       PUSH  A
    156B: 51 16    MOV   A,[__r5]
    156D: 08       PUSH  A
    156E: 51 15    MOV   A,[__r6]
    1570: 08       PUSH  A
    1571: 51 14    MOV   A,[__r7]
    1573: 08       PUSH  A
    1574: 7C 21 9A LCALL __fpmul
    1577: 18       POP   A
    1578: 53 14    MOV   [__r7],A
    157A: 18       POP   A
    157B: 53 15    MOV   [__r6],A
    157D: 18       POP   A
    157E: 53 16    MOV   [__r5],A
    1580: 18       POP   A
    1581: 53 17    MOV   [__r4],A
    1583: 38 FC    ADD   SP,252
    1585: 51 13    MOV   A,[__r8]
    1587: 08       PUSH  A
    1588: 51 12    MOV   A,[__r9]
    158A: 08       PUSH  A
    158B: 51 11    MOV   A,[__r10]
    158D: 08       PUSH  A
    158E: 51 10    MOV   A,[__r11]
    1590: 08       PUSH  A
    1591: 51 17    MOV   A,[__r4]
    1593: 08       PUSH  A
    1594: 51 16    MOV   A,[__r5]
    1596: 08       PUSH  A
    1597: 51 15    MOV   A,[__r6]
    1599: 08       PUSH  A
    159A: 51 14    MOV   A,[__r7]
    159C: 08       PUSH  A
    159D: 7C 20 B6 LCALL __fpadd
    15A0: 18       POP   A
    15A1: 53 14    MOV   [__r7],A
    15A3: 18       POP   A
    15A4: 53 15    MOV   [__r6],A
    15A6: 18       POP   A
    15A7: 53 16    MOV   [__r5],A
    15A9: 18       POP   A
    15AA: 38 FC    ADD   SP,252
    15AC: 08       PUSH  A
    15AD: 51 16    MOV   A,[__r5]
    15AF: 08       PUSH  A
    15B0: 51 15    MOV   A,[__r6]
    15B2: 08       PUSH  A
    15B3: 51 14    MOV   A,[__r7]
    15B5: 08       PUSH  A
    15B6: 7C 29 C9 LCALL _sqrt
    15B9: 38 FC    ADD   SP,252
    15BB: 62 D0 00 MOV   REG[208],0
    15BE: 50 42    MOV   A,66
    15C0: 08       PUSH  A
    15C1: 50 80    MOV   A,128
    15C3: 08       PUSH  A
    15C4: 50 00    MOV   A,0
    15C6: 08       PUSH  A
    15C7: 08       PUSH  A
    15C8: 51 1B    MOV   A,[__r0]
    15CA: 08       PUSH  A
    15CB: 51 1A    MOV   A,[__r1]
    15CD: 08       PUSH  A
    15CE: 51 19    MOV   A,[__r2]
    15D0: 08       PUSH  A
    15D1: 51 18    MOV   A,[__r3]
    15D3: 08       PUSH  A
    15D4: 7C 22 83 LCALL __fpdiv
    15D7: 18       POP   A
    15D8: 53 18    MOV   [__r3],A
    15DA: 18       POP   A
    15DB: 53 19    MOV   [__r2],A
    15DD: 18       POP   A
    15DE: 53 1A    MOV   [__r1],A
    15E0: 18       POP   A
    15E1: 53 1B    MOV   [__r0],A
    15E3: 38 FC    ADD   SP,252
    15E5: 52 49    MOV   A,[X+73]
    15E7: 01 00    ADD   A,0
    15E9: 53 16    MOV   [__r5],A
    15EB: 52 48    MOV   A,[X+72]
    15ED: 09 02    ADC   A,2
    15EF: 60 D5    MOV   REG[213],A
    15F1: 51 1B    MOV   A,[__r0]
    15F3: 3F 16    MVI   [__r5],A
    15F5: 51 1A    MOV   A,[__r1]
    15F7: 3F 16    MVI   [__r5],A
    15F9: 51 19    MOV   A,[__r2]
    15FB: 3F 16    MVI   [__r5],A
    15FD: 51 18    MOV   A,[__r3]
    15FF: 3F 16    MVI   [__r5],A
    1601: 07 03 01 ADD   [X+3],1
    1604: 0F 02 00 ADC   [X+2],0
    1607: 0F 01 00 ADC   [X+1],0
    160A: 0F 00 00 ADC   [X+0],0
    160D: 52 03    MOV   A,[X+3]
    160F: 11 40    SUB   A,64
    1611: 52 02    MOV   A,[X+2]
    1613: 19 00    SBB   A,0
    1615: 52 01    MOV   A,[X+1]
    1617: 19 00    SBB   A,0
    1619: 52 00    MOV   A,[X+0]
    161B: 31 80    XOR   A,128
    161D: 19 80    SBB   A,128
    161F: CE A8    JC    0x14C8
(0086) }    1621: 38 B6    ADD   SP,182
    1623: 20       POP   X
    1624: 7F       RET   
FILE: .\main.c
(0001) //----------------------------------------------------------------------------
(0002) // VC1 provides a sample clock of 3 MHz to the DELTA_SIGMA-11bit, 
(0003) // resulting in a sample rate of 7.8 Ksamples per second. 
(0004) // VC3 generates the baud clock for the UART by dividing 24 MHz by 156. The UART internally 
(0005) // divides VC3 by 8 resulting in a baud rate of 19,200 bps. The serial data is 
(0006) // sent as ASCII text with 1 start bit, 8 data bits, 1 stop bit and no parity. 
(0007) // This data may be monitored using most terminal software. 
(0008) //
(0009) //
(0010) // PSoCEval1 Connections:
(0011) //      port0_pin1 -> External Signal = ADC Input (0-Vdd)
(0012) //      port1_pin6 -> RX = RS232 RX
(0013) //      port2_pin7 -> TX = RS232 TX
(0014) //
(0015) //-----------------------------------------------------------------------------
(0016) 
(0017) 
(0018) #include <m8c.h>                         // part specific constants and macros
(0019) #include "PSoCAPI.h"                     // PSoC API definitions for all User Modules
(0020) #include "stdlib.h"
(0021) #include "fft.h"                     // PSoC API definitions for all User Modules
(0022) 	
(0023) #define RESOLUTION 12                    // ADC resolution
(0024) #define SCALE_BG  (( 1 << RESOLUTION)/55) // BarGraph scale factor
(0025) 
(0026) int  iResult;                            // ADC result variable
(0027) char df[4];
(0028) double max,zero=0;
(0029) unsigned int i=0;         //index
(0030) unsigned int ind;         
(0031) unsigned int endl=65535;  //uart tag
(0032) 
(0033) 
(0034) // Delta-Sigma-11bit: 7.8 ksps
(0035) unsigned int N_samples=7800;
(0036) double  time;    // time record
(0037) double delta_f;  // frequency sampling interval
(0038) 
(0039) void UART_print_re_imm ()  //send REAL and IMAGINARY parts data
(0040) {  
(0041)      UART_1_CPutString("Real Part\t\tImaginary Part\n");
_UART_print_re_imm:
    1625: 10       PUSH  X
    1626: 50 01    MOV   A,1
    1628: 08       PUSH  A
    1629: 50 6E    MOV   A,110
    162B: 5C       MOV   X,A
    162C: 18       POP   A
    162D: 7C 04 E1 LCALL 0x04E1
    1630: 20       POP   X
(0042)      for(i=0;i<N_points;i++)
    1631: 62 D0 00 MOV   REG[208],0
    1634: 55 31 00 MOV   [i+1],0
    1637: 55 30 00 MOV   [i],0
    163A: 80 B6    JMP   0x16F1
(0043)      {
(0044)        UART_1_PutSHexInt(data_re[i]);
    163C: 62 D0 00 MOV   REG[208],0
    163F: 51 31    MOV   A,[i+1]
    1641: 08       PUSH  A
    1642: 51 30    MOV   A,[i]
    1644: 62 D0 00 MOV   REG[208],0
    1647: 53 1B    MOV   [__r0],A
    1649: 18       POP   A
    164A: 53 1A    MOV   [__r1],A
    164C: 65 1A    ASL   [__r1]
    164E: 6B 1B    RLC   [__r0]
    1650: 65 1A    ASL   [__r1]
    1652: 6B 1B    RLC   [__r0]
    1654: 06 1A 00 ADD   [__r1],0
    1657: 0E 1B 03 ADC   [__r0],3
    165A: 51 1B    MOV   A,[__r0]
    165C: 60 D4    MOV   REG[212],A
    165E: 3E 1A    MVI   A,[__r1]
    1660: 53 17    MOV   [__r4],A
    1662: 3E 1A    MVI   A,[__r1]
    1664: 53 16    MOV   [__r5],A
    1666: 3E 1A    MVI   A,[__r1]
    1668: 53 15    MOV   [__r6],A
    166A: 3E 1A    MVI   A,[__r1]
    166C: 53 14    MOV   [__r7],A
    166E: 51 17    MOV   A,[__r4]
    1670: 08       PUSH  A
    1671: 51 16    MOV   A,[__r5]
    1673: 08       PUSH  A
    1674: 51 15    MOV   A,[__r6]
    1676: 08       PUSH  A
    1677: 51 14    MOV   A,[__r7]
    1679: 08       PUSH  A
    167A: 7C 23 EB LCALL __fp2long
    167D: 18       POP   A
    167E: 53 1A    MOV   [__r1],A
    1680: 18       POP   A
    1681: 38 FE    ADD   SP,254
    1683: 10       PUSH  X
    1684: 08       PUSH  A
    1685: 51 1A    MOV   A,[__r1]
    1687: 20       POP   X
    1688: 7C 04 37 LCALL 0x0437
(0045)         UART_1_CPutString("\t\t");
    168B: 50 01    MOV   A,1
    168D: 08       PUSH  A
    168E: 50 6B    MOV   A,107
    1690: 5C       MOV   X,A
    1691: 18       POP   A
    1692: 7C 04 E1 LCALL 0x04E1
    1695: 20       POP   X
(0046)         UART_1_PutSHexInt(data_imm[i]);
    1696: 62 D0 00 MOV   REG[208],0
    1699: 51 31    MOV   A,[i+1]
    169B: 08       PUSH  A
    169C: 51 30    MOV   A,[i]
    169E: 62 D0 00 MOV   REG[208],0
    16A1: 53 1B    MOV   [__r0],A
    16A3: 18       POP   A
    16A4: 53 1A    MOV   [__r1],A
    16A6: 65 1A    ASL   [__r1]
    16A8: 6B 1B    RLC   [__r0]
    16AA: 65 1A    ASL   [__r1]
    16AC: 6B 1B    RLC   [__r0]
    16AE: 06 1A 00 ADD   [__r1],0
    16B1: 0E 1B 01 ADC   [__r0],1
    16B4: 51 1B    MOV   A,[__r0]
    16B6: 60 D4    MOV   REG[212],A
    16B8: 3E 1A    MVI   A,[__r1]
    16BA: 53 17    MOV   [__r4],A
    16BC: 3E 1A    MVI   A,[__r1]
    16BE: 53 16    MOV   [__r5],A
    16C0: 3E 1A    MVI   A,[__r1]
    16C2: 53 15    MOV   [__r6],A
    16C4: 3E 1A    MVI   A,[__r1]
    16C6: 53 14    MOV   [__r7],A
    16C8: 51 17    MOV   A,[__r4]
    16CA: 08       PUSH  A
    16CB: 51 16    MOV   A,[__r5]
    16CD: 08       PUSH  A
    16CE: 51 15    MOV   A,[__r6]
    16D0: 08       PUSH  A
    16D1: 51 14    MOV   A,[__r7]
    16D3: 08       PUSH  A
    16D4: 7C 23 EB LCALL __fp2long
    16D7: 18       POP   A
    16D8: 53 1A    MOV   [__r1],A
    16DA: 18       POP   A
    16DB: 38 FE    ADD   SP,254
    16DD: 10       PUSH  X
    16DE: 08       PUSH  A
    16DF: 51 1A    MOV   A,[__r1]
    16E1: 20       POP   X
    16E2: 7C 04 37 LCALL 0x0437
(0047)       UART_1_PutCRLF();  
    16E5: 7C 04 F3 LCALL 0x04F3
    16E8: 20       POP   X
    16E9: 62 D0 00 MOV   REG[208],0
    16EC: 76 31    INC   [i+1]
    16EE: 0E 30 00 ADC   [i],0
    16F1: 62 D0 00 MOV   REG[208],0
    16F4: 51 31    MOV   A,[i+1]
    16F6: 11 40    SUB   A,64
    16F8: 51 30    MOV   A,[i]
    16FA: 19 00    SBB   A,0
    16FC: CF 3F    JC    0x163C
(0048)       }
(0049)     }
    16FE: 7F       RET   
(0050) 
(0051) void UART_print_mod ()    //send ABSOLUTE VALUE data
(0052) {
(0053)    UART_1_PutSHexInt(0);
_UART_print_mod:
    16FF: 10       PUSH  X
    1700: 50 00    MOV   A,0
    1702: 5C       MOV   X,A
    1703: 7C 04 37 LCALL 0x0437
    1706: 20       POP   X
(0054)    for(i=0;i<N_points;i++)
    1707: 62 D0 00 MOV   REG[208],0
    170A: 55 31 00 MOV   [i+1],0
    170D: 55 30 00 MOV   [i],0
    1710: 80 59    JMP   0x176A
(0055)    {
(0056)    UART_1_PutSHexInt(mod[i]);
    1712: 62 D0 00 MOV   REG[208],0
    1715: 51 31    MOV   A,[i+1]
    1717: 08       PUSH  A
    1718: 51 30    MOV   A,[i]
    171A: 62 D0 00 MOV   REG[208],0
    171D: 53 1B    MOV   [__r0],A
    171F: 18       POP   A
    1720: 53 1A    MOV   [__r1],A
    1722: 65 1A    ASL   [__r1]
    1724: 6B 1B    RLC   [__r0]
    1726: 65 1A    ASL   [__r1]
    1728: 6B 1B    RLC   [__r0]
    172A: 06 1A 00 ADD   [__r1],0
    172D: 0E 1B 02 ADC   [__r0],2
    1730: 51 1B    MOV   A,[__r0]
    1732: 60 D4    MOV   REG[212],A
    1734: 3E 1A    MVI   A,[__r1]
    1736: 53 17    MOV   [__r4],A
    1738: 3E 1A    MVI   A,[__r1]
    173A: 53 16    MOV   [__r5],A
    173C: 3E 1A    MVI   A,[__r1]
    173E: 53 15    MOV   [__r6],A
    1740: 3E 1A    MVI   A,[__r1]
    1742: 53 14    MOV   [__r7],A
    1744: 51 17    MOV   A,[__r4]
    1746: 08       PUSH  A
    1747: 51 16    MOV   A,[__r5]
    1749: 08       PUSH  A
    174A: 51 15    MOV   A,[__r6]
    174C: 08       PUSH  A
    174D: 51 14    MOV   A,[__r7]
    174F: 08       PUSH  A
    1750: 7C 23 EB LCALL __fp2long
    1753: 18       POP   A
    1754: 53 1A    MOV   [__r1],A
    1756: 18       POP   A
    1757: 38 FE    ADD   SP,254
    1759: 10       PUSH  X
    175A: 08       PUSH  A
    175B: 51 1A    MOV   A,[__r1]
    175D: 20       POP   X
    175E: 7C 04 37 LCALL 0x0437
    1761: 20       POP   X
    1762: 62 D0 00 MOV   REG[208],0
    1765: 76 31    INC   [i+1]
    1767: 0E 30 00 ADC   [i],0
    176A: 62 D0 00 MOV   REG[208],0
    176D: 51 31    MOV   A,[i+1]
    176F: 11 40    SUB   A,64
    1771: 51 30    MOV   A,[i]
    1773: 19 00    SBB   A,0
    1775: CF 9C    JC    0x1712
(0057)    }
(0058)    UART_1_PutSHexInt(endl);
    1777: 10       PUSH  X
    1778: 62 D0 00 MOV   REG[208],0
    177B: 51 36    MOV   A,[endl]
    177D: 08       PUSH  A
    177E: 51 37    MOV   A,[endl+1]
    1780: 20       POP   X
    1781: 7C 04 37 LCALL 0x0437
(0059)    UART_1_PutCRLF();   
    1784: 7C 04 F3 LCALL 0x04F3
    1787: 20       POP   X
(0060) }
    1788: 7F       RET   
(0061) 
(0062) void UART_print_data ()   // send REAL data
(0063) {
(0064)    UART_1_CPutString("Data init\n"); // Example string
_UART_print_data:
    1789: 10       PUSH  X
    178A: 50 01    MOV   A,1
    178C: 08       PUSH  A
    178D: 50 60    MOV   A,96
    178F: 5C       MOV   X,A
    1790: 18       POP   A
    1791: 7C 04 E1 LCALL 0x04E1
    1794: 20       POP   X
(0065)     
(0066)    for (i=0;i<N_points;i++)
    1795: 62 D0 00 MOV   REG[208],0
    1798: 55 31 00 MOV   [i+1],0
    179B: 55 30 00 MOV   [i],0
    179E: 80 5C    JMP   0x17FB
(0067)    {
(0068)    UART_1_PutSHexInt(data_re[i]);
    17A0: 62 D0 00 MOV   REG[208],0
    17A3: 51 31    MOV   A,[i+1]
    17A5: 08       PUSH  A
    17A6: 51 30    MOV   A,[i]
    17A8: 62 D0 00 MOV   REG[208],0
    17AB: 53 1B    MOV   [__r0],A
    17AD: 18       POP   A
    17AE: 53 1A    MOV   [__r1],A
    17B0: 65 1A    ASL   [__r1]
    17B2: 6B 1B    RLC   [__r0]
    17B4: 65 1A    ASL   [__r1]
    17B6: 6B 1B    RLC   [__r0]
    17B8: 06 1A 00 ADD   [__r1],0
    17BB: 0E 1B 03 ADC   [__r0],3
    17BE: 51 1B    MOV   A,[__r0]
    17C0: 60 D4    MOV   REG[212],A
    17C2: 3E 1A    MVI   A,[__r1]
    17C4: 53 17    MOV   [__r4],A
    17C6: 3E 1A    MVI   A,[__r1]
    17C8: 53 16    MOV   [__r5],A
    17CA: 3E 1A    MVI   A,[__r1]
    17CC: 53 15    MOV   [__r6],A
    17CE: 3E 1A    MVI   A,[__r1]
    17D0: 53 14    MOV   [__r7],A
    17D2: 51 17    MOV   A,[__r4]
    17D4: 08       PUSH  A
    17D5: 51 16    MOV   A,[__r5]
    17D7: 08       PUSH  A
    17D8: 51 15    MOV   A,[__r6]
    17DA: 08       PUSH  A
    17DB: 51 14    MOV   A,[__r7]
    17DD: 08       PUSH  A
    17DE: 7C 23 EB LCALL __fp2long
    17E1: 18       POP   A
    17E2: 53 1A    MOV   [__r1],A
    17E4: 18       POP   A
    17E5: 38 FE    ADD   SP,254
    17E7: 10       PUSH  X
    17E8: 08       PUSH  A
    17E9: 51 1A    MOV   A,[__r1]
    17EB: 20       POP   X
    17EC: 7C 04 37 LCALL 0x0437
(0069)    UART_1_PutCRLF();
    17EF: 7C 04 F3 LCALL 0x04F3
    17F2: 20       POP   X
    17F3: 62 D0 00 MOV   REG[208],0
    17F6: 76 31    INC   [i+1]
    17F8: 0E 30 00 ADC   [i],0
    17FB: 62 D0 00 MOV   REG[208],0
    17FE: 51 31    MOV   A,[i+1]
    1800: 11 40    SUB   A,64
    1802: 51 30    MOV   A,[i]
    1804: 19 00    SBB   A,0
    1806: CF 99    JC    0x17A0
(0070)    }
(0071) 
(0072) }
    1808: 7F       RET   
(0073) 
(0074) void LCD_print()
(0075) {         
(0076) 	/* find the fundamental harmonic (except the zero component)*/
(0077)         max=mod[0];        
_LCD_print:
    1809: 62 D0 02 MOV   REG[208],2
    180C: 51 00    MOV   A,[mod]
    180E: 08       PUSH  A
    180F: 51 01    MOV   A,[mod+1]
    1811: 08       PUSH  A
    1812: 51 02    MOV   A,[mod+2]
    1814: 08       PUSH  A
    1815: 51 03    MOV   A,[mod+3]
    1817: 62 D0 00 MOV   REG[208],0
    181A: 53 2F    MOV   [max+3],A
    181C: 18       POP   A
    181D: 53 2E    MOV   [max+2],A
    181F: 18       POP   A
    1820: 53 2D    MOV   [max+1],A
    1822: 18       POP   A
    1823: 53 2C    MOV   [max],A
(0078)         ind=0;
    1825: 62 D0 00 MOV   REG[208],0
    1828: 55 35 00 MOV   [ind+1],0
    182B: 55 34 00 MOV   [ind],0
(0079)         for(i=1;i<N_points/2;i++)
    182E: 62 D0 00 MOV   REG[208],0
    1831: 55 31 01 MOV   [i+1],1
    1834: 55 30 00 MOV   [i],0
    1837: 80 BD    JMP   0x18F5
(0080)         	if(mod[i]>max)
    1839: 62 D0 00 MOV   REG[208],0
    183C: 51 31    MOV   A,[i+1]
    183E: 08       PUSH  A
    183F: 51 30    MOV   A,[i]
    1841: 62 D0 00 MOV   REG[208],0
    1844: 53 1B    MOV   [__r0],A
    1846: 18       POP   A
    1847: 53 1A    MOV   [__r1],A
    1849: 65 1A    ASL   [__r1]
    184B: 6B 1B    RLC   [__r0]
    184D: 65 1A    ASL   [__r1]
    184F: 6B 1B    RLC   [__r0]
    1851: 06 1A 00 ADD   [__r1],0
    1854: 0E 1B 02 ADC   [__r0],2
    1857: 51 1B    MOV   A,[__r0]
    1859: 60 D4    MOV   REG[212],A
    185B: 3E 1A    MVI   A,[__r1]
    185D: 53 17    MOV   [__r4],A
    185F: 3E 1A    MVI   A,[__r1]
    1861: 53 16    MOV   [__r5],A
    1863: 3E 1A    MVI   A,[__r1]
    1865: 53 15    MOV   [__r6],A
    1867: 3E 1A    MVI   A,[__r1]
    1869: 53 14    MOV   [__r7],A
    186B: 62 D0 00 MOV   REG[208],0
    186E: 51 2C    MOV   A,[max]
    1870: 08       PUSH  A
    1871: 51 2D    MOV   A,[max+1]
    1873: 08       PUSH  A
    1874: 51 2E    MOV   A,[max+2]
    1876: 08       PUSH  A
    1877: 51 2F    MOV   A,[max+3]
    1879: 08       PUSH  A
    187A: 62 D0 00 MOV   REG[208],0
    187D: 51 17    MOV   A,[__r4]
    187F: 08       PUSH  A
    1880: 51 16    MOV   A,[__r5]
    1882: 08       PUSH  A
    1883: 51 15    MOV   A,[__r6]
    1885: 08       PUSH  A
    1886: 51 14    MOV   A,[__r7]
    1888: 08       PUSH  A
    1889: 7C 23 8C LCALL __fpcmp
    188C: 38 F8    ADD   SP,248
    188E: 39 00    CMP   A,0
    1890: A0 5C    JZ    0x18ED
    1892: 39 01    CMP   A,1
    1894: B0 58    JNZ   0x18ED
(0081)         		{
(0082)         		  max=mod[i];
    1896: 62 D0 00 MOV   REG[208],0
    1899: 51 31    MOV   A,[i+1]
    189B: 08       PUSH  A
    189C: 51 30    MOV   A,[i]
    189E: 62 D0 00 MOV   REG[208],0
    18A1: 53 1B    MOV   [__r0],A
    18A3: 18       POP   A
    18A4: 53 1A    MOV   [__r1],A
    18A6: 65 1A    ASL   [__r1]
    18A8: 6B 1B    RLC   [__r0]
    18AA: 65 1A    ASL   [__r1]
    18AC: 6B 1B    RLC   [__r0]
    18AE: 06 1A 00 ADD   [__r1],0
    18B1: 0E 1B 02 ADC   [__r0],2
    18B4: 51 1B    MOV   A,[__r0]
    18B6: 60 D4    MOV   REG[212],A
    18B8: 3E 1A    MVI   A,[__r1]
    18BA: 62 D0 00 MOV   REG[208],0
    18BD: 53 2C    MOV   [max],A
    18BF: 62 D0 00 MOV   REG[208],0
    18C2: 3E 1A    MVI   A,[__r1]
    18C4: 62 D0 00 MOV   REG[208],0
    18C7: 53 2D    MOV   [max+1],A
    18C9: 62 D0 00 MOV   REG[208],0
    18CC: 3E 1A    MVI   A,[__r1]
    18CE: 62 D0 00 MOV   REG[208],0
    18D1: 53 2E    MOV   [max+2],A
    18D3: 62 D0 00 MOV   REG[208],0
    18D6: 3E 1A    MVI   A,[__r1]
    18D8: 62 D0 00 MOV   REG[208],0
    18DB: 53 2F    MOV   [max+3],A
(0083)         		  ind=i;
    18DD: 62 D0 00 MOV   REG[208],0
    18E0: 51 31    MOV   A,[i+1]
    18E2: 08       PUSH  A
    18E3: 51 30    MOV   A,[i]
    18E5: 62 D0 00 MOV   REG[208],0
    18E8: 53 34    MOV   [ind],A
    18EA: 18       POP   A
    18EB: 53 35    MOV   [ind+1],A
    18ED: 62 D0 00 MOV   REG[208],0
    18F0: 76 31    INC   [i+1]
    18F2: 0E 30 00 ADC   [i],0
    18F5: 62 D0 00 MOV   REG[208],0
    18F8: 51 31    MOV   A,[i+1]
    18FA: 11 20    SUB   A,32
    18FC: 51 30    MOV   A,[i]
    18FE: 19 00    SBB   A,0
    1900: CF 38    JC    0x1839
(0084)          		 }
(0085)         		
(0086)         itoa(df,(int)(max),10);
    1902: 50 00    MOV   A,0
    1904: 08       PUSH  A
    1905: 50 0A    MOV   A,10
    1907: 08       PUSH  A
    1908: 62 D0 00 MOV   REG[208],0
    190B: 51 2C    MOV   A,[max]
    190D: 08       PUSH  A
    190E: 51 2D    MOV   A,[max+1]
    1910: 08       PUSH  A
    1911: 51 2E    MOV   A,[max+2]
    1913: 08       PUSH  A
    1914: 51 2F    MOV   A,[max+3]
    1916: 08       PUSH  A
    1917: 62 D0 00 MOV   REG[208],0
    191A: 7C 23 EB LCALL __fp2long
    191D: 18       POP   A
    191E: 53 1A    MOV   [__r1],A
    1920: 18       POP   A
    1921: 38 FE    ADD   SP,254
    1923: 08       PUSH  A
    1924: 51 1A    MOV   A,[__r1]
    1926: 08       PUSH  A
    1927: 50 00    MOV   A,0
    1929: 08       PUSH  A
    192A: 50 28    MOV   A,40
    192C: 08       PUSH  A
    192D: 7C 24 D7 LCALL _itoa
    1930: 38 FA    ADD   SP,250
(0087)         LCD_1_Position(1,0);
    1932: 10       PUSH  X
    1933: 57 00    MOV   X,0
    1935: 50 01    MOV   A,1
    1937: 7C 06 BC LCALL 0x06BC
(0088)         LCD_1_PrString(df);
    193A: 50 00    MOV   A,0
    193C: 08       PUSH  A
    193D: 50 28    MOV   A,40
    193F: 5C       MOV   X,A
    1940: 18       POP   A
    1941: 7C 05 78 LCALL 0x0578
    1944: 20       POP   X
(0089)         
(0090)         itoa(df,(int)(ind*delta_f),10);
    1945: 50 00    MOV   A,0
    1947: 08       PUSH  A
    1948: 50 0A    MOV   A,10
    194A: 08       PUSH  A
    194B: 62 D0 00 MOV   REG[208],0
    194E: 51 35    MOV   A,[ind+1]
    1950: 21 01    AND   A,1
    1952: 62 D0 00 MOV   REG[208],0
    1955: 53 1A    MOV   [__r1],A
    1957: 62 D0 00 MOV   REG[208],0
    195A: 51 34    MOV   A,[ind]
    195C: 21 00    AND   A,0
    195E: 62 D0 00 MOV   REG[208],0
    1961: 53 1B    MOV   [__r0],A
    1963: 51 1A    MOV   A,[__r1]
    1965: 53 18    MOV   [__r3],A
    1967: 51 1B    MOV   A,[__r0]
    1969: 53 19    MOV   [__r2],A
    196B: 47 19 80 TST   [__r2],128
    196E: A0 09    JZ    0x1978
    1970: 55 1A FF MOV   [__r1],255
    1973: 55 1B FF MOV   [__r0],255
    1976: 80 0A    JMP   0x1981
    1978: 62 D0 00 MOV   REG[208],0
    197B: 55 1A 00 MOV   [__r1],0
    197E: 55 1B 00 MOV   [__r0],0
    1981: 62 D0 00 MOV   REG[208],0
    1984: 51 1B    MOV   A,[__r0]
    1986: 08       PUSH  A
    1987: 51 1A    MOV   A,[__r1]
    1989: 08       PUSH  A
    198A: 51 19    MOV   A,[__r2]
    198C: 08       PUSH  A
    198D: 51 18    MOV   A,[__r3]
    198F: 08       PUSH  A
    1990: 7C 24 6D LCALL __long2fp
    1993: 18       POP   A
    1994: 53 18    MOV   [__r3],A
    1996: 18       POP   A
    1997: 53 19    MOV   [__r2],A
    1999: 18       POP   A
    199A: 53 1A    MOV   [__r1],A
    199C: 18       POP   A
    199D: 53 1B    MOV   [__r0],A
    199F: 62 D0 00 MOV   REG[208],0
    19A2: 51 35    MOV   A,[ind+1]
    19A4: 08       PUSH  A
    19A5: 51 34    MOV   A,[ind]
    19A7: 62 D0 00 MOV   REG[208],0
    19AA: 53 17    MOV   [__r4],A
    19AC: 18       POP   A
    19AD: 53 16    MOV   [__r5],A
    19AF: 70 FB    AND   F,251
    19B1: 6E 17    RRC   [__r4]
    19B3: 6E 16    RRC   [__r5]
    19B5: 51 16    MOV   A,[__r5]
    19B7: 53 14    MOV   [__r7],A
    19B9: 51 17    MOV   A,[__r4]
    19BB: 53 15    MOV   [__r6],A
    19BD: 47 15 80 TST   [__r6],128
    19C0: A0 09    JZ    0x19CA
    19C2: 55 16 FF MOV   [__r5],255
    19C5: 55 17 FF MOV   [__r4],255
    19C8: 80 0A    JMP   0x19D3
    19CA: 62 D0 00 MOV   REG[208],0
    19CD: 55 16 00 MOV   [__r5],0
    19D0: 55 17 00 MOV   [__r4],0
    19D3: 62 D0 00 MOV   REG[208],0
    19D6: 51 17    MOV   A,[__r4]
    19D8: 08       PUSH  A
    19D9: 51 16    MOV   A,[__r5]
    19DB: 08       PUSH  A
    19DC: 51 15    MOV   A,[__r6]
    19DE: 08       PUSH  A
    19DF: 51 14    MOV   A,[__r7]
    19E1: 08       PUSH  A
    19E2: 7C 24 6D LCALL __long2fp
    19E5: 18       POP   A
    19E6: 53 14    MOV   [__r7],A
    19E8: 18       POP   A
    19E9: 53 15    MOV   [__r6],A
    19EB: 18       POP   A
    19EC: 53 16    MOV   [__r5],A
    19EE: 18       POP   A
    19EF: 08       PUSH  A
    19F0: 51 16    MOV   A,[__r5]
    19F2: 08       PUSH  A
    19F3: 51 15    MOV   A,[__r6]
    19F5: 08       PUSH  A
    19F6: 51 14    MOV   A,[__r7]
    19F8: 08       PUSH  A
    19F9: 50 40    MOV   A,64
    19FB: 08       PUSH  A
    19FC: 50 00    MOV   A,0
    19FE: 08       PUSH  A
    19FF: 08       PUSH  A
    1A00: 08       PUSH  A
    1A01: 7C 21 9A LCALL __fpmul
    1A04: 18       POP   A
    1A05: 53 14    MOV   [__r7],A
    1A07: 18       POP   A
    1A08: 53 15    MOV   [__r6],A
    1A0A: 18       POP   A
    1A0B: 53 16    MOV   [__r5],A
    1A0D: 18       POP   A
    1A0E: 53 17    MOV   [__r4],A
    1A10: 38 FC    ADD   SP,252
    1A12: 51 1B    MOV   A,[__r0]
    1A14: 08       PUSH  A
    1A15: 51 1A    MOV   A,[__r1]
    1A17: 08       PUSH  A
    1A18: 51 19    MOV   A,[__r2]
    1A1A: 08       PUSH  A
    1A1B: 51 18    MOV   A,[__r3]
    1A1D: 08       PUSH  A
    1A1E: 51 17    MOV   A,[__r4]
    1A20: 08       PUSH  A
    1A21: 51 16    MOV   A,[__r5]
    1A23: 08       PUSH  A
    1A24: 51 15    MOV   A,[__r6]
    1A26: 08       PUSH  A
    1A27: 51 14    MOV   A,[__r7]
    1A29: 08       PUSH  A
    1A2A: 7C 20 B6 LCALL __fpadd
    1A2D: 18       POP   A
    1A2E: 53 18    MOV   [__r3],A
    1A30: 18       POP   A
    1A31: 53 19    MOV   [__r2],A
    1A33: 18       POP   A
    1A34: 53 1A    MOV   [__r1],A
    1A36: 18       POP   A
    1A37: 53 1B    MOV   [__r0],A
    1A39: 38 FC    ADD   SP,252
    1A3B: 62 D0 00 MOV   REG[208],0
    1A3E: 51 24    MOV   A,[delta_f]
    1A40: 08       PUSH  A
    1A41: 51 25    MOV   A,[delta_f+1]
    1A43: 08       PUSH  A
    1A44: 51 26    MOV   A,[delta_f+2]
    1A46: 08       PUSH  A
    1A47: 51 27    MOV   A,[delta_f+3]
    1A49: 08       PUSH  A
    1A4A: 62 D0 00 MOV   REG[208],0
    1A4D: 51 1B    MOV   A,[__r0]
    1A4F: 08       PUSH  A
    1A50: 51 1A    MOV   A,[__r1]
    1A52: 08       PUSH  A
    1A53: 51 19    MOV   A,[__r2]
    1A55: 08       PUSH  A
    1A56: 51 18    MOV   A,[__r3]
    1A58: 08       PUSH  A
    1A59: 7C 21 9A LCALL __fpmul
    1A5C: 18       POP   A
    1A5D: 53 18    MOV   [__r3],A
    1A5F: 18       POP   A
    1A60: 53 19    MOV   [__r2],A
    1A62: 18       POP   A
    1A63: 53 1A    MOV   [__r1],A
    1A65: 18       POP   A
    1A66: 38 FC    ADD   SP,252
    1A68: 08       PUSH  A
    1A69: 51 1A    MOV   A,[__r1]
    1A6B: 08       PUSH  A
    1A6C: 51 19    MOV   A,[__r2]
    1A6E: 08       PUSH  A
    1A6F: 51 18    MOV   A,[__r3]
    1A71: 08       PUSH  A
    1A72: 7C 23 EB LCALL __fp2long
    1A75: 18       POP   A
    1A76: 53 1A    MOV   [__r1],A
    1A78: 18       POP   A
    1A79: 38 FE    ADD   SP,254
    1A7B: 08       PUSH  A
    1A7C: 51 1A    MOV   A,[__r1]
    1A7E: 08       PUSH  A
    1A7F: 50 00    MOV   A,0
    1A81: 08       PUSH  A
    1A82: 50 28    MOV   A,40
    1A84: 08       PUSH  A
    1A85: 7C 24 D7 LCALL _itoa
    1A88: 38 FA    ADD   SP,250
(0091)         LCD_1_Position(1,6);
    1A8A: 10       PUSH  X
    1A8B: 57 06    MOV   X,6
    1A8D: 50 01    MOV   A,1
    1A8F: 7C 06 BC LCALL 0x06BC
(0092)         LCD_1_PrString(df);
    1A92: 50 00    MOV   A,0
    1A94: 08       PUSH  A
    1A95: 50 28    MOV   A,40
    1A97: 5C       MOV   X,A
    1A98: 18       POP   A
    1A99: 7C 05 78 LCALL 0x0578
(0093)         
(0094)         LCD_1_Position(1,11);
    1A9C: 57 0B    MOV   X,11
    1A9E: 50 01    MOV   A,1
    1AA0: 7C 06 BC LCALL 0x06BC
(0095)         LCD_1_PrCString("Hz");
    1AA3: 50 01    MOV   A,1
    1AA5: 08       PUSH  A
    1AA6: 50 5D    MOV   A,93
    1AA8: 5C       MOV   X,A
    1AA9: 18       POP   A
    1AAA: 7C 05 3C LCALL 0x053C
    1AAD: 20       POP   X
(0096) }
    1AAE: 7F       RET   
(0097) 
(0098) void main()
(0099) {
_main:
  bgPos                --> X+0
    1AAF: 10       PUSH  X
    1AB0: 4F       MOV   X,SP
    1AB1: 38 05    ADD   SP,5
(0100)     BYTE bgPos;                          // BarGraph position
(0101)    
(0102)     UART_1_Start(UART_PARITY_NONE);      // Enable UART
    1AB3: 10       PUSH  X
    1AB4: 50 00    MOV   A,0
    1AB6: 7C 03 CC LCALL 0x03CC
(0103)       
(0104)     PGA_1_Start(PGA_1_MEDPOWER);         // Turn on PGA power
    1AB9: 50 02    MOV   A,2
    1ABB: 7C 04 FC LCALL 0x04FC
(0105)     
(0106)     DELSIG11_1_Start( DELSIG11_1_HIGHPOWER );  
    1ABE: 50 03    MOV   A,3
    1AC0: 7C 08 2B LCALL 0x082B
(0107)     DELSIG11_1_StartAD(); 
    1AC3: 7C 08 41 LCALL 0x0841
    1AC6: 20       POP   X
(0108)     
(0109)     time=(double)N_points/N_samples;
    1AC7: 62 D0 00 MOV   REG[208],0
    1ACA: 51 33    MOV   A,[N_samples+1]
    1ACC: 21 01    AND   A,1
    1ACE: 62 D0 00 MOV   REG[208],0
    1AD1: 53 1A    MOV   [__r1],A
    1AD3: 62 D0 00 MOV   REG[208],0
    1AD6: 51 32    MOV   A,[N_samples]
    1AD8: 21 00    AND   A,0
    1ADA: 62 D0 00 MOV   REG[208],0
    1ADD: 53 1B    MOV   [__r0],A
    1ADF: 51 1A    MOV   A,[__r1]
    1AE1: 53 18    MOV   [__r3],A
    1AE3: 51 1B    MOV   A,[__r0]
    1AE5: 53 19    MOV   [__r2],A
    1AE7: 47 19 80 TST   [__r2],128
    1AEA: A0 09    JZ    0x1AF4
    1AEC: 55 1A FF MOV   [__r1],255
    1AEF: 55 1B FF MOV   [__r0],255
    1AF2: 80 0A    JMP   0x1AFD
    1AF4: 62 D0 00 MOV   REG[208],0
    1AF7: 55 1A 00 MOV   [__r1],0
    1AFA: 55 1B 00 MOV   [__r0],0
    1AFD: 62 D0 00 MOV   REG[208],0
    1B00: 51 1B    MOV   A,[__r0]
    1B02: 08       PUSH  A
    1B03: 51 1A    MOV   A,[__r1]
    1B05: 08       PUSH  A
    1B06: 51 19    MOV   A,[__r2]
    1B08: 08       PUSH  A
    1B09: 51 18    MOV   A,[__r3]
    1B0B: 08       PUSH  A
    1B0C: 7C 24 6D LCALL __long2fp
    1B0F: 18       POP   A
    1B10: 53 18    MOV   [__r3],A
    1B12: 18       POP   A
    1B13: 53 19    MOV   [__r2],A
    1B15: 18       POP   A
    1B16: 53 1A    MOV   [__r1],A
    1B18: 18       POP   A
    1B19: 53 1B    MOV   [__r0],A
    1B1B: 62 D0 00 MOV   REG[208],0
    1B1E: 51 33    MOV   A,[N_samples+1]
    1B20: 08       PUSH  A
    1B21: 51 32    MOV   A,[N_samples]
    1B23: 62 D0 00 MOV   REG[208],0
    1B26: 53 17    MOV   [__r4],A
    1B28: 18       POP   A
    1B29: 53 16    MOV   [__r5],A
    1B2B: 70 FB    AND   F,251
    1B2D: 6E 17    RRC   [__r4]
    1B2F: 6E 16    RRC   [__r5]
    1B31: 51 16    MOV   A,[__r5]
    1B33: 53 14    MOV   [__r7],A
    1B35: 51 17    MOV   A,[__r4]
    1B37: 53 15    MOV   [__r6],A
    1B39: 47 15 80 TST   [__r6],128
    1B3C: A0 09    JZ    0x1B46
    1B3E: 55 16 FF MOV   [__r5],255
    1B41: 55 17 FF MOV   [__r4],255
    1B44: 80 0A    JMP   0x1B4F
    1B46: 62 D0 00 MOV   REG[208],0
    1B49: 55 16 00 MOV   [__r5],0
    1B4C: 55 17 00 MOV   [__r4],0
    1B4F: 62 D0 00 MOV   REG[208],0
    1B52: 51 17    MOV   A,[__r4]
    1B54: 08       PUSH  A
    1B55: 51 16    MOV   A,[__r5]
    1B57: 08       PUSH  A
    1B58: 51 15    MOV   A,[__r6]
    1B5A: 08       PUSH  A
    1B5B: 51 14    MOV   A,[__r7]
    1B5D: 08       PUSH  A
    1B5E: 7C 24 6D LCALL __long2fp
    1B61: 18       POP   A
    1B62: 53 14    MOV   [__r7],A
    1B64: 18       POP   A
    1B65: 53 15    MOV   [__r6],A
    1B67: 18       POP   A
    1B68: 53 16    MOV   [__r5],A
    1B6A: 18       POP   A
    1B6B: 08       PUSH  A
    1B6C: 51 16    MOV   A,[__r5]
    1B6E: 08       PUSH  A
    1B6F: 51 15    MOV   A,[__r6]
    1B71: 08       PUSH  A
    1B72: 51 14    MOV   A,[__r7]
    1B74: 08       PUSH  A
    1B75: 50 40    MOV   A,64
    1B77: 08       PUSH  A
    1B78: 50 00    MOV   A,0
    1B7A: 08       PUSH  A
    1B7B: 08       PUSH  A
    1B7C: 08       PUSH  A
    1B7D: 7C 21 9A LCALL __fpmul
    1B80: 18       POP   A
    1B81: 53 14    MOV   [__r7],A
    1B83: 18       POP   A
    1B84: 53 15    MOV   [__r6],A
    1B86: 18       POP   A
    1B87: 53 16    MOV   [__r5],A
    1B89: 18       POP   A
    1B8A: 53 17    MOV   [__r4],A
    1B8C: 38 FC    ADD   SP,252
    1B8E: 51 1B    MOV   A,[__r0]
    1B90: 08       PUSH  A
    1B91: 51 1A    MOV   A,[__r1]
    1B93: 08       PUSH  A
    1B94: 51 19    MOV   A,[__r2]
    1B96: 08       PUSH  A
    1B97: 51 18    MOV   A,[__r3]
    1B99: 08       PUSH  A
    1B9A: 51 17    MOV   A,[__r4]
    1B9C: 08       PUSH  A
    1B9D: 51 16    MOV   A,[__r5]
    1B9F: 08       PUSH  A
    1BA0: 51 15    MOV   A,[__r6]
    1BA2: 08       PUSH  A
    1BA3: 51 14    MOV   A,[__r7]
    1BA5: 08       PUSH  A
    1BA6: 7C 20 B6 LCALL __fpadd
    1BA9: 18       POP   A
    1BAA: 53 18    MOV   [__r3],A
    1BAC: 18       POP   A
    1BAD: 53 19    MOV   [__r2],A
    1BAF: 18       POP   A
    1BB0: 53 1A    MOV   [__r1],A
    1BB2: 18       POP   A
    1BB3: 38 FC    ADD   SP,252
    1BB5: 08       PUSH  A
    1BB6: 51 1A    MOV   A,[__r1]
    1BB8: 08       PUSH  A
    1BB9: 51 19    MOV   A,[__r2]
    1BBB: 08       PUSH  A
    1BBC: 51 18    MOV   A,[__r3]
    1BBE: 08       PUSH  A
    1BBF: 50 42    MOV   A,66
    1BC1: 08       PUSH  A
    1BC2: 50 80    MOV   A,128
    1BC4: 08       PUSH  A
    1BC5: 50 00    MOV   A,0
    1BC7: 08       PUSH  A
    1BC8: 08       PUSH  A
    1BC9: 7C 22 83 LCALL __fpdiv
    1BCC: 18       POP   A
    1BCD: 62 D0 00 MOV   REG[208],0
    1BD0: 53 23    MOV   [time+3],A
    1BD2: 18       POP   A
    1BD3: 53 22    MOV   [time+2],A
    1BD5: 18       POP   A
    1BD6: 53 21    MOV   [time+1],A
    1BD8: 18       POP   A
    1BD9: 53 20    MOV   [time],A
    1BDB: 38 FC    ADD   SP,252
(0110)     delta_f=(double)1/time;
    1BDD: 51 20    MOV   A,[time]
    1BDF: 08       PUSH  A
    1BE0: 51 21    MOV   A,[time+1]
    1BE2: 08       PUSH  A
    1BE3: 51 22    MOV   A,[time+2]
    1BE5: 08       PUSH  A
    1BE6: 51 23    MOV   A,[time+3]
    1BE8: 08       PUSH  A
    1BE9: 50 3F    MOV   A,63
    1BEB: 08       PUSH  A
    1BEC: 50 80    MOV   A,128
    1BEE: 08       PUSH  A
    1BEF: 50 00    MOV   A,0
    1BF1: 08       PUSH  A
    1BF2: 08       PUSH  A
    1BF3: 62 D0 00 MOV   REG[208],0
    1BF6: 7C 22 83 LCALL __fpdiv
    1BF9: 18       POP   A
    1BFA: 62 D0 00 MOV   REG[208],0
    1BFD: 53 27    MOV   [delta_f+3],A
    1BFF: 18       POP   A
    1C00: 53 26    MOV   [delta_f+2],A
    1C02: 18       POP   A
    1C03: 53 25    MOV   [delta_f+1],A
    1C05: 18       POP   A
    1C06: 53 24    MOV   [delta_f],A
    1C08: 38 FC    ADD   SP,252
(0111)     
(0112)     itoa(df,(int)delta_f,10);
    1C0A: 50 00    MOV   A,0
    1C0C: 08       PUSH  A
    1C0D: 50 0A    MOV   A,10
    1C0F: 08       PUSH  A
    1C10: 51 24    MOV   A,[delta_f]
    1C12: 08       PUSH  A
    1C13: 51 25    MOV   A,[delta_f+1]
    1C15: 08       PUSH  A
    1C16: 51 26    MOV   A,[delta_f+2]
    1C18: 08       PUSH  A
    1C19: 51 27    MOV   A,[delta_f+3]
    1C1B: 08       PUSH  A
    1C1C: 62 D0 00 MOV   REG[208],0
    1C1F: 7C 23 EB LCALL __fp2long
    1C22: 18       POP   A
    1C23: 53 1A    MOV   [__r1],A
    1C25: 18       POP   A
    1C26: 38 FE    ADD   SP,254
    1C28: 08       PUSH  A
    1C29: 51 1A    MOV   A,[__r1]
    1C2B: 08       PUSH  A
    1C2C: 50 00    MOV   A,0
    1C2E: 08       PUSH  A
    1C2F: 50 28    MOV   A,40
    1C31: 08       PUSH  A
    1C32: 7C 24 D7 LCALL _itoa
    1C35: 38 FA    ADD   SP,250
(0113)     
(0114)     LCD_1_Start();                       // Init the LCD
    1C37: 10       PUSH  X
    1C38: 7C 06 49 LCALL 0x0649
(0115)     LCD_1_InitBG(LCD_1_SOLID_BG);
    1C3B: 50 00    MOV   A,0
    1C3D: 7C 07 8E LCALL 0x078E
(0116)     LCD_1_Position(0,0);
    1C40: 50 00    MOV   A,0
    1C42: 5C       MOV   X,A
    1C43: 7C 06 BC LCALL 0x06BC
(0117)     LCD_1_PrCString("FFT  df=");
    1C46: 50 01    MOV   A,1
    1C48: 08       PUSH  A
    1C49: 50 54    MOV   A,84
    1C4B: 5C       MOV   X,A
    1C4C: 18       POP   A
    1C4D: 7C 05 3C LCALL 0x053C
(0118)     LCD_1_Position(0,8);
    1C50: 57 08    MOV   X,8
    1C52: 50 00    MOV   A,0
    1C54: 7C 06 BC LCALL 0x06BC
(0119)     LCD_1_PrString(df);
    1C57: 50 00    MOV   A,0
    1C59: 08       PUSH  A
    1C5A: 50 28    MOV   A,40
    1C5C: 5C       MOV   X,A
    1C5D: 18       POP   A
    1C5E: 7C 05 78 LCALL 0x0578
(0120)     LCD_1_PrCString(" Hz");
    1C61: 50 01    MOV   A,1
    1C63: 08       PUSH  A
    1C64: 50 50    MOV   A,80
    1C66: 5C       MOV   X,A
    1C67: 18       POP   A
    1C68: 7C 05 3C LCALL 0x053C
    1C6B: 20       POP   X
(0121)     M8C_EnableGInt;                      // Enable Global interrupts
    1C6C: 71 01    OR    F,1
(0122)     
(0123)        
(0124)     i=0;
    1C6E: 62 D0 00 MOV   REG[208],0
    1C71: 55 31 00 MOV   [i+1],0
    1C74: 55 30 00 MOV   [i],0
    1C77: 81 DA    JMP   0x1E52
(0125)     
(0126)  	while (1)// Main loop 
(0127)     {   
(0128)          if ( DELSIG11_1_fIsDataAvailable() ) 
    1C79: 10       PUSH  X
    1C7A: 7C 08 72 LCALL 0x0872
    1C7D: 62 D0 00 MOV   REG[208],0
    1C80: 20       POP   X
    1C81: 39 00    CMP   A,0
    1C83: A0 7F    JZ    0x1D03
(0129)          {  
(0130)          data_re[i]=DELSIG11_1_iGetDataClearFlag();       
    1C85: 10       PUSH  X
    1C86: 7C 08 78 LCALL 0x0878
    1C89: 62 D0 00 MOV   REG[208],0
    1C8C: 5A 1B    MOV   [__r0],X
    1C8E: 20       POP   X
    1C8F: 53 18    MOV   [__r3],A
    1C91: 51 1B    MOV   A,[__r0]
    1C93: 53 19    MOV   [__r2],A
    1C95: 47 19 80 TST   [__r2],128
    1C98: A0 09    JZ    0x1CA2
    1C9A: 55 1A FF MOV   [__r1],255
    1C9D: 55 1B FF MOV   [__r0],255
    1CA0: 80 0A    JMP   0x1CAB
    1CA2: 62 D0 00 MOV   REG[208],0
    1CA5: 55 1A 00 MOV   [__r1],0
    1CA8: 55 1B 00 MOV   [__r0],0
    1CAB: 62 D0 00 MOV   REG[208],0
    1CAE: 51 1B    MOV   A,[__r0]
    1CB0: 08       PUSH  A
    1CB1: 51 1A    MOV   A,[__r1]
    1CB3: 08       PUSH  A
    1CB4: 51 19    MOV   A,[__r2]
    1CB6: 08       PUSH  A
    1CB7: 51 18    MOV   A,[__r3]
    1CB9: 08       PUSH  A
    1CBA: 7C 24 6D LCALL __long2fp
    1CBD: 18       POP   A
    1CBE: 53 18    MOV   [__r3],A
    1CC0: 18       POP   A
    1CC1: 53 19    MOV   [__r2],A
    1CC3: 18       POP   A
    1CC4: 53 1A    MOV   [__r1],A
    1CC6: 18       POP   A
    1CC7: 53 1B    MOV   [__r0],A
    1CC9: 62 D0 00 MOV   REG[208],0
    1CCC: 51 31    MOV   A,[i+1]
    1CCE: 08       PUSH  A
    1CCF: 51 30    MOV   A,[i]
    1CD1: 62 D0 00 MOV   REG[208],0
    1CD4: 53 17    MOV   [__r4],A
    1CD6: 18       POP   A
    1CD7: 53 16    MOV   [__r5],A
    1CD9: 65 16    ASL   [__r5]
    1CDB: 6B 17    RLC   [__r4]
    1CDD: 65 16    ASL   [__r5]
    1CDF: 6B 17    RLC   [__r4]
    1CE1: 06 16 00 ADD   [__r5],0
    1CE4: 0E 17 03 ADC   [__r4],3
    1CE7: 51 17    MOV   A,[__r4]
    1CE9: 60 D5    MOV   REG[213],A
    1CEB: 51 1B    MOV   A,[__r0]
    1CED: 3F 16    MVI   [__r5],A
    1CEF: 51 1A    MOV   A,[__r1]
    1CF1: 3F 16    MVI   [__r5],A
    1CF3: 51 19    MOV   A,[__r2]
    1CF5: 3F 16    MVI   [__r5],A
    1CF7: 51 18    MOV   A,[__r3]
    1CF9: 3F 16    MVI   [__r5],A
(0131)          i++;
    1CFB: 62 D0 00 MOV   REG[208],0
    1CFE: 76 31    INC   [i+1]
    1D00: 0E 30 00 ADC   [i],0
(0132)          } 
(0133)       
(0134)        if(i==N_points)
    1D03: 62 D0 00 MOV   REG[208],0
    1D06: 3C 30 00 CMP   [i],0
    1D09: B1 48    JNZ   0x1E52
    1D0B: 3C 31 40 CMP   [i+1],64
    1D0E: B1 43    JNZ   0x1E52
(0135)         {
(0136)             
(0137)         	FFT(1,exponent,data_re,data_imm );
    1D10: 50 42    MOV   A,66
    1D12: 08       PUSH  A
    1D13: 50 80    MOV   A,128
    1D15: 08       PUSH  A
    1D16: 50 00    MOV   A,0
    1D18: 08       PUSH  A
    1D19: 08       PUSH  A
    1D1A: 7C 27 1A LCALL _log
    1D1D: 62 D0 00 MOV   REG[208],0
    1D20: 51 1B    MOV   A,[__r0]
    1D22: 54 01    MOV   [X+1],A
    1D24: 51 1A    MOV   A,[__r1]
    1D26: 54 02    MOV   [X+2],A
    1D28: 51 19    MOV   A,[__r2]
    1D2A: 54 03    MOV   [X+3],A
    1D2C: 51 18    MOV   A,[__r3]
    1D2E: 54 04    MOV   [X+4],A
    1D30: 50 40    MOV   A,64
    1D32: 08       PUSH  A
    1D33: 50 00    MOV   A,0
    1D35: 08       PUSH  A
    1D36: 08       PUSH  A
    1D37: 08       PUSH  A
    1D38: 7C 27 1A LCALL _log
    1D3B: 38 F8    ADD   SP,248
    1D3D: 50 01    MOV   A,1
    1D3F: 08       PUSH  A
    1D40: 50 00    MOV   A,0
    1D42: 08       PUSH  A
    1D43: 50 03    MOV   A,3
    1D45: 08       PUSH  A
    1D46: 50 00    MOV   A,0
    1D48: 08       PUSH  A
    1D49: 62 D0 00 MOV   REG[208],0
    1D4C: 51 1B    MOV   A,[__r0]
    1D4E: 08       PUSH  A
    1D4F: 51 1A    MOV   A,[__r1]
    1D51: 08       PUSH  A
    1D52: 51 19    MOV   A,[__r2]
    1D54: 08       PUSH  A
    1D55: 51 18    MOV   A,[__r3]
    1D57: 08       PUSH  A
    1D58: 52 01    MOV   A,[X+1]
    1D5A: 08       PUSH  A
    1D5B: 52 02    MOV   A,[X+2]
    1D5D: 08       PUSH  A
    1D5E: 52 03    MOV   A,[X+3]
    1D60: 08       PUSH  A
    1D61: 52 04    MOV   A,[X+4]
    1D63: 08       PUSH  A
    1D64: 7C 22 83 LCALL __fpdiv
    1D67: 18       POP   A
    1D68: 53 18    MOV   [__r3],A
    1D6A: 18       POP   A
    1D6B: 53 19    MOV   [__r2],A
    1D6D: 18       POP   A
    1D6E: 53 1A    MOV   [__r1],A
    1D70: 18       POP   A
    1D71: 38 FC    ADD   SP,252
    1D73: 08       PUSH  A
    1D74: 51 1A    MOV   A,[__r1]
    1D76: 08       PUSH  A
    1D77: 51 19    MOV   A,[__r2]
    1D79: 08       PUSH  A
    1D7A: 51 18    MOV   A,[__r3]
    1D7C: 08       PUSH  A
    1D7D: 7C 23 EB LCALL __fp2long
    1D80: 18       POP   A
    1D81: 53 18    MOV   [__r3],A
    1D83: 18       POP   A
    1D84: 53 19    MOV   [__r2],A
    1D86: 18       POP   A
    1D87: 53 1A    MOV   [__r1],A
    1D89: 18       POP   A
    1D8A: 08       PUSH  A
    1D8B: 51 1A    MOV   A,[__r1]
    1D8D: 08       PUSH  A
    1D8E: 51 19    MOV   A,[__r2]
    1D90: 08       PUSH  A
    1D91: 51 18    MOV   A,[__r3]
    1D93: 08       PUSH  A
    1D94: 50 00    MOV   A,0
    1D96: 08       PUSH  A
    1D97: 50 01    MOV   A,1
    1D99: 08       PUSH  A
    1D9A: 7C 08 9E LCALL _FFT
    1D9D: 38 F6    ADD   SP,246
(0138)        
(0139)             UART_print_mod ();
    1D9F: 99 5E    CALL  _UART_print_mod
(0140)             UART_print_re_imm ();
    1DA1: 98 82    CALL  _UART_print_re_imm
(0141)             //UART_print_data();
(0142)     	    LCD_print();
    1DA3: 9A 64    CALL  _LCD_print
(0143)         	
(0144)          	for(i=0;i<N_points;i++)
    1DA5: 62 D0 00 MOV   REG[208],0
    1DA8: 55 31 00 MOV   [i+1],0
    1DAB: 55 30 00 MOV   [i],0
    1DAE: 80 8D    JMP   0x1E3C
(0145)          	{  	
(0146)             mod[i]=0;       //init 0
    1DB0: 62 D0 00 MOV   REG[208],0
    1DB3: 51 31    MOV   A,[i+1]
    1DB5: 08       PUSH  A
    1DB6: 51 30    MOV   A,[i]
    1DB8: 62 D0 00 MOV   REG[208],0
    1DBB: 53 1B    MOV   [__r0],A
    1DBD: 18       POP   A
    1DBE: 53 1A    MOV   [__r1],A
    1DC0: 65 1A    ASL   [__r1]
    1DC2: 6B 1B    RLC   [__r0]
    1DC4: 65 1A    ASL   [__r1]
    1DC6: 6B 1B    RLC   [__r0]
    1DC8: 06 1A 00 ADD   [__r1],0
    1DCB: 0E 1B 02 ADC   [__r0],2
    1DCE: 51 1B    MOV   A,[__r0]
    1DD0: 60 D5    MOV   REG[213],A
    1DD2: 50 00    MOV   A,0
    1DD4: 3F 1A    MVI   [__r1],A
    1DD6: 3F 1A    MVI   [__r1],A
    1DD8: 3F 1A    MVI   [__r1],A
    1DDA: 3F 1A    MVI   [__r1],A
(0147)             data_re[i]=0;
    1DDC: 62 D0 00 MOV   REG[208],0
    1DDF: 51 31    MOV   A,[i+1]
    1DE1: 08       PUSH  A
    1DE2: 51 30    MOV   A,[i]
    1DE4: 62 D0 00 MOV   REG[208],0
    1DE7: 53 1B    MOV   [__r0],A
    1DE9: 18       POP   A
    1DEA: 53 1A    MOV   [__r1],A
    1DEC: 65 1A    ASL   [__r1]
    1DEE: 6B 1B    RLC   [__r0]
    1DF0: 65 1A    ASL   [__r1]
    1DF2: 6B 1B    RLC   [__r0]
    1DF4: 06 1A 00 ADD   [__r1],0
    1DF7: 0E 1B 03 ADC   [__r0],3
    1DFA: 51 1B    MOV   A,[__r0]
    1DFC: 60 D5    MOV   REG[213],A
    1DFE: 50 00    MOV   A,0
    1E00: 3F 1A    MVI   [__r1],A
    1E02: 3F 1A    MVI   [__r1],A
    1E04: 3F 1A    MVI   [__r1],A
    1E06: 3F 1A    MVI   [__r1],A
(0148)             data_imm[i]=0;
    1E08: 62 D0 00 MOV   REG[208],0
    1E0B: 51 31    MOV   A,[i+1]
    1E0D: 08       PUSH  A
    1E0E: 51 30    MOV   A,[i]
    1E10: 62 D0 00 MOV   REG[208],0
    1E13: 53 1B    MOV   [__r0],A
    1E15: 18       POP   A
    1E16: 53 1A    MOV   [__r1],A
    1E18: 65 1A    ASL   [__r1]
    1E1A: 6B 1B    RLC   [__r0]
    1E1C: 65 1A    ASL   [__r1]
    1E1E: 6B 1B    RLC   [__r0]
    1E20: 06 1A 00 ADD   [__r1],0
    1E23: 0E 1B 01 ADC   [__r0],1
    1E26: 51 1B    MOV   A,[__r0]
    1E28: 60 D5    MOV   REG[213],A
    1E2A: 50 00    MOV   A,0
    1E2C: 3F 1A    MVI   [__r1],A
    1E2E: 3F 1A    MVI   [__r1],A
    1E30: 3F 1A    MVI   [__r1],A
    1E32: 3F 1A    MVI   [__r1],A
    1E34: 62 D0 00 MOV   REG[208],0
    1E37: 76 31    INC   [i+1]
    1E39: 0E 30 00 ADC   [i],0
    1E3C: 62 D0 00 MOV   REG[208],0
    1E3F: 51 31    MOV   A,[i+1]
    1E41: 11 40    SUB   A,64
    1E43: 51 30    MOV   A,[i]
    1E45: 19 00    SBB   A,0
    1E47: CF 68    JC    0x1DB0
(0149)             }
(0150)             i=0;
    1E49: 62 D0 00 MOV   REG[208],0
    1E4C: 55 31 00 MOV   [i+1],0
    1E4F: 55 30 00 MOV   [i],0
    1E52: 8E 26    JMP   0x1C79
(0151)         }       
(0152) }      
(0153) }FILE: <library>
    1E54: 38 FB    ADD   SP,251
    1E56: 20       POP   X
    1E57: 8F FF    JMP   0x1E57
__divmodu_16X16_16:
    1E59: 5A 0F    MOV   [__rX],X
    1E5B: 4F       MOV   X,SP
    1E5C: 38 09    ADD   SP,9
    1E5E: 56 08 00 MOV   [X+8],0
    1E61: 52 FD    MOV   A,[X-3]
    1E63: 54 07    MOV   [X+7],A
    1E65: 52 FC    MOV   A,[X-4]
    1E67: 54 06    MOV   [X+6],A
    1E69: 56 05 00 MOV   [X+5],0
    1E6C: 56 04 00 MOV   [X+4],0
    1E6F: 56 00 05 MOV   [X+0],5
    1E72: 69 06    ASR   [X+6]
    1E74: 6F 07    RRC   [X+7]
    1E76: 6F 08    RRC   [X+8]
    1E78: 7B 00    DEC   [X+0]
    1E7A: BF F7    JNZ   0x1E72
    1E7C: 27 06 07 AND   [X+6],7
    1E7F: 56 03 00 MOV   [X+3],0
    1E82: 52 FB    MOV   A,[X-5]
    1E84: 54 02    MOV   [X+2],A
    1E86: 52 FA    MOV   A,[X-6]
    1E88: 54 01    MOV   [X+1],A
    1E8A: 56 00 05 MOV   [X+0],5
    1E8D: 69 01    ASR   [X+1]
    1E8F: 6F 02    RRC   [X+2]
    1E91: 6F 03    RRC   [X+3]
    1E93: 7B 00    DEC   [X+0]
    1E95: BF F7    JNZ   0x1E8D
    1E97: 27 01 07 AND   [X+1],7
    1E9A: 56 00 10 MOV   [X+0],16
    1E9D: 66 08    ASL   [X+8]
    1E9F: 6C 07    RLC   [X+7]
    1EA1: 6C 06    RLC   [X+6]
    1EA3: 6C 05    RLC   [X+5]
    1EA5: 6C 04    RLC   [X+4]
    1EA7: D0 0F    JNC   0x1EB7
    1EA9: 52 03    MOV   A,[X+3]
    1EAB: 05 06    ADD   [X+6],A
    1EAD: 52 02    MOV   A,[X+2]
    1EAF: 0D 05    ADC   [X+5],A
    1EB1: 52 01    MOV   A,[X+1]
    1EB3: 0D 04    ADC   [X+4],A
    1EB5: 80 0D    JMP   0x1EC3
    1EB7: 52 03    MOV   A,[X+3]
    1EB9: 15 06    SUB   [X+6],A
    1EBB: 52 02    MOV   A,[X+2]
    1EBD: 1D 05    SBB   [X+5],A
    1EBF: 52 01    MOV   A,[X+1]
    1EC1: 1D 04    SBB   [X+4],A
    1EC3: 48 04 80 TST   [X+4],128
    1EC6: B0 04    JNZ   0x1ECB
    1EC8: 2F 08 01 OR    [X+8],1
    1ECB: 7B 00    DEC   [X+0]
    1ECD: BF CF    JNZ   0x1E9D
    1ECF: 52 08    MOV   A,[X+8]
    1ED1: 54 FD    MOV   [X-3],A
    1ED3: 52 07    MOV   A,[X+7]
    1ED5: 54 FC    MOV   [X-4],A
    1ED7: 48 04 80 TST   [X+4],128
    1EDA: A0 0D    JZ    0x1EE8
    1EDC: 52 03    MOV   A,[X+3]
    1EDE: 05 06    ADD   [X+6],A
    1EE0: 52 02    MOV   A,[X+2]
    1EE2: 0D 05    ADC   [X+5],A
    1EE4: 52 01    MOV   A,[X+1]
    1EE6: 0D 04    ADC   [X+4],A
    1EE8: 56 00 03 MOV   [X+0],3
    1EEB: 69 04    ASR   [X+4]
    1EED: 6F 05    RRC   [X+5]
    1EEF: 6F 06    RRC   [X+6]
    1EF1: 7B 00    DEC   [X+0]
    1EF3: BF F7    JNZ   0x1EEB
    1EF5: 52 05    MOV   A,[X+5]
    1EF7: 54 FA    MOV   [X-6],A
    1EF9: 52 06    MOV   A,[X+6]
    1EFB: 54 FB    MOV   [X-5],A
    1EFD: 38 F7    ADD   SP,247
    1EFF: 58 0F    MOV   X,[__rX]
    1F01: 7F       RET   
__SPFloat_is_zero:
    1F02: 52 01    MOV   A,[X+1]
    1F04: 2B 02    OR    A,[X+2]
    1F06: 2B 03    OR    A,[X+3]
    1F08: 2B 04    OR    A,[X+4]
    1F0A: 21 FF    AND   A,255
    1F0C: 7F       RET   
__unpack_u:
    1F0D: 52 01    MOV   A,[X+1]
    1F0F: 54 00    MOV   [X+0],A
    1F11: 9F EF    CALL  __SPFloat_is_zero
    1F13: A0 19    JZ    0x1F2D
    1F15: 52 02    MOV   A,[X+2]
    1F17: 64       ASL   A
    1F18: 52 01    MOV   A,[X+1]
    1F1A: 6A       RLC   A
    1F1B: 11 7F    SUB   A,127
    1F1D: 54 00    MOV   [X+0],A
    1F1F: 56 01 00 MOV   [X+1],0
    1F22: 27 02 7F AND   [X+2],127
    1F25: 3D 00 81 CMP   [X+0],129
    1F28: A0 04    JZ    0x1F2D
    1F2A: 2F 02 80 OR    [X+2],128
    1F2D: 7F       RET   
__unpack_s:
    1F2E: 52 01    MOV   A,[X+1]
    1F30: 54 00    MOV   [X+0],A
    1F32: 9F CE    CALL  __SPFloat_is_zero
    1F34: B0 05    JNZ   0x1F3A
    1F36: 50 00    MOV   A,0
    1F38: 80 39    JMP   0x1F72
    1F3A: 52 02    MOV   A,[X+2]
    1F3C: 64       ASL   A
    1F3D: 52 01    MOV   A,[X+1]
    1F3F: 08       PUSH  A
    1F40: 6A       RLC   A
    1F41: 11 7F    SUB   A,127
    1F43: 54 00    MOV   [X+0],A
    1F45: 56 01 00 MOV   [X+1],0
    1F48: 27 02 7F AND   [X+2],127
    1F4B: 3D 00 80 CMP   [X+0],128
    1F4E: A0 04    JZ    0x1F53
    1F50: 2F 02 80 OR    [X+2],128
    1F53: 18       POP   A
    1F54: 08       PUSH  A
    1F55: 21 80    AND   A,128
    1F57: A0 19    JZ    0x1F71
    1F59: 37 01 FF XOR   [X+1],255
    1F5C: 37 02 FF XOR   [X+2],255
    1F5F: 37 03 FF XOR   [X+3],255
    1F62: 37 04 FF XOR   [X+4],255
    1F65: 07 04 01 ADD   [X+4],1
    1F68: 0F 03 00 ADC   [X+3],0
    1F6B: 0F 02 00 ADC   [X+2],0
    1F6E: 0F 01 00 ADC   [X+1],0
    1F71: 18       POP   A
    1F72: 7F       RET   
__pack:
    1F73: 08       PUSH  A
    1F74: 10       PUSH  X
    1F75: 75       INC   X
    1F76: 90 DA    CALL  __tst_s32
    1F78: 20       POP   X
    1F79: A0 0E    JZ    0x1F88
    1F7B: 52 00    MOV   A,[X+0]
    1F7D: 54 01    MOV   [X+1],A
    1F7F: 66 02    ASL   [X+2]
    1F81: 18       POP   A
    1F82: 64       ASL   A
    1F83: 6F 01    RRC   [X+1]
    1F85: 6F 02    RRC   [X+2]
    1F87: 7F       RET   
    1F88: 18       POP   A
    1F89: 7F       RET   
__add_FP_exp:
    1F8A: 10       PUSH  X
    1F8B: 08       PUSH  A
    1F8C: 52 00    MOV   A,[X+0]
    1F8E: 08       PUSH  A
    1F8F: 4F       MOV   X,SP
    1F90: 03 FE    ADD   A,[X-2]
    1F92: 08       PUSH  A
    1F93: 52 FF    MOV   A,[X-1]
    1F95: 33 FE    XOR   A,[X-2]
    1F97: 21 80    AND   A,128
    1F99: B0 39    JNZ   0x1FD3
    1F9B: 52 00    MOV   A,[X+0]
    1F9D: 33 FF    XOR   A,[X-1]
    1F9F: 21 80    AND   A,128
    1FA1: A0 31    JZ    0x1FD3
    1FA3: 48 FF 80 TST   [X-1],128
    1FA6: A0 16    JZ    0x1FBD
    1FA8: 59 FD    MOV   X,[X-3]
    1FAA: 56 00 00 MOV   [X+0],0
    1FAD: 56 01 00 MOV   [X+1],0
    1FB0: 56 02 00 MOV   [X+2],0
    1FB3: 56 03 00 MOV   [X+3],0
    1FB6: 56 04 00 MOV   [X+4],0
    1FB9: 50 FF    MOV   A,255
    1FBB: 80 14    JMP   0x1FD0
    1FBD: 59 FD    MOV   X,[X-3]
    1FBF: 56 00 FE MOV   [X+0],254
    1FC2: 56 01 00 MOV   [X+1],0
    1FC5: 56 02 FF MOV   [X+2],255
    1FC8: 56 03 FF MOV   [X+3],255
    1FCB: 56 04 FF MOV   [X+4],255
    1FCE: 50 01    MOV   A,1
    1FD0: 38 FC    ADD   SP,252
    1FD2: 7F       RET   
    1FD3: 18       POP   A
    1FD4: 38 FE    ADD   SP,254
    1FD6: 20       POP   X
    1FD7: 01 7F    ADD   A,127
    1FD9: 54 00    MOV   [X+0],A
    1FDB: 50 00    MOV   A,0
    1FDD: 7F       RET   
__normalize:
    1FDE: 10       PUSH  X
    1FDF: 75       INC   X
    1FE0: 90 70    CALL  __tst_s32
    1FE2: 20       POP   X
    1FE3: A0 34    JZ    0x2018
    1FE5: 48 01 FF TST   [X+1],255
    1FE8: A0 12    JZ    0x1FFB
    1FEA: 3D 00 7F CMP   [X+0],127
    1FED: A0 37    JZ    0x2025
    1FEF: 69 01    ASR   [X+1]
    1FF1: 6F 02    RRC   [X+2]
    1FF3: 6F 03    RRC   [X+3]
    1FF5: 6F 04    RRC   [X+4]
    1FF7: 77 00    INC   [X+0]
    1FF9: 8F EB    JMP   0x1FE5
    1FFB: 48 02 80 TST   [X+2],128
    1FFE: B0 17    JNZ   0x2016
    2000: 3D 00 80 CMP   [X+0],128
    2003: A0 12    JZ    0x2016
    2005: 3D 00 81 CMP   [X+0],129
    2008: A0 10    JZ    0x2019
    200A: 66 04    ASL   [X+4]
    200C: 6C 03    RLC   [X+3]
    200E: 6C 02    RLC   [X+2]
    2010: 6C 01    RLC   [X+1]
    2012: 7B 00    DEC   [X+0]
    2014: 8F E6    JMP   0x1FFB
    2016: 50 01    MOV   A,1
    2018: 7F       RET   
    2019: 50 00    MOV   A,0
    201B: 54 01    MOV   [X+1],A
    201D: 54 02    MOV   [X+2],A
    201F: 54 03    MOV   [X+3],A
    2021: 54 04    MOV   [X+4],A
    2023: 8F F4    JMP   0x2018
    2025: 56 01 00 MOV   [X+1],0
    2028: 50 FF    MOV   A,255
    202A: 54 02    MOV   [X+2],A
    202C: 54 03    MOV   [X+3],A
    202E: 54 04    MOV   [X+4],A
    2030: 8F E7    JMP   0x2018
__asr_32:
    2032: 39 00    CMP   A,0
    2034: A0 1C    JZ    0x2051
    2036: 39 20    CMP   A,32
    2038: D0 0E    JNC   0x2047
    203A: 69 00    ASR   [X+0]
    203C: 6F 01    RRC   [X+1]
    203E: 6F 02    RRC   [X+2]
    2040: 6F 03    RRC   [X+3]
    2042: 78       DEC   A
    2043: BF F6    JNZ   0x203A
    2045: 80 0B    JMP   0x2051
    2047: 50 00    MOV   A,0
    2049: 54 00    MOV   [X+0],A
    204B: 54 01    MOV   [X+1],A
    204D: 54 02    MOV   [X+2],A
    204F: 54 03    MOV   [X+3],A
    2051: 7F       RET   
__tst_s32:
    2052: 48 00 FF TST   [X+0],255
    2055: B0 10    JNZ   0x2066
    2057: 48 01 FF TST   [X+1],255
    205A: B0 0B    JNZ   0x2066
    205C: 48 02 FF TST   [X+2],255
    205F: B0 06    JNZ   0x2066
    2061: 48 03 FF TST   [X+3],255
    2064: A0 0B    JZ    0x2070
    2066: 48 00 80 TST   [X+0],128
    2069: B0 04    JNZ   0x206E
    206B: 50 01    MOV   A,1
    206D: 7F       RET   
    206E: 50 FF    MOV   A,255
    2070: 7F       RET   
__neg_32:
    2071: 37 00 FF XOR   [X+0],255
    2074: 37 01 FF XOR   [X+1],255
    2077: 37 02 FF XOR   [X+2],255
    207A: 37 03 FF XOR   [X+3],255
    207D: 0F 03 00 ADC   [X+3],0
    2080: 0F 02 00 ADC   [X+2],0
    2083: 0F 01 00 ADC   [X+1],0
    2086: 07 00 01 ADD   [X+0],1
    2089: 7F       RET   
__SPFloat_neg:
    208A: 9E 76    CALL  __SPFloat_is_zero
    208C: A0 04    JZ    0x2091
    208E: 37 00 80 XOR   [X+0],128
    2091: 7F       RET   
__overflow:
    2092: 10       PUSH  X
    2093: 4F       MOV   X,SP
    2094: 52 FB    MOV   A,[X-5]
    2096: 33 FC    XOR   A,[X-4]
    2098: 21 80    AND   A,128
    209A: B0 09    JNZ   0x20A4
    209C: 52 FB    MOV   A,[X-5]
    209E: 33 FA    XOR   A,[X-6]
    20A0: 21 80    AND   A,128
    20A2: 20       POP   X
    20A3: 7F       RET   
    20A4: 50 00    MOV   A,0
    20A6: 8F FB    JMP   0x20A2
__fpsub:
    20A8: 10       PUSH  X
    20A9: 4F       MOV   X,SP
    20AA: 4B       SWAP  A,X
    20AB: 01 F5    ADD   A,245
    20AD: 4B       SWAP  A,X
    20AE: 9F A2    CALL  __tst_s32
    20B0: A0 04    JZ    0x20B5
    20B2: 37 00 80 XOR   [X+0],128
    20B5: 20       POP   X
__fpadd:
    20B6: 10       PUSH  X
    20B7: 4F       MOV   X,SP
    20B8: 4B       SWAP  A,X
    20B9: 01 F5    ADD   A,245
    20BB: 4B       SWAP  A,X
    20BC: 9F 94    CALL  __tst_s32
    20BE: A0 D9    JZ    0x2198
    20C0: 4F       MOV   X,SP
    20C1: 4B       SWAP  A,X
    20C2: 01 F9    ADD   A,249
    20C4: 4B       SWAP  A,X
    20C5: 9F 8B    CALL  __tst_s32
    20C7: B0 14    JNZ   0x20DC
    20C9: 4F       MOV   X,SP
    20CA: 52 F5    MOV   A,[X-11]
    20CC: 54 F9    MOV   [X-7],A
    20CE: 52 F6    MOV   A,[X-10]
    20D0: 54 FA    MOV   [X-6],A
    20D2: 52 F7    MOV   A,[X-9]
    20D4: 54 FB    MOV   [X-5],A
    20D6: 52 F8    MOV   A,[X-8]
    20D8: 54 FC    MOV   [X-4],A
    20DA: 80 BD    JMP   0x2198
    20DC: 4F       MOV   X,SP
    20DD: 38 0B    ADD   SP,11
    20DF: 52 F9    MOV   A,[X-7]
    20E1: 54 01    MOV   [X+1],A
    20E3: 52 FA    MOV   A,[X-6]
    20E5: 54 02    MOV   [X+2],A
    20E7: 52 FB    MOV   A,[X-5]
    20E9: 54 03    MOV   [X+3],A
    20EB: 52 FC    MOV   A,[X-4]
    20ED: 54 04    MOV   [X+4],A
    20EF: 52 F5    MOV   A,[X-11]
    20F1: 54 07    MOV   [X+7],A
    20F3: 52 F6    MOV   A,[X-10]
    20F5: 54 08    MOV   [X+8],A
    20F7: 52 F7    MOV   A,[X-9]
    20F9: 54 09    MOV   [X+9],A
    20FB: 52 F8    MOV   A,[X-8]
    20FD: 54 0A    MOV   [X+10],A
    20FF: 9E 2D    CALL  __unpack_s
    2101: 10       PUSH  X
    2102: 4B       SWAP  A,X
    2103: 01 06    ADD   A,6
    2105: 4B       SWAP  A,X
    2106: 9E 26    CALL  __unpack_s
    2108: 20       POP   X
    2109: 52 00    MOV   A,[X+0]
    210B: 13 06    SUB   A,[X+6]
    210D: A0 3A    JZ    0x2148
    210F: 08       PUSH  A
    2110: 52 06    MOV   A,[X+6]
    2112: 73       CPL   A
    2113: 74       INC   A
    2114: 08       PUSH  A
    2115: 52 00    MOV   A,[X+0]
    2117: 08       PUSH  A
    2118: 9F 78    CALL  __overflow
    211A: 38 FE    ADD   SP,254
    211C: A0 08    JZ    0x2125
    211E: 18       POP   A
    211F: 39 80    CMP   A,128
    2121: C0 1A    JC    0x213C
    2123: 80 72    JMP   0x2196
    2125: 18       POP   A
    2126: 39 80    CMP   A,128
    2128: D0 07    JNC   0x2130
    212A: 39 18    CMP   A,24
    212C: D0 69    JNC   0x2196
    212E: 80 11    JMP   0x2140
    2130: 39 E9    CMP   A,233
    2132: C0 09    JC    0x213C
    2134: 73       CPL   A
    2135: 74       INC   A
    2136: 05 00    ADD   [X+0],A
    2138: 10       PUSH  X
    2139: 75       INC   X
    213A: 80 0A    JMP   0x2145
    213C: 38 F5    ADD   SP,245
    213E: 8F 8A    JMP   0x20C9
    2140: 10       PUSH  X
    2141: 4B       SWAP  A,X
    2142: 01 07    ADD   A,7
    2144: 4B       SWAP  A,X
    2145: 9E EB    CALL  __asr_32
    2147: 20       POP   X
    2148: 52 0A    MOV   A,[X+10]
    214A: 05 04    ADD   [X+4],A
    214C: 52 09    MOV   A,[X+9]
    214E: 0D 03    ADC   [X+3],A
    2150: 52 08    MOV   A,[X+8]
    2152: 0D 02    ADC   [X+2],A
    2154: 52 07    MOV   A,[X+7]
    2156: 0D 01    ADC   [X+1],A
    2158: 52 01    MOV   A,[X+1]
    215A: 54 05    MOV   [X+5],A
    215C: 39 80    CMP   A,128
    215E: C0 19    JC    0x2178
    2160: 50 00    MOV   A,0
    2162: 13 04    SUB   A,[X+4]
    2164: 54 04    MOV   [X+4],A
    2166: 50 00    MOV   A,0
    2168: 1B 03    SBB   A,[X+3]
    216A: 54 03    MOV   [X+3],A
    216C: 50 00    MOV   A,0
    216E: 1B 02    SBB   A,[X+2]
    2170: 54 02    MOV   [X+2],A
    2172: 50 00    MOV   A,0
    2174: 1B 01    SBB   A,[X+1]
    2176: 54 01    MOV   [X+1],A
    2178: 9E 64    CALL  __normalize
    217A: A0 0B    JZ    0x2186
    217C: 10       PUSH  X
    217D: 50 7F    MOV   A,127
    217F: 05 00    ADD   [X+0],A
    2181: 52 05    MOV   A,[X+5]
    2183: 9D EE    CALL  __pack
    2185: 20       POP   X
    2186: 52 01    MOV   A,[X+1]
    2188: 54 F9    MOV   [X-7],A
    218A: 52 02    MOV   A,[X+2]
    218C: 54 FA    MOV   [X-6],A
    218E: 52 03    MOV   A,[X+3]
    2190: 54 FB    MOV   [X-5],A
    2192: 52 04    MOV   A,[X+4]
    2194: 54 FC    MOV   [X-4],A
    2196: 38 F5    ADD   SP,245
    2198: 20       POP   X
    2199: 7F       RET   
__fpmul:
    219A: 10       PUSH  X
    219B: 4F       MOV   X,SP
    219C: 4B       SWAP  A,X
    219D: 01 F5    ADD   A,245
    219F: 4B       SWAP  A,X
    21A0: 9E B0    CALL  __tst_s32
    21A2: 4F       MOV   X,SP
    21A3: A0 0C    JZ    0x21B0
    21A5: 4B       SWAP  A,X
    21A6: 01 F9    ADD   A,249
    21A8: 4B       SWAP  A,X
    21A9: 9E A7    CALL  __tst_s32
    21AB: 4F       MOV   X,SP
    21AC: A0 D4    JZ    0x2281
    21AE: 80 0F    JMP   0x21BE
    21B0: 56 F9 00 MOV   [X-7],0
    21B3: 56 FA 00 MOV   [X-6],0
    21B6: 56 FB 00 MOV   [X-5],0
    21B9: 56 FC 00 MOV   [X-4],0
    21BC: 80 C4    JMP   0x2281
    21BE: 38 0E    ADD   SP,14
    21C0: 52 F5    MOV   A,[X-11]
    21C2: 54 0A    MOV   [X+10],A
    21C4: 54 01    MOV   [X+1],A
    21C6: 52 F6    MOV   A,[X-10]
    21C8: 54 0B    MOV   [X+11],A
    21CA: 52 F7    MOV   A,[X-9]
    21CC: 54 0C    MOV   [X+12],A
    21CE: 52 F8    MOV   A,[X-8]
    21D0: 54 0D    MOV   [X+13],A
    21D2: 52 F9    MOV   A,[X-7]
    21D4: 54 03    MOV   [X+3],A
    21D6: 35 01    XOR   [X+1],A
    21D8: 52 FA    MOV   A,[X-6]
    21DA: 54 04    MOV   [X+4],A
    21DC: 52 FB    MOV   A,[X-5]
    21DE: 54 05    MOV   [X+5],A
    21E0: 52 FC    MOV   A,[X-4]
    21E2: 54 06    MOV   [X+6],A
    21E4: 10       PUSH  X
    21E5: 4B       SWAP  A,X
    21E6: 01 09    ADD   A,9
    21E8: 4B       SWAP  A,X
    21E9: 9D 22    CALL  __unpack_u
    21EB: 20       POP   X
    21EC: 52 09    MOV   A,[X+9]
    21EE: 54 00    MOV   [X+0],A
    21F0: 10       PUSH  X
    21F1: 4B       SWAP  A,X
    21F2: 01 02    ADD   A,2
    21F4: 4B       SWAP  A,X
    21F5: 9D 16    CALL  __unpack_u
    21F7: 20       POP   X
    21F8: 56 07 00 MOV   [X+7],0
    21FB: 56 08 00 MOV   [X+8],0
    21FE: 56 09 00 MOV   [X+9],0
    2201: 56 0A 00 MOV   [X+10],0
    2204: 50 18    MOV   A,24
    2206: 08       PUSH  A
    2207: 70 FB    AND   F,251
    2209: 6F 07    RRC   [X+7]
    220B: 6F 08    RRC   [X+8]
    220D: 6F 09    RRC   [X+9]
    220F: 6F 0A    RRC   [X+10]
    2211: 6F 0B    RRC   [X+11]
    2213: 6F 0C    RRC   [X+12]
    2215: 6F 0D    RRC   [X+13]
    2217: D0 11    JNC   0x2229
    2219: 52 06    MOV   A,[X+6]
    221B: 05 0A    ADD   [X+10],A
    221D: 52 05    MOV   A,[X+5]
    221F: 0D 09    ADC   [X+9],A
    2221: 52 04    MOV   A,[X+4]
    2223: 0D 08    ADC   [X+8],A
    2225: 50 00    MOV   A,0
    2227: 0D 07    ADC   [X+7],A
    2229: 18       POP   A
    222A: 78       DEC   A
    222B: BF DA    JNZ   0x2206
    222D: 70 FB    AND   F,251
    222F: 6F 07    RRC   [X+7]
    2231: 6F 08    RRC   [X+8]
    2233: 6F 09    RRC   [X+9]
    2235: 6F 0A    RRC   [X+10]
    2237: 6F 0B    RRC   [X+11]
    2239: 10       PUSH  X
    223A: 52 00    MOV   A,[X+0]
    223C: 4B       SWAP  A,X
    223D: 01 02    ADD   A,2
    223F: 4B       SWAP  A,X
    2240: 7C 1F 8A LCALL __add_FP_exp
    2243: B0 28    JNZ   0x226C
    2245: 20       POP   X
    2246: 48 08 80 TST   [X+8],128
    2249: A0 05    JZ    0x224F
    224B: 77 02    INC   [X+2]
    224D: 80 09    JMP   0x2257
    224F: 66 0B    ASL   [X+11]
    2251: 6C 0A    RLC   [X+10]
    2253: 6C 09    RLC   [X+9]
    2255: 6C 08    RLC   [X+8]
    2257: 52 08    MOV   A,[X+8]
    2259: 54 04    MOV   [X+4],A
    225B: 52 09    MOV   A,[X+9]
    225D: 54 05    MOV   [X+5],A
    225F: 52 0A    MOV   A,[X+10]
    2261: 54 06    MOV   [X+6],A
    2263: 10       PUSH  X
    2264: 52 01    MOV   A,[X+1]
    2266: 08       PUSH  A
    2267: 4B       SWAP  A,X
    2268: 01 02    ADD   A,2
    226A: 4B       SWAP  A,X
    226B: 18       POP   A
    226C: 9D 05    CALL  __pack
    226E: 20       POP   X
    226F: 52 03    MOV   A,[X+3]
    2271: 54 F9    MOV   [X-7],A
    2273: 52 04    MOV   A,[X+4]
    2275: 54 FA    MOV   [X-6],A
    2277: 52 05    MOV   A,[X+5]
    2279: 54 FB    MOV   [X-5],A
    227B: 52 06    MOV   A,[X+6]
    227D: 54 FC    MOV   [X-4],A
    227F: 38 F2    ADD   SP,242
    2281: 20       POP   X
    2282: 7F       RET   
__fpdiv:
    2283: 10       PUSH  X
    2284: 4F       MOV   X,SP
    2285: 4B       SWAP  A,X
    2286: 01 F9    ADD   A,249
    2288: 4B       SWAP  A,X
    2289: 9D C7    CALL  __tst_s32
    228B: 4F       MOV   X,SP
    228C: A0 FD    JZ    0x238A
    228E: 4B       SWAP  A,X
    228F: 01 F5    ADD   A,245
    2291: 4B       SWAP  A,X
    2292: 9D BE    CALL  __tst_s32
    2294: 4F       MOV   X,SP
    2295: A0 E0    JZ    0x2376
    2297: 52 F9    MOV   A,[X-7]
    2299: 33 F5    XOR   A,[X-11]
    229B: 38 0F    ADD   SP,15
    229D: 54 00    MOV   [X+0],A
    229F: 52 F5    MOV   A,[X-11]
    22A1: 54 02    MOV   [X+2],A
    22A3: 52 F6    MOV   A,[X-10]
    22A5: 54 03    MOV   [X+3],A
    22A7: 52 F7    MOV   A,[X-9]
    22A9: 54 04    MOV   [X+4],A
    22AB: 52 F8    MOV   A,[X-8]
    22AD: 54 05    MOV   [X+5],A
    22AF: 52 F9    MOV   A,[X-7]
    22B1: 54 08    MOV   [X+8],A
    22B3: 52 FA    MOV   A,[X-6]
    22B5: 54 09    MOV   [X+9],A
    22B7: 52 FB    MOV   A,[X-5]
    22B9: 54 0A    MOV   [X+10],A
    22BB: 52 FC    MOV   A,[X-4]
    22BD: 54 0B    MOV   [X+11],A
    22BF: 10       PUSH  X
    22C0: 4B       SWAP  A,X
    22C1: 01 07    ADD   A,7
    22C3: 4B       SWAP  A,X
    22C4: 9C 47    CALL  __unpack_u
    22C6: 20       POP   X
    22C7: 52 07    MOV   A,[X+7]
    22C9: 54 06    MOV   [X+6],A
    22CB: 10       PUSH  X
    22CC: 4B       SWAP  A,X
    22CD: 01 01    ADD   A,1
    22CF: 4B       SWAP  A,X
    22D0: 9C 3B    CALL  __unpack_u
    22D2: 20       POP   X
    22D3: 70 FB    AND   F,251
    22D5: 6F 08    RRC   [X+8]
    22D7: 6F 09    RRC   [X+9]
    22D9: 6F 0A    RRC   [X+10]
    22DB: 6F 0B    RRC   [X+11]
    22DD: 56 07 00 MOV   [X+7],0
    22E0: 56 0C 00 MOV   [X+12],0
    22E3: 56 0D 00 MOV   [X+13],0
    22E6: 56 0E 00 MOV   [X+14],0
    22E9: 50 20    MOV   A,32
    22EB: 08       PUSH  A
    22EC: 66 0E    ASL   [X+14]
    22EE: 6C 0D    RLC   [X+13]
    22F0: 6C 0C    RLC   [X+12]
    22F2: 6C 0B    RLC   [X+11]
    22F4: 6C 0A    RLC   [X+10]
    22F6: 6C 09    RLC   [X+9]
    22F8: 6C 08    RLC   [X+8]
    22FA: 6C 07    RLC   [X+7]
    22FC: C0 13    JC    0x2310
    22FE: 52 05    MOV   A,[X+5]
    2300: 15 0A    SUB   [X+10],A
    2302: 52 04    MOV   A,[X+4]
    2304: 1D 09    SBB   [X+9],A
    2306: 52 03    MOV   A,[X+3]
    2308: 1D 08    SBB   [X+8],A
    230A: 52 02    MOV   A,[X+2]
    230C: 1D 07    SBB   [X+7],A
    230E: 80 11    JMP   0x2320
    2310: 52 05    MOV   A,[X+5]
    2312: 05 0A    ADD   [X+10],A
    2314: 52 04    MOV   A,[X+4]
    2316: 0D 09    ADC   [X+9],A
    2318: 52 03    MOV   A,[X+3]
    231A: 0D 08    ADC   [X+8],A
    231C: 52 02    MOV   A,[X+2]
    231E: 0D 07    ADC   [X+7],A
    2320: 48 07 80 TST   [X+7],128
    2323: B0 04    JNZ   0x2328
    2325: 2F 0E 01 OR    [X+14],1
    2328: 18       POP   A
    2329: 78       DEC   A
    232A: BF C0    JNZ   0x22EB
    232C: 52 06    MOV   A,[X+6]
    232E: 54 0A    MOV   [X+10],A
    2330: 52 01    MOV   A,[X+1]
    2332: 31 FF    XOR   A,255
    2334: 74       INC   A
    2335: 10       PUSH  X
    2336: 4B       SWAP  A,X
    2337: 01 0A    ADD   A,10
    2339: 4B       SWAP  A,X
    233A: 7C 1F 8A LCALL __add_FP_exp
    233D: 20       POP   X
    233E: B0 19    JNZ   0x2358
    2340: 48 0B FF TST   [X+11],255
    2343: A0 05    JZ    0x2349
    2345: 38 F1    ADD   SP,241
    2347: 80 2E    JMP   0x2376
    2349: 48 0C 80 TST   [X+12],128
    234C: B0 0B    JNZ   0x2358
    234E: 66 0E    ASL   [X+14]
    2350: 6C 0D    RLC   [X+13]
    2352: 6C 0C    RLC   [X+12]
    2354: 6C 0B    RLC   [X+11]
    2356: 7B 0A    DEC   [X+10]
    2358: 52 00    MOV   A,[X+0]
    235A: 10       PUSH  X
    235B: 4B       SWAP  A,X
    235C: 01 0A    ADD   A,10
    235E: 4B       SWAP  A,X
    235F: 9C 12    CALL  __pack
    2361: 20       POP   X
    2362: 52 0B    MOV   A,[X+11]
    2364: 54 F9    MOV   [X-7],A
    2366: 52 0C    MOV   A,[X+12]
    2368: 54 FA    MOV   [X-6],A
    236A: 52 0D    MOV   A,[X+13]
    236C: 54 FB    MOV   [X-5],A
    236E: 52 0E    MOV   A,[X+14]
    2370: 54 FC    MOV   [X-4],A
    2372: 38 F1    ADD   SP,241
    2374: 80 15    JMP   0x238A
    2376: 56 F9 7F MOV   [X-7],127
    2379: 56 FA 80 MOV   [X-6],128
    237C: 56 FB 00 MOV   [X-5],0
    237F: 56 FC 00 MOV   [X-4],0
    2382: 48 00 80 TST   [X+0],128
    2385: A0 04    JZ    0x238A
    2387: 2F F9 80 OR    [X-7],128
    238A: 20       POP   X
    238B: 7F       RET   
__fpcmp:
    238C: 10       PUSH  X
    238D: 4F       MOV   X,SP
    238E: 38 01    ADD   SP,1
    2390: 52 F9    MOV   A,[X-7]
    2392: 33 F5    XOR   A,[X-11]
    2394: 21 80    AND   A,128
    2396: A0 0E    JZ    0x23A5
    2398: 48 F9 80 TST   [X-7],128
    239B: A0 05    JZ    0x23A1
    239D: 50 FF    MOV   A,255
    239F: 80 47    JMP   0x23E7
    23A1: 50 01    MOV   A,1
    23A3: 80 43    JMP   0x23E7
    23A5: 52 F9    MOV   A,[X-7]
    23A7: 21 80    AND   A,128
    23A9: 54 00    MOV   [X+0],A
    23AB: A0 0A    JZ    0x23B6
    23AD: 37 F9 80 XOR   [X-7],128
    23B0: 37 F5 80 XOR   [X-11],128
    23B3: 2F 00 01 OR    [X+0],1
    23B6: 52 F8    MOV   A,[X-8]
    23B8: 15 FC    SUB   [X-4],A
    23BA: 52 F7    MOV   A,[X-9]
    23BC: 1D FB    SBB   [X-5],A
    23BE: 52 F6    MOV   A,[X-10]
    23C0: 1D FA    SBB   [X-6],A
    23C2: 52 F5    MOV   A,[X-11]
    23C4: 1D F9    SBB   [X-7],A
    23C6: C0 15    JC    0x23DC
    23C8: 4B       SWAP  A,X
    23C9: 11 08    SUB   A,8
    23CB: 4B       SWAP  A,X
    23CC: 9B 34    CALL  __SPFloat_is_zero
    23CE: A0 05    JZ    0x23D4
    23D0: 50 01    MOV   A,1
    23D2: 80 03    JMP   0x23D6
    23D4: 50 00    MOV   A,0
    23D6: 4B       SWAP  A,X
    23D7: 01 08    ADD   A,8
    23D9: 4B       SWAP  A,X
    23DA: 80 03    JMP   0x23DE
    23DC: 50 FF    MOV   A,255
    23DE: 48 00 80 TST   [X+0],128
    23E1: A0 05    JZ    0x23E7
    23E3: 31 FF    XOR   A,255
    23E5: 01 01    ADD   A,1
    23E7: 38 FF    ADD   SP,255
    23E9: 20       POP   X
    23EA: 7F       RET   
__fp2long:
    23EB: 10       PUSH  X
    23EC: 4F       MOV   X,SP
    23ED: 4B       SWAP  A,X
    23EE: 11 07    SUB   A,7
    23F0: 4B       SWAP  A,X
    23F1: 9C 5F    CALL  __tst_s32
    23F3: A0 77    JZ    0x246B
    23F5: 4F       MOV   X,SP
    23F6: 52 F9    MOV   A,[X-7]
    23F8: 08       PUSH  A
    23F9: 66 FA    ASL   [X-6]
    23FB: 6C F9    RLC   [X-7]
    23FD: 52 F9    MOV   A,[X-7]
    23FF: 11 7F    SUB   A,127
    2401: 69 FA    ASR   [X-6]
    2403: 2F FA 80 OR    [X-6],128
    2406: 56 F9 00 MOV   [X-7],0
    2409: 39 80    CMP   A,128
    240B: D0 19    JNC   0x2425
    240D: 39 17    CMP   A,23
    240F: C0 20    JC    0x2430
    2411: A0 3C    JZ    0x244E
    2413: 39 20    CMP   A,32
    2415: C0 2B    JC    0x2441
    2417: 56 F9 7F MOV   [X-7],127
    241A: 56 FA FF MOV   [X-6],255
    241D: 56 FB FF MOV   [X-5],255
    2420: 56 FC FF MOV   [X-4],255
    2423: 80 2A    JMP   0x244E
    2425: 56 FA 00 MOV   [X-6],0
    2428: 56 FB 00 MOV   [X-5],0
    242B: 56 FC 00 MOV   [X-4],0
    242E: 80 1F    JMP   0x244E
    2430: 73       CPL   A
    2431: 74       INC   A
    2432: 01 17    ADD   A,23
    2434: 69 F9    ASR   [X-7]
    2436: 6F FA    RRC   [X-6]
    2438: 6F FB    RRC   [X-5]
    243A: 6F FC    RRC   [X-4]
    243C: 78       DEC   A
    243D: BF F6    JNZ   0x2434
    243F: 80 0E    JMP   0x244E
    2441: 11 17    SUB   A,23
    2443: 66 FC    ASL   [X-4]
    2445: 6C FB    RLC   [X-5]
    2447: 6C FA    RLC   [X-6]
    2449: 6C F9    RLC   [X-7]
    244B: 78       DEC   A
    244C: BF F6    JNZ   0x2443
    244E: 18       POP   A
    244F: 39 80    CMP   A,128
    2451: C0 19    JC    0x246B
    2453: 50 00    MOV   A,0
    2455: 13 FC    SUB   A,[X-4]
    2457: 54 FC    MOV   [X-4],A
    2459: 50 00    MOV   A,0
    245B: 1B FB    SBB   A,[X-5]
    245D: 54 FB    MOV   [X-5],A
    245F: 50 00    MOV   A,0
    2461: 1B FA    SBB   A,[X-6]
    2463: 54 FA    MOV   [X-6],A
    2465: 50 00    MOV   A,0
    2467: 1B F9    SBB   A,[X-7]
    2469: 54 F9    MOV   [X-7],A
    246B: 20       POP   X
    246C: 7F       RET   
__long2fp:
    246D: 10       PUSH  X
    246E: 4F       MOV   X,SP
    246F: 4B       SWAP  A,X
    2470: 11 07    SUB   A,7
    2472: 4B       SWAP  A,X
    2473: 9B DD    CALL  __tst_s32
    2475: A0 5F    JZ    0x24D5
    2477: 4F       MOV   X,SP
    2478: 52 F9    MOV   A,[X-7]
    247A: 08       PUSH  A
    247B: 50 96    MOV   A,150
    247D: 08       PUSH  A
    247E: 48 00 80 TST   [X+0],128
    2481: A0 19    JZ    0x249B
    2483: 50 00    MOV   A,0
    2485: 13 FC    SUB   A,[X-4]
    2487: 54 FC    MOV   [X-4],A
    2489: 50 00    MOV   A,0
    248B: 1B FB    SBB   A,[X-5]
    248D: 54 FB    MOV   [X-5],A
    248F: 50 00    MOV   A,0
    2491: 1B FA    SBB   A,[X-6]
    2493: 54 FA    MOV   [X-6],A
    2495: 50 00    MOV   A,0
    2497: 1B F9    SBB   A,[X-7]
    2499: 54 F9    MOV   [X-7],A
    249B: 48 F9 FF TST   [X-7],255
    249E: A0 1E    JZ    0x24BD
    24A0: 80 0B    JMP   0x24AC
    24A2: 69 F9    ASR   [X-7]
    24A4: 6F FA    RRC   [X-6]
    24A6: 6F FB    RRC   [X-5]
    24A8: 6F FC    RRC   [X-4]
    24AA: 77 01    INC   [X+1]
    24AC: 48 F9 FF TST   [X-7],255
    24AF: BF F2    JNZ   0x24A2
    24B1: 80 10    JMP   0x24C2
    24B3: 66 FC    ASL   [X-4]
    24B5: 6C FB    RLC   [X-5]
    24B7: 6C FA    RLC   [X-6]
    24B9: 6C F9    RLC   [X-7]
    24BB: 7B 01    DEC   [X+1]
    24BD: 48 FA 80 TST   [X-6],128
    24C0: AF F2    JZ    0x24B3
    24C2: 18       POP   A
    24C3: 66 FA    ASL   [X-6]
    24C5: 54 F9    MOV   [X-7],A
    24C7: 70 FB    AND   F,251
    24C9: 6F F9    RRC   [X-7]
    24CB: 6F FA    RRC   [X-6]
    24CD: 18       POP   A
    24CE: 39 80    CMP   A,128
    24D0: C0 04    JC    0x24D5
    24D2: 2F F9 80 OR    [X-7],128
    24D5: 20       POP   X
    24D6: 7F       RET   
_itoa:
    24D7: 10       PUSH  X
    24D8: 4F       MOV   X,SP
    24D9: 38 07    ADD   SP,7
    24DB: 56 06 00 MOV   [X+6],0
    24DE: 52 FA    MOV   A,[X-6]
    24E0: 54 03    MOV   [X+3],A
    24E2: 52 F9    MOV   A,[X-7]
    24E4: 54 02    MOV   [X+2],A
    24E6: 52 FA    MOV   A,[X-6]
    24E8: 11 00    SUB   A,0
    24EA: 52 F9    MOV   A,[X-7]
    24EC: 31 80    XOR   A,128
    24EE: 19 80    SBB   A,128
    24F0: D0 29    JNC   0x251A
    24F2: 3D F7 00 CMP   [X-9],0
    24F5: B0 24    JNZ   0x251A
    24F7: 3D F8 0A CMP   [X-8],10
    24FA: B0 1F    JNZ   0x251A
    24FC: 56 06 01 MOV   [X+6],1
    24FF: 62 D0 00 MOV   REG[208],0
    2502: 52 03    MOV   A,[X+3]
    2504: 73       CPL   A
    2505: 53 1A    MOV   [__r1],A
    2507: 52 02    MOV   A,[X+2]
    2509: 73       CPL   A
    250A: 53 1B    MOV   [__r0],A
    250C: 51 1A    MOV   A,[__r1]
    250E: 01 01    ADD   A,1
    2510: 54 03    MOV   [X+3],A
    2512: 51 1B    MOV   A,[__r0]
    2514: 09 00    ADC   A,0
    2516: 54 02    MOV   [X+2],A
    2518: 80 04    JMP   0x251D
    251A: 56 06 00 MOV   [X+6],0
    251D: 52 FC    MOV   A,[X-4]
    251F: 54 01    MOV   [X+1],A
    2521: 52 FB    MOV   A,[X-5]
    2523: 54 00    MOV   [X+0],A
    2525: 62 D0 00 MOV   REG[208],0
    2528: 52 01    MOV   A,[X+1]
    252A: 53 1A    MOV   [__r1],A
    252C: 52 00    MOV   A,[X+0]
    252E: 53 1B    MOV   [__r0],A
    2530: 51 1A    MOV   A,[__r1]
    2532: 01 01    ADD   A,1
    2534: 54 01    MOV   [X+1],A
    2536: 51 1B    MOV   A,[__r0]
    2538: 09 00    ADC   A,0
    253A: 54 00    MOV   [X+0],A
    253C: 52 F7    MOV   A,[X-9]
    253E: 08       PUSH  A
    253F: 52 F8    MOV   A,[X-8]
    2541: 08       PUSH  A
    2542: 52 02    MOV   A,[X+2]
    2544: 08       PUSH  A
    2545: 52 03    MOV   A,[X+3]
    2547: 08       PUSH  A
    2548: 7C 1E 59 LCALL __divmodu_16X16_16
    254B: 38 FE    ADD   SP,254
    254D: 18       POP   A
    254E: 53 18    MOV   [__r3],A
    2550: 18       POP   A
    2551: 53 19    MOV   [__r2],A
    2553: 06 18 1A ADD   [__r3],26
    2556: 0E 19 03 ADC   [__r2],3
    2559: 51 19    MOV   A,[__r2]
    255B: 10       PUSH  X
    255C: 58 18    MOV   X,[__r3]
    255E: 28       ROMX  
    255F: 20       POP   X
    2560: 53 19    MOV   [__r2],A
    2562: 51 1B    MOV   A,[__r0]
    2564: 60 D5    MOV   REG[213],A
    2566: 51 19    MOV   A,[__r2]
    2568: 3F 1A    MVI   [__r1],A
    256A: 52 F7    MOV   A,[X-9]
    256C: 08       PUSH  A
    256D: 52 F8    MOV   A,[X-8]
    256F: 08       PUSH  A
    2570: 52 02    MOV   A,[X+2]
    2572: 08       PUSH  A
    2573: 52 03    MOV   A,[X+3]
    2575: 08       PUSH  A
    2576: 7C 1E 59 LCALL __divmodu_16X16_16
    2579: 18       POP   A
    257A: 54 03    MOV   [X+3],A
    257C: 18       POP   A
    257D: 54 02    MOV   [X+2],A
    257F: 38 FE    ADD   SP,254
    2581: 3D 02 00 CMP   [X+2],0
    2584: BF A0    JNZ   0x2525
    2586: 3D 03 00 CMP   [X+3],0
    2589: BF 9B    JNZ   0x2525
    258B: 3D 06 00 CMP   [X+6],0
    258E: A0 20    JZ    0x25AF
    2590: 62 D0 00 MOV   REG[208],0
    2593: 52 01    MOV   A,[X+1]
    2595: 53 1A    MOV   [__r1],A
    2597: 52 00    MOV   A,[X+0]
    2599: 53 1B    MOV   [__r0],A
    259B: 51 1A    MOV   A,[__r1]
    259D: 01 01    ADD   A,1
    259F: 54 01    MOV   [X+1],A
    25A1: 51 1B    MOV   A,[__r0]
    25A3: 09 00    ADC   A,0
    25A5: 54 00    MOV   [X+0],A
    25A7: 51 1B    MOV   A,[__r0]
    25A9: 60 D5    MOV   REG[213],A
    25AB: 50 2D    MOV   A,45
    25AD: 3F 1A    MVI   [__r1],A
    25AF: 62 D0 00 MOV   REG[208],0
    25B2: 52 01    MOV   A,[X+1]
    25B4: 53 1A    MOV   [__r1],A
    25B6: 52 00    MOV   A,[X+0]
    25B8: 53 1B    MOV   [__r0],A
    25BA: 51 1A    MOV   A,[__r1]
    25BC: 01 FF    ADD   A,255
    25BE: 54 01    MOV   [X+1],A
    25C0: 51 1B    MOV   A,[__r0]
    25C2: 09 FF    ADC   A,255
    25C4: 54 00    MOV   [X+0],A
    25C6: 51 1B    MOV   A,[__r0]
    25C8: 60 D5    MOV   REG[213],A
    25CA: 50 00    MOV   A,0
    25CC: 3F 1A    MVI   [__r1],A
    25CE: 52 FC    MOV   A,[X-4]
    25D0: 54 05    MOV   [X+5],A
    25D2: 52 FB    MOV   A,[X-5]
    25D4: 54 04    MOV   [X+4],A
    25D6: 80 54    JMP   0x262B
    25D8: 62 D0 00 MOV   REG[208],0
    25DB: 52 05    MOV   A,[X+5]
    25DD: 53 1A    MOV   [__r1],A
    25DF: 52 04    MOV   A,[X+4]
    25E1: 60 D4    MOV   REG[212],A
    25E3: 3E 1A    MVI   A,[__r1]
    25E5: 54 06    MOV   [X+6],A
    25E7: 52 05    MOV   A,[X+5]
    25E9: 53 1A    MOV   [__r1],A
    25EB: 52 04    MOV   A,[X+4]
    25ED: 53 1B    MOV   [__r0],A
    25EF: 51 1A    MOV   A,[__r1]
    25F1: 01 01    ADD   A,1
    25F3: 54 05    MOV   [X+5],A
    25F5: 51 1B    MOV   A,[__r0]
    25F7: 09 00    ADC   A,0
    25F9: 54 04    MOV   [X+4],A
    25FB: 52 01    MOV   A,[X+1]
    25FD: 53 18    MOV   [__r3],A
    25FF: 52 00    MOV   A,[X+0]
    2601: 60 D4    MOV   REG[212],A
    2603: 3E 18    MVI   A,[__r3]
    2605: 53 19    MOV   [__r2],A
    2607: 51 1B    MOV   A,[__r0]
    2609: 60 D5    MOV   REG[213],A
    260B: 51 19    MOV   A,[__r2]
    260D: 3F 1A    MVI   [__r1],A
    260F: 52 01    MOV   A,[X+1]
    2611: 53 1A    MOV   [__r1],A
    2613: 52 00    MOV   A,[X+0]
    2615: 53 1B    MOV   [__r0],A
    2617: 51 1A    MOV   A,[__r1]
    2619: 01 FF    ADD   A,255
    261B: 54 01    MOV   [X+1],A
    261D: 51 1B    MOV   A,[__r0]
    261F: 09 FF    ADC   A,255
    2621: 54 00    MOV   [X+0],A
    2623: 51 1B    MOV   A,[__r0]
    2625: 60 D5    MOV   REG[213],A
    2627: 52 06    MOV   A,[X+6]
    2629: 3F 1A    MVI   [__r1],A
    262B: 52 05    MOV   A,[X+5]
    262D: 13 01    SUB   A,[X+1]
    262F: 52 04    MOV   A,[X+4]
    2631: 1B 00    SBB   A,[X+0]
    2633: CF A4    JC    0x25D8
    2635: 62 D0 00 MOV   REG[208],0
    2638: 52 FC    MOV   A,[X-4]
    263A: 53 1A    MOV   [__r1],A
    263C: 52 FB    MOV   A,[X-5]
    263E: 53 1B    MOV   [__r0],A
    2640: 38 F9    ADD   SP,249
    2642: 20       POP   X
    2643: 7F       RET   
_frexp:
    2644: 10       PUSH  X
    2645: 4F       MOV   X,SP
    2646: 38 08    ADD   SP,8
    2648: 50 00    MOV   A,0
    264A: 08       PUSH  A
    264B: 08       PUSH  A
    264C: 08       PUSH  A
    264D: 08       PUSH  A
    264E: 52 F9    MOV   A,[X-7]
    2650: 08       PUSH  A
    2651: 52 FA    MOV   A,[X-6]
    2653: 08       PUSH  A
    2654: 52 FB    MOV   A,[X-5]
    2656: 08       PUSH  A
    2657: 52 FC    MOV   A,[X-4]
    2659: 08       PUSH  A
    265A: 62 D0 00 MOV   REG[208],0
    265D: 7C 23 8C LCALL __fpcmp
    2660: 38 F8    ADD   SP,248
    2662: 39 00    CMP   A,0
    2664: B0 1D    JNZ   0x2682
    2666: 52 F8    MOV   A,[X-8]
    2668: 53 1A    MOV   [__r1],A
    266A: 52 F7    MOV   A,[X-9]
    266C: 60 D5    MOV   REG[213],A
    266E: 50 00    MOV   A,0
    2670: 3F 1A    MVI   [__r1],A
    2672: 3F 1A    MVI   [__r1],A
    2674: 55 1B 00 MOV   [__r0],0
    2677: 55 1A 00 MOV   [__r1],0
    267A: 55 19 00 MOV   [__r2],0
    267D: 55 18 00 MOV   [__r3],0
    2680: 80 95    JMP   0x2716
    2682: 52 F9    MOV   A,[X-7]
    2684: 54 00    MOV   [X+0],A
    2686: 52 FA    MOV   A,[X-6]
    2688: 54 01    MOV   [X+1],A
    268A: 52 FB    MOV   A,[X-5]
    268C: 54 02    MOV   [X+2],A
    268E: 52 FC    MOV   A,[X-4]
    2690: 54 03    MOV   [X+3],A
    2692: 66 01    ASL   [X+1]
    2694: 6C 00    RLC   [X+0]
    2696: 62 D0 00 MOV   REG[208],0
    2699: 52 00    MOV   A,[X+0]
    269B: 53 1A    MOV   [__r1],A
    269D: 55 1B 00 MOV   [__r0],0
    26A0: 16 1A 7E SUB   [__r1],126
    26A3: 1E 1B 00 SBB   [__r0],0
    26A6: 52 F8    MOV   A,[X-8]
    26A8: 53 18    MOV   [__r3],A
    26AA: 52 F7    MOV   A,[X-9]
    26AC: 60 D5    MOV   REG[213],A
    26AE: 51 1B    MOV   A,[__r0]
    26B0: 3F 18    MVI   [__r3],A
    26B2: 51 1A    MOV   A,[__r1]
    26B4: 3F 18    MVI   [__r3],A
    26B6: 56 00 7E MOV   [X+0],126
    26B9: 70 FB    AND   F,251
    26BB: 6F 00    RRC   [X+0]
    26BD: 6F 01    RRC   [X+1]
    26BF: 50 00    MOV   A,0
    26C1: 08       PUSH  A
    26C2: 08       PUSH  A
    26C3: 08       PUSH  A
    26C4: 08       PUSH  A
    26C5: 52 F9    MOV   A,[X-7]
    26C7: 08       PUSH  A
    26C8: 52 FA    MOV   A,[X-6]
    26CA: 08       PUSH  A
    26CB: 52 FB    MOV   A,[X-5]
    26CD: 08       PUSH  A
    26CE: 52 FC    MOV   A,[X-4]
    26D0: 08       PUSH  A
    26D1: 7C 23 8C LCALL __fpcmp
    26D4: 38 F8    ADD   SP,248
    26D6: 39 00    CMP   A,0
    26D8: A0 1A    JZ    0x26F3
    26DA: 39 01    CMP   A,1
    26DC: A0 16    JZ    0x26F3
    26DE: 52 00    MOV   A,[X+0]
    26E0: 54 04    MOV   [X+4],A
    26E2: 52 01    MOV   A,[X+1]
    26E4: 54 05    MOV   [X+5],A
    26E6: 52 02    MOV   A,[X+2]
    26E8: 54 06    MOV   [X+6],A
    26EA: 52 03    MOV   A,[X+3]
    26EC: 54 07    MOV   [X+7],A
    26EE: 37 04 80 XOR   [X+4],128
    26F1: 80 11    JMP   0x2703
    26F3: 52 00    MOV   A,[X+0]
    26F5: 54 04    MOV   [X+4],A
    26F7: 52 01    MOV   A,[X+1]
    26F9: 54 05    MOV   [X+5],A
    26FB: 52 02    MOV   A,[X+2]
    26FD: 54 06    MOV   [X+6],A
    26FF: 52 03    MOV   A,[X+3]
    2701: 54 07    MOV   [X+7],A
    2703: 62 D0 00 MOV   REG[208],0
    2706: 52 04    MOV   A,[X+4]
    2708: 53 1B    MOV   [__r0],A
    270A: 52 05    MOV   A,[X+5]
    270C: 53 1A    MOV   [__r1],A
    270E: 52 06    MOV   A,[X+6]
    2710: 53 19    MOV   [__r2],A
    2712: 52 07    MOV   A,[X+7]
    2714: 53 18    MOV   [__r3],A
    2716: 38 F8    ADD   SP,248
    2718: 20       POP   X
    2719: 7F       RET   
_log:
    271A: 10       PUSH  X
    271B: 4F       MOV   X,SP
    271C: 38 06    ADD   SP,6
    271E: 50 00    MOV   A,0
    2720: 08       PUSH  A
    2721: 08       PUSH  A
    2722: 08       PUSH  A
    2723: 08       PUSH  A
    2724: 52 F9    MOV   A,[X-7]
    2726: 08       PUSH  A
    2727: 52 FA    MOV   A,[X-6]
    2729: 08       PUSH  A
    272A: 52 FB    MOV   A,[X-5]
    272C: 08       PUSH  A
    272D: 52 FC    MOV   A,[X-4]
    272F: 08       PUSH  A
    2730: 62 D0 00 MOV   REG[208],0
    2733: 7C 23 8C LCALL __fpcmp
    2736: 38 F8    ADD   SP,248
    2738: 39 01    CMP   A,1
    273A: A0 1B    JZ    0x2756
    273C: 62 D0 00 MOV   REG[208],0
    273F: 55 3B 01 MOV   [errno+1],1
    2742: 55 3A 00 MOV   [errno],0
    2745: 62 D0 00 MOV   REG[208],0
    2748: 55 1B FF MOV   [__r0],255
    274B: 55 1A 7F MOV   [__r1],127
    274E: 55 19 FF MOV   [__r2],255
    2751: 55 18 FF MOV   [__r3],255
    2754: 82 70    JMP   0x29C5
    2756: 62 D0 00 MOV   REG[208],0
    2759: 5A 1A    MOV   [__r1],X
    275B: 06 1A 04 ADD   [__r1],4
    275E: 50 07    MOV   A,7
    2760: 08       PUSH  A
    2761: 51 1A    MOV   A,[__r1]
    2763: 08       PUSH  A
    2764: 52 F9    MOV   A,[X-7]
    2766: 08       PUSH  A
    2767: 52 FA    MOV   A,[X-6]
    2769: 08       PUSH  A
    276A: 52 FB    MOV   A,[X-5]
    276C: 08       PUSH  A
    276D: 52 FC    MOV   A,[X-4]
    276F: 08       PUSH  A
    2770: 7C 26 44 LCALL _frexp
    2773: 38 FA    ADD   SP,250
    2775: 62 D0 00 MOV   REG[208],0
    2778: 51 1B    MOV   A,[__r0]
    277A: 54 F9    MOV   [X-7],A
    277C: 51 1A    MOV   A,[__r1]
    277E: 54 FA    MOV   [X-6],A
    2780: 51 19    MOV   A,[__r2]
    2782: 54 FB    MOV   [X-5],A
    2784: 51 18    MOV   A,[__r3]
    2786: 54 FC    MOV   [X-4],A
    2788: 50 3F    MOV   A,63
    278A: 08       PUSH  A
    278B: 50 35    MOV   A,53
    278D: 08       PUSH  A
    278E: 50 04    MOV   A,4
    2790: 08       PUSH  A
    2791: 50 F3    MOV   A,243
    2793: 08       PUSH  A
    2794: 52 F9    MOV   A,[X-7]
    2796: 08       PUSH  A
    2797: 52 FA    MOV   A,[X-6]
    2799: 08       PUSH  A
    279A: 52 FB    MOV   A,[X-5]
    279C: 08       PUSH  A
    279D: 52 FC    MOV   A,[X-4]
    279F: 08       PUSH  A
    27A0: 7C 23 8C LCALL __fpcmp
    27A3: 38 F8    ADD   SP,248
    27A5: 39 00    CMP   A,0
    27A7: A0 33    JZ    0x27DB
    27A9: 39 01    CMP   A,1
    27AB: A0 2F    JZ    0x27DB
    27AD: 52 F9    MOV   A,[X-7]
    27AF: 08       PUSH  A
    27B0: 52 FA    MOV   A,[X-6]
    27B2: 08       PUSH  A
    27B3: 52 FB    MOV   A,[X-5]
    27B5: 08       PUSH  A
    27B6: 52 FC    MOV   A,[X-4]
    27B8: 08       PUSH  A
    27B9: 52 F9    MOV   A,[X-7]
    27BB: 08       PUSH  A
    27BC: 52 FA    MOV   A,[X-6]
    27BE: 08       PUSH  A
    27BF: 52 FB    MOV   A,[X-5]
    27C1: 08       PUSH  A
    27C2: 52 FC    MOV   A,[X-4]
    27C4: 08       PUSH  A
    27C5: 7C 20 B6 LCALL __fpadd
    27C8: 18       POP   A
    27C9: 54 FC    MOV   [X-4],A
    27CB: 18       POP   A
    27CC: 54 FB    MOV   [X-5],A
    27CE: 18       POP   A
    27CF: 54 FA    MOV   [X-6],A
    27D1: 18       POP   A
    27D2: 54 F9    MOV   [X-7],A
    27D4: 38 FC    ADD   SP,252
    27D6: 7B 05    DEC   [X+5]
    27D8: 1F 04 00 SBB   [X+4],0
    27DB: 62 D0 00 MOV   REG[208],0
    27DE: 50 3F    MOV   A,63
    27E0: 08       PUSH  A
    27E1: 50 80    MOV   A,128
    27E3: 08       PUSH  A
    27E4: 50 00    MOV   A,0
    27E6: 08       PUSH  A
    27E7: 08       PUSH  A
    27E8: 52 F9    MOV   A,[X-7]
    27EA: 08       PUSH  A
    27EB: 52 FA    MOV   A,[X-6]
    27ED: 08       PUSH  A
    27EE: 52 FB    MOV   A,[X-5]
    27F0: 08       PUSH  A
    27F1: 52 FC    MOV   A,[X-4]
    27F3: 08       PUSH  A
    27F4: 7C 20 A8 LCALL __fpsub
    27F7: 18       POP   A
    27F8: 53 18    MOV   [__r3],A
    27FA: 18       POP   A
    27FB: 53 19    MOV   [__r2],A
    27FD: 18       POP   A
    27FE: 53 1A    MOV   [__r1],A
    2800: 18       POP   A
    2801: 53 1B    MOV   [__r0],A
    2803: 38 FC    ADD   SP,252
    2805: 50 3F    MOV   A,63
    2807: 08       PUSH  A
    2808: 50 80    MOV   A,128
    280A: 08       PUSH  A
    280B: 50 00    MOV   A,0
    280D: 08       PUSH  A
    280E: 08       PUSH  A
    280F: 52 F9    MOV   A,[X-7]
    2811: 08       PUSH  A
    2812: 52 FA    MOV   A,[X-6]
    2814: 08       PUSH  A
    2815: 52 FB    MOV   A,[X-5]
    2817: 08       PUSH  A
    2818: 52 FC    MOV   A,[X-4]
    281A: 08       PUSH  A
    281B: 7C 20 B6 LCALL __fpadd
    281E: 18       POP   A
    281F: 53 14    MOV   [__r7],A
    2821: 18       POP   A
    2822: 53 15    MOV   [__r6],A
    2824: 18       POP   A
    2825: 53 16    MOV   [__r5],A
    2827: 18       POP   A
    2828: 38 FC    ADD   SP,252
    282A: 08       PUSH  A
    282B: 51 16    MOV   A,[__r5]
    282D: 08       PUSH  A
    282E: 51 15    MOV   A,[__r6]
    2830: 08       PUSH  A
    2831: 51 14    MOV   A,[__r7]
    2833: 08       PUSH  A
    2834: 51 1B    MOV   A,[__r0]
    2836: 08       PUSH  A
    2837: 51 1A    MOV   A,[__r1]
    2839: 08       PUSH  A
    283A: 51 19    MOV   A,[__r2]
    283C: 08       PUSH  A
    283D: 51 18    MOV   A,[__r3]
    283F: 08       PUSH  A
    2840: 7C 22 83 LCALL __fpdiv
    2843: 18       POP   A
    2844: 54 FC    MOV   [X-4],A
    2846: 18       POP   A
    2847: 54 FB    MOV   [X-5],A
    2849: 18       POP   A
    284A: 54 FA    MOV   [X-6],A
    284C: 18       POP   A
    284D: 54 F9    MOV   [X-7],A
    284F: 38 FC    ADD   SP,252
    2851: 52 F9    MOV   A,[X-7]
    2853: 08       PUSH  A
    2854: 52 FA    MOV   A,[X-6]
    2856: 08       PUSH  A
    2857: 52 FB    MOV   A,[X-5]
    2859: 08       PUSH  A
    285A: 52 FC    MOV   A,[X-4]
    285C: 08       PUSH  A
    285D: 52 F9    MOV   A,[X-7]
    285F: 08       PUSH  A
    2860: 52 FA    MOV   A,[X-6]
    2862: 08       PUSH  A
    2863: 52 FB    MOV   A,[X-5]
    2865: 08       PUSH  A
    2866: 52 FC    MOV   A,[X-4]
    2868: 08       PUSH  A
    2869: 7C 21 9A LCALL __fpmul
    286C: 18       POP   A
    286D: 54 03    MOV   [X+3],A
    286F: 18       POP   A
    2870: 54 02    MOV   [X+2],A
    2872: 18       POP   A
    2873: 54 01    MOV   [X+1],A
    2875: 18       POP   A
    2876: 54 00    MOV   [X+0],A
    2878: 38 FC    ADD   SP,252
    287A: 52 00    MOV   A,[X+0]
    287C: 08       PUSH  A
    287D: 52 01    MOV   A,[X+1]
    287F: 08       PUSH  A
    2880: 52 02    MOV   A,[X+2]
    2882: 08       PUSH  A
    2883: 52 03    MOV   A,[X+3]
    2885: 08       PUSH  A
    2886: 50 3F    MOV   A,63
    2888: 08       PUSH  A
    2889: 50 65    MOV   A,101
    288B: 08       PUSH  A
    288C: 50 42    MOV   A,66
    288E: 08       PUSH  A
    288F: 50 26    MOV   A,38
    2891: 08       PUSH  A
    2892: 7C 21 9A LCALL __fpmul
    2895: 18       POP   A
    2896: 53 18    MOV   [__r3],A
    2898: 18       POP   A
    2899: 53 19    MOV   [__r2],A
    289B: 18       POP   A
    289C: 53 1A    MOV   [__r1],A
    289E: 18       POP   A
    289F: 53 1B    MOV   [__r0],A
    28A1: 38 FC    ADD   SP,252
    28A3: 50 40    MOV   A,64
    28A5: 08       PUSH  A
    28A6: 50 54    MOV   A,84
    28A8: 08       PUSH  A
    28A9: 50 11    MOV   A,17
    28AB: 08       PUSH  A
    28AC: 50 4E    MOV   A,78
    28AE: 08       PUSH  A
    28AF: 51 1B    MOV   A,[__r0]
    28B1: 08       PUSH  A
    28B2: 51 1A    MOV   A,[__r1]
    28B4: 08       PUSH  A
    28B5: 51 19    MOV   A,[__r2]
    28B7: 08       PUSH  A
    28B8: 51 18    MOV   A,[__r3]
    28BA: 08       PUSH  A
    28BB: 7C 20 A8 LCALL __fpsub
    28BE: 18       POP   A
    28BF: 53 18    MOV   [__r3],A
    28C1: 18       POP   A
    28C2: 53 19    MOV   [__r2],A
    28C4: 18       POP   A
    28C5: 53 1A    MOV   [__r1],A
    28C7: 18       POP   A
    28C8: 38 FC    ADD   SP,252
    28CA: 08       PUSH  A
    28CB: 51 1A    MOV   A,[__r1]
    28CD: 08       PUSH  A
    28CE: 51 19    MOV   A,[__r2]
    28D0: 08       PUSH  A
    28D1: 51 18    MOV   A,[__r3]
    28D3: 08       PUSH  A
    28D4: 52 F9    MOV   A,[X-7]
    28D6: 08       PUSH  A
    28D7: 52 FA    MOV   A,[X-6]
    28D9: 08       PUSH  A
    28DA: 52 FB    MOV   A,[X-5]
    28DC: 08       PUSH  A
    28DD: 52 FC    MOV   A,[X-4]
    28DF: 08       PUSH  A
    28E0: 7C 21 9A LCALL __fpmul
    28E3: 18       POP   A
    28E4: 53 18    MOV   [__r3],A
    28E6: 18       POP   A
    28E7: 53 19    MOV   [__r2],A
    28E9: 18       POP   A
    28EA: 53 1A    MOV   [__r1],A
    28EC: 18       POP   A
    28ED: 53 1B    MOV   [__r0],A
    28EF: 38 FC    ADD   SP,252
    28F1: 50 3F    MOV   A,63
    28F3: 08       PUSH  A
    28F4: 50 D4    MOV   A,212
    28F6: 08       PUSH  A
    28F7: 50 11    MOV   A,17
    28F9: 08       PUSH  A
    28FA: 50 4D    MOV   A,77
    28FC: 08       PUSH  A
    28FD: 52 00    MOV   A,[X+0]
    28FF: 08       PUSH  A
    2900: 52 01    MOV   A,[X+1]
    2902: 08       PUSH  A
    2903: 52 02    MOV   A,[X+2]
    2905: 08       PUSH  A
    2906: 52 03    MOV   A,[X+3]
    2908: 08       PUSH  A
    2909: 7C 20 A8 LCALL __fpsub
    290C: 18       POP   A
    290D: 53 14    MOV   [__r7],A
    290F: 18       POP   A
    2910: 53 15    MOV   [__r6],A
    2912: 18       POP   A
    2913: 53 16    MOV   [__r5],A
    2915: 18       POP   A
    2916: 38 FC    ADD   SP,252
    2918: 08       PUSH  A
    2919: 51 16    MOV   A,[__r5]
    291B: 08       PUSH  A
    291C: 51 15    MOV   A,[__r6]
    291E: 08       PUSH  A
    291F: 51 14    MOV   A,[__r7]
    2921: 08       PUSH  A
    2922: 51 1B    MOV   A,[__r0]
    2924: 08       PUSH  A
    2925: 51 1A    MOV   A,[__r1]
    2927: 08       PUSH  A
    2928: 51 19    MOV   A,[__r2]
    292A: 08       PUSH  A
    292B: 51 18    MOV   A,[__r3]
    292D: 08       PUSH  A
    292E: 7C 22 83 LCALL __fpdiv
    2931: 18       POP   A
    2932: 53 18    MOV   [__r3],A
    2934: 18       POP   A
    2935: 53 19    MOV   [__r2],A
    2937: 18       POP   A
    2938: 53 1A    MOV   [__r1],A
    293A: 18       POP   A
    293B: 53 1B    MOV   [__r0],A
    293D: 38 FC    ADD   SP,252
    293F: 52 05    MOV   A,[X+5]
    2941: 53 14    MOV   [__r7],A
    2943: 52 04    MOV   A,[X+4]
    2945: 53 15    MOV   [__r6],A
    2947: 47 15 80 TST   [__r6],128
    294A: A0 09    JZ    0x2954
    294C: 55 16 FF MOV   [__r5],255
    294F: 55 17 FF MOV   [__r4],255
    2952: 80 0A    JMP   0x295D
    2954: 62 D0 00 MOV   REG[208],0
    2957: 55 16 00 MOV   [__r5],0
    295A: 55 17 00 MOV   [__r4],0
    295D: 62 D0 00 MOV   REG[208],0
    2960: 51 17    MOV   A,[__r4]
    2962: 08       PUSH  A
    2963: 51 16    MOV   A,[__r5]
    2965: 08       PUSH  A
    2966: 51 15    MOV   A,[__r6]
    2968: 08       PUSH  A
    2969: 51 14    MOV   A,[__r7]
    296B: 08       PUSH  A
    296C: 7C 24 6D LCALL __long2fp
    296F: 18       POP   A
    2970: 53 14    MOV   [__r7],A
    2972: 18       POP   A
    2973: 53 15    MOV   [__r6],A
    2975: 18       POP   A
    2976: 53 16    MOV   [__r5],A
    2978: 18       POP   A
    2979: 08       PUSH  A
    297A: 51 16    MOV   A,[__r5]
    297C: 08       PUSH  A
    297D: 51 15    MOV   A,[__r6]
    297F: 08       PUSH  A
    2980: 51 14    MOV   A,[__r7]
    2982: 08       PUSH  A
    2983: 50 3F    MOV   A,63
    2985: 08       PUSH  A
    2986: 50 31    MOV   A,49
    2988: 08       PUSH  A
    2989: 50 72    MOV   A,114
    298B: 08       PUSH  A
    298C: 50 18    MOV   A,24
    298E: 08       PUSH  A
    298F: 7C 21 9A LCALL __fpmul
    2992: 18       POP   A
    2993: 53 14    MOV   [__r7],A
    2995: 18       POP   A
    2996: 53 15    MOV   [__r6],A
    2998: 18       POP   A
    2999: 53 16    MOV   [__r5],A
    299B: 18       POP   A
    299C: 38 FC    ADD   SP,252
    299E: 08       PUSH  A
    299F: 51 16    MOV   A,[__r5]
    29A1: 08       PUSH  A
    29A2: 51 15    MOV   A,[__r6]
    29A4: 08       PUSH  A
    29A5: 51 14    MOV   A,[__r7]
    29A7: 08       PUSH  A
    29A8: 51 1B    MOV   A,[__r0]
    29AA: 08       PUSH  A
    29AB: 51 1A    MOV   A,[__r1]
    29AD: 08       PUSH  A
    29AE: 51 19    MOV   A,[__r2]
    29B0: 08       PUSH  A
    29B1: 51 18    MOV   A,[__r3]
    29B3: 08       PUSH  A
    29B4: 7C 20 B6 LCALL __fpadd
    29B7: 18       POP   A
    29B8: 53 18    MOV   [__r3],A
    29BA: 18       POP   A
    29BB: 53 19    MOV   [__r2],A
    29BD: 18       POP   A
    29BE: 53 1A    MOV   [__r1],A
    29C0: 18       POP   A
    29C1: 53 1B    MOV   [__r0],A
    29C3: 38 FC    ADD   SP,252
    29C5: 38 FA    ADD   SP,250
    29C7: 20       POP   X
    29C8: 7F       RET   
_sqrt:
    29C9: 10       PUSH  X
    29CA: 4F       MOV   X,SP
    29CB: 38 0A    ADD   SP,10
    29CD: 50 00    MOV   A,0
    29CF: 08       PUSH  A
    29D0: 08       PUSH  A
    29D1: 08       PUSH  A
    29D2: 08       PUSH  A
    29D3: 52 F9    MOV   A,[X-7]
    29D5: 08       PUSH  A
    29D6: 52 FA    MOV   A,[X-6]
    29D8: 08       PUSH  A
    29D9: 52 FB    MOV   A,[X-5]
    29DB: 08       PUSH  A
    29DC: 52 FC    MOV   A,[X-4]
    29DE: 08       PUSH  A
    29DF: 62 D0 00 MOV   REG[208],0
    29E2: 7C 23 8C LCALL __fpcmp
    29E5: 38 F8    ADD   SP,248
    29E7: 39 00    CMP   A,0
    29E9: A0 1F    JZ    0x2A09
    29EB: 39 01    CMP   A,1
    29ED: A0 1B    JZ    0x2A09
    29EF: 62 D0 00 MOV   REG[208],0
    29F2: 55 3B 01 MOV   [errno+1],1
    29F5: 55 3A 00 MOV   [errno],0
    29F8: 62 D0 00 MOV   REG[208],0
    29FB: 55 1B 00 MOV   [__r0],0
    29FE: 55 1A 00 MOV   [__r1],0
    2A01: 55 19 00 MOV   [__r2],0
    2A04: 55 18 00 MOV   [__r3],0
    2A07: 83 36    JMP   0x2D3E
    2A09: 50 00    MOV   A,0
    2A0B: 08       PUSH  A
    2A0C: 08       PUSH  A
    2A0D: 08       PUSH  A
    2A0E: 08       PUSH  A
    2A0F: 52 F9    MOV   A,[X-7]
    2A11: 08       PUSH  A
    2A12: 52 FA    MOV   A,[X-6]
    2A14: 08       PUSH  A
    2A15: 52 FB    MOV   A,[X-5]
    2A17: 08       PUSH  A
    2A18: 52 FC    MOV   A,[X-4]
    2A1A: 08       PUSH  A
    2A1B: 62 D0 00 MOV   REG[208],0
    2A1E: 7C 23 8C LCALL __fpcmp
    2A21: 38 F8    ADD   SP,248
    2A23: 39 00    CMP   A,0
    2A25: B0 0F    JNZ   0x2A35
    2A27: 55 1B 00 MOV   [__r0],0
    2A2A: 55 1A 00 MOV   [__r1],0
    2A2D: 55 19 00 MOV   [__r2],0
    2A30: 55 18 00 MOV   [__r3],0
    2A33: 83 0A    JMP   0x2D3E
    2A35: 62 D0 00 MOV   REG[208],0
    2A38: 50 07    MOV   A,7
    2A3A: 08       PUSH  A
    2A3B: 10       PUSH  X
    2A3C: 52 F9    MOV   A,[X-7]
    2A3E: 08       PUSH  A
    2A3F: 52 FA    MOV   A,[X-6]
    2A41: 08       PUSH  A
    2A42: 52 FB    MOV   A,[X-5]
    2A44: 08       PUSH  A
    2A45: 52 FC    MOV   A,[X-4]
    2A47: 08       PUSH  A
    2A48: 7C 26 44 LCALL _frexp
    2A4B: 38 FA    ADD   SP,250
    2A4D: 62 D0 00 MOV   REG[208],0
    2A50: 51 1B    MOV   A,[__r0]
    2A52: 54 02    MOV   [X+2],A
    2A54: 51 1A    MOV   A,[__r1]
    2A56: 54 03    MOV   [X+3],A
    2A58: 51 19    MOV   A,[__r2]
    2A5A: 54 04    MOV   [X+4],A
    2A5C: 51 18    MOV   A,[__r3]
    2A5E: 54 05    MOV   [X+5],A
    2A60: 52 01    MOV   A,[X+1]
    2A62: 21 01    AND   A,1
    2A64: 53 1A    MOV   [__r1],A
    2A66: 52 00    MOV   A,[X+0]
    2A68: 21 00    AND   A,0
    2A6A: 39 00    CMP   A,0
    2A6C: B0 06    JNZ   0x2A73
    2A6E: 3C 1A 00 CMP   [__r1],0
    2A71: A0 32    JZ    0x2AA4
    2A73: 52 02    MOV   A,[X+2]
    2A75: 08       PUSH  A
    2A76: 52 03    MOV   A,[X+3]
    2A78: 08       PUSH  A
    2A79: 52 04    MOV   A,[X+4]
    2A7B: 08       PUSH  A
    2A7C: 52 05    MOV   A,[X+5]
    2A7E: 08       PUSH  A
    2A7F: 52 02    MOV   A,[X+2]
    2A81: 08       PUSH  A
    2A82: 52 03    MOV   A,[X+3]
    2A84: 08       PUSH  A
    2A85: 52 04    MOV   A,[X+4]
    2A87: 08       PUSH  A
    2A88: 52 05    MOV   A,[X+5]
    2A8A: 08       PUSH  A
    2A8B: 62 D0 00 MOV   REG[208],0
    2A8E: 7C 20 B6 LCALL __fpadd
    2A91: 18       POP   A
    2A92: 54 05    MOV   [X+5],A
    2A94: 18       POP   A
    2A95: 54 04    MOV   [X+4],A
    2A97: 18       POP   A
    2A98: 54 03    MOV   [X+3],A
    2A9A: 18       POP   A
    2A9B: 54 02    MOV   [X+2],A
    2A9D: 38 FC    ADD   SP,252
    2A9F: 7B 01    DEC   [X+1]
    2AA1: 1F 00 00 SBB   [X+0],0
    2AA4: 62 D0 00 MOV   REG[208],0
    2AA7: 50 3F    MOV   A,63
    2AA9: 08       PUSH  A
    2AAA: 50 80    MOV   A,128
    2AAC: 08       PUSH  A
    2AAD: 50 00    MOV   A,0
    2AAF: 08       PUSH  A
    2AB0: 08       PUSH  A
    2AB1: 52 02    MOV   A,[X+2]
    2AB3: 08       PUSH  A
    2AB4: 52 03    MOV   A,[X+3]
    2AB6: 08       PUSH  A
    2AB7: 52 04    MOV   A,[X+4]
    2AB9: 08       PUSH  A
    2ABA: 52 05    MOV   A,[X+5]
    2ABC: 08       PUSH  A
    2ABD: 7C 20 B6 LCALL __fpadd
    2AC0: 18       POP   A
    2AC1: 53 18    MOV   [__r3],A
    2AC3: 18       POP   A
    2AC4: 53 19    MOV   [__r2],A
    2AC6: 18       POP   A
    2AC7: 53 1A    MOV   [__r1],A
    2AC9: 18       POP   A
    2ACA: 38 FC    ADD   SP,252
    2ACC: 08       PUSH  A
    2ACD: 51 1A    MOV   A,[__r1]
    2ACF: 08       PUSH  A
    2AD0: 51 19    MOV   A,[__r2]
    2AD2: 08       PUSH  A
    2AD3: 51 18    MOV   A,[__r3]
    2AD5: 08       PUSH  A
    2AD6: 50 3F    MOV   A,63
    2AD8: 08       PUSH  A
    2AD9: 50 00    MOV   A,0
    2ADB: 08       PUSH  A
    2ADC: 08       PUSH  A
    2ADD: 08       PUSH  A
    2ADE: 7C 21 9A LCALL __fpmul
    2AE1: 18       POP   A
    2AE2: 54 05    MOV   [X+5],A
    2AE4: 18       POP   A
    2AE5: 54 04    MOV   [X+4],A
    2AE7: 18       POP   A
    2AE8: 54 03    MOV   [X+3],A
    2AEA: 18       POP   A
    2AEB: 54 02    MOV   [X+2],A
    2AED: 38 FC    ADD   SP,252
    2AEF: 80 31    JMP   0x2B21
    2AF1: 52 02    MOV   A,[X+2]
    2AF3: 08       PUSH  A
    2AF4: 52 03    MOV   A,[X+3]
    2AF6: 08       PUSH  A
    2AF7: 52 04    MOV   A,[X+4]
    2AF9: 08       PUSH  A
    2AFA: 52 05    MOV   A,[X+5]
    2AFC: 08       PUSH  A
    2AFD: 50 4E    MOV   A,78
    2AFF: 08       PUSH  A
    2B00: 50 80    MOV   A,128
    2B02: 08       PUSH  A
    2B03: 50 00    MOV   A,0
    2B05: 08       PUSH  A
    2B06: 08       PUSH  A
    2B07: 62 D0 00 MOV   REG[208],0
    2B0A: 7C 21 9A LCALL __fpmul
    2B0D: 18       POP   A
    2B0E: 54 05    MOV   [X+5],A
    2B10: 18       POP   A
    2B11: 54 04    MOV   [X+4],A
    2B13: 18       POP   A
    2B14: 54 03    MOV   [X+3],A
    2B16: 18       POP   A
    2B17: 54 02    MOV   [X+2],A
    2B19: 38 FC    ADD   SP,252
    2B1B: 17 01 3C SUB   [X+1],60
    2B1E: 1F 00 00 SBB   [X+0],0
    2B21: 50 3C    MOV   A,60
    2B23: 13 01    SUB   A,[X+1]
    2B25: 52 00    MOV   A,[X+0]
    2B27: 31 80    XOR   A,128
    2B29: 62 D0 00 MOV   REG[208],0
    2B2C: 53 0F    MOV   [__rX],A
    2B2E: 50 80    MOV   A,128
    2B30: 1A 0F    SBB   A,[__rX]
    2B32: CF BE    JC    0x2AF1
    2B34: 80 31    JMP   0x2B66
    2B36: 50 4E    MOV   A,78
    2B38: 08       PUSH  A
    2B39: 50 80    MOV   A,128
    2B3B: 08       PUSH  A
    2B3C: 50 00    MOV   A,0
    2B3E: 08       PUSH  A
    2B3F: 08       PUSH  A
    2B40: 52 02    MOV   A,[X+2]
    2B42: 08       PUSH  A
    2B43: 52 03    MOV   A,[X+3]
    2B45: 08       PUSH  A
    2B46: 52 04    MOV   A,[X+4]
    2B48: 08       PUSH  A
    2B49: 52 05    MOV   A,[X+5]
    2B4B: 08       PUSH  A
    2B4C: 62 D0 00 MOV   REG[208],0
    2B4F: 7C 22 83 LCALL __fpdiv
    2B52: 18       POP   A
    2B53: 54 05    MOV   [X+5],A
    2B55: 18       POP   A
    2B56: 54 04    MOV   [X+4],A
    2B58: 18       POP   A
    2B59: 54 03    MOV   [X+3],A
    2B5B: 18       POP   A
    2B5C: 54 02    MOV   [X+2],A
    2B5E: 38 FC    ADD   SP,252
    2B60: 07 01 3C ADD   [X+1],60
    2B63: 0F 00 00 ADC   [X+0],0
    2B66: 52 01    MOV   A,[X+1]
    2B68: 11 C4    SUB   A,196
    2B6A: 52 00    MOV   A,[X+0]
    2B6C: 31 80    XOR   A,128
    2B6E: 19 7F    SBB   A,127
    2B70: CF C5    JC    0x2B36
    2B72: 56 06 00 MOV   [X+6],0
    2B75: 56 07 00 MOV   [X+7],0
    2B78: 56 08 00 MOV   [X+8],0
    2B7B: 56 09 01 MOV   [X+9],1
    2B7E: 52 01    MOV   A,[X+1]
    2B80: 11 00    SUB   A,0
    2B82: 52 00    MOV   A,[X+0]
    2B84: 31 80    XOR   A,128
    2B86: 19 80    SBB   A,128
    2B88: C0 89    JC    0x2C12
    2B8A: 62 D0 00 MOV   REG[208],0
    2B8D: 52 01    MOV   A,[X+1]
    2B8F: 53 1A    MOV   [__r1],A
    2B91: 52 00    MOV   A,[X+0]
    2B93: 53 1B    MOV   [__r0],A
    2B95: 68 1B    ASR   [__r0]
    2B97: 6E 1A    RRC   [__r1]
    2B99: 52 06    MOV   A,[X+6]
    2B9B: 53 17    MOV   [__r4],A
    2B9D: 52 07    MOV   A,[X+7]
    2B9F: 53 16    MOV   [__r5],A
    2BA1: 52 08    MOV   A,[X+8]
    2BA3: 53 15    MOV   [__r6],A
    2BA5: 52 09    MOV   A,[X+9]
    2BA7: 53 14    MOV   [__r7],A
    2BA9: 51 1A    MOV   A,[__r1]
    2BAB: 21 1F    AND   A,31
    2BAD: A0 0F    JZ    0x2BBD
    2BAF: 62 D0 00 MOV   REG[208],0
    2BB2: 65 14    ASL   [__r7]
    2BB4: 6B 15    RLC   [__r6]
    2BB6: 6B 16    RLC   [__r5]
    2BB8: 6B 17    RLC   [__r4]
    2BBA: 78       DEC   A
    2BBB: BF F3    JNZ   0x2BAF
    2BBD: 62 D0 00 MOV   REG[208],0
    2BC0: 51 17    MOV   A,[__r4]
    2BC2: 54 06    MOV   [X+6],A
    2BC4: 51 16    MOV   A,[__r5]
    2BC6: 54 07    MOV   [X+7],A
    2BC8: 51 15    MOV   A,[__r6]
    2BCA: 54 08    MOV   [X+8],A
    2BCC: 51 14    MOV   A,[__r7]
    2BCE: 54 09    MOV   [X+9],A
    2BD0: 52 06    MOV   A,[X+6]
    2BD2: 08       PUSH  A
    2BD3: 52 07    MOV   A,[X+7]
    2BD5: 08       PUSH  A
    2BD6: 52 08    MOV   A,[X+8]
    2BD8: 08       PUSH  A
    2BD9: 52 09    MOV   A,[X+9]
    2BDB: 08       PUSH  A
    2BDC: 7C 24 6D LCALL __long2fp
    2BDF: 18       POP   A
    2BE0: 53 18    MOV   [__r3],A
    2BE2: 18       POP   A
    2BE3: 53 19    MOV   [__r2],A
    2BE5: 18       POP   A
    2BE6: 53 1A    MOV   [__r1],A
    2BE8: 18       POP   A
    2BE9: 08       PUSH  A
    2BEA: 51 1A    MOV   A,[__r1]
    2BEC: 08       PUSH  A
    2BED: 51 19    MOV   A,[__r2]
    2BEF: 08       PUSH  A
    2BF0: 51 18    MOV   A,[__r3]
    2BF2: 08       PUSH  A
    2BF3: 52 02    MOV   A,[X+2]
    2BF5: 08       PUSH  A
    2BF6: 52 03    MOV   A,[X+3]
    2BF8: 08       PUSH  A
    2BF9: 52 04    MOV   A,[X+4]
    2BFB: 08       PUSH  A
    2BFC: 52 05    MOV   A,[X+5]
    2BFE: 08       PUSH  A
    2BFF: 7C 21 9A LCALL __fpmul
    2C02: 18       POP   A
    2C03: 54 05    MOV   [X+5],A
    2C05: 18       POP   A
    2C06: 54 04    MOV   [X+4],A
    2C08: 18       POP   A
    2C09: 54 03    MOV   [X+3],A
    2C0B: 18       POP   A
    2C0C: 54 02    MOV   [X+2],A
    2C0E: 38 FC    ADD   SP,252
    2C10: 80 8D    JMP   0x2C9E
    2C12: 62 D0 00 MOV   REG[208],0
    2C15: 52 01    MOV   A,[X+1]
    2C17: 73       CPL   A
    2C18: 11 FF    SUB   A,255
    2C1A: 53 1A    MOV   [__r1],A
    2C1C: 52 00    MOV   A,[X+0]
    2C1E: 73       CPL   A
    2C1F: 19 FF    SBB   A,255
    2C21: 53 1B    MOV   [__r0],A
    2C23: 68 1B    ASR   [__r0]
    2C25: 6E 1A    RRC   [__r1]
    2C27: 52 06    MOV   A,[X+6]
    2C29: 53 17    MOV   [__r4],A
    2C2B: 52 07    MOV   A,[X+7]
    2C2D: 53 16    MOV   [__r5],A
    2C2F: 52 08    MOV   A,[X+8]
    2C31: 53 15    MOV   [__r6],A
    2C33: 52 09    MOV   A,[X+9]
    2C35: 53 14    MOV   [__r7],A
    2C37: 51 1A    MOV   A,[__r1]
    2C39: 21 1F    AND   A,31
    2C3B: A0 0F    JZ    0x2C4B
    2C3D: 62 D0 00 MOV   REG[208],0
    2C40: 65 14    ASL   [__r7]
    2C42: 6B 15    RLC   [__r6]
    2C44: 6B 16    RLC   [__r5]
    2C46: 6B 17    RLC   [__r4]
    2C48: 78       DEC   A
    2C49: BF F3    JNZ   0x2C3D
    2C4B: 62 D0 00 MOV   REG[208],0
    2C4E: 51 17    MOV   A,[__r4]
    2C50: 54 06    MOV   [X+6],A
    2C52: 51 16    MOV   A,[__r5]
    2C54: 54 07    MOV   [X+7],A
    2C56: 51 15    MOV   A,[__r6]
    2C58: 54 08    MOV   [X+8],A
    2C5A: 51 14    MOV   A,[__r7]
    2C5C: 54 09    MOV   [X+9],A
    2C5E: 52 06    MOV   A,[X+6]
    2C60: 08       PUSH  A
    2C61: 52 07    MOV   A,[X+7]
    2C63: 08       PUSH  A
    2C64: 52 08    MOV   A,[X+8]
    2C66: 08       PUSH  A
    2C67: 52 09    MOV   A,[X+9]
    2C69: 08       PUSH  A
    2C6A: 7C 24 6D LCALL __long2fp
    2C6D: 18       POP   A
    2C6E: 53 18    MOV   [__r3],A
    2C70: 18       POP   A
    2C71: 53 19    MOV   [__r2],A
    2C73: 18       POP   A
    2C74: 53 1A    MOV   [__r1],A
    2C76: 18       POP   A
    2C77: 08       PUSH  A
    2C78: 51 1A    MOV   A,[__r1]
    2C7A: 08       PUSH  A
    2C7B: 51 19    MOV   A,[__r2]
    2C7D: 08       PUSH  A
    2C7E: 51 18    MOV   A,[__r3]
    2C80: 08       PUSH  A
    2C81: 52 02    MOV   A,[X+2]
    2C83: 08       PUSH  A
    2C84: 52 03    MOV   A,[X+3]
    2C86: 08       PUSH  A
    2C87: 52 04    MOV   A,[X+4]
    2C89: 08       PUSH  A
    2C8A: 52 05    MOV   A,[X+5]
    2C8C: 08       PUSH  A
    2C8D: 7C 22 83 LCALL __fpdiv
    2C90: 18       POP   A
    2C91: 54 05    MOV   [X+5],A
    2C93: 18       POP   A
    2C94: 54 04    MOV   [X+4],A
    2C96: 18       POP   A
    2C97: 54 03    MOV   [X+3],A
    2C99: 18       POP   A
    2C9A: 54 02    MOV   [X+2],A
    2C9C: 38 FC    ADD   SP,252
    2C9E: 56 01 00 MOV   [X+1],0
    2CA1: 56 00 00 MOV   [X+0],0
    2CA4: 62 D0 00 MOV   REG[208],0
    2CA7: 52 02    MOV   A,[X+2]
    2CA9: 08       PUSH  A
    2CAA: 52 03    MOV   A,[X+3]
    2CAC: 08       PUSH  A
    2CAD: 52 04    MOV   A,[X+4]
    2CAF: 08       PUSH  A
    2CB0: 52 05    MOV   A,[X+5]
    2CB2: 08       PUSH  A
    2CB3: 52 F9    MOV   A,[X-7]
    2CB5: 08       PUSH  A
    2CB6: 52 FA    MOV   A,[X-6]
    2CB8: 08       PUSH  A
    2CB9: 52 FB    MOV   A,[X-5]
    2CBB: 08       PUSH  A
    2CBC: 52 FC    MOV   A,[X-4]
    2CBE: 08       PUSH  A
    2CBF: 7C 22 83 LCALL __fpdiv
    2CC2: 18       POP   A
    2CC3: 53 18    MOV   [__r3],A
    2CC5: 18       POP   A
    2CC6: 53 19    MOV   [__r2],A
    2CC8: 18       POP   A
    2CC9: 53 1A    MOV   [__r1],A
    2CCB: 18       POP   A
    2CCC: 53 1B    MOV   [__r0],A
    2CCE: 38 FC    ADD   SP,252
    2CD0: 52 02    MOV   A,[X+2]
    2CD2: 08       PUSH  A
    2CD3: 52 03    MOV   A,[X+3]
    2CD5: 08       PUSH  A
    2CD6: 52 04    MOV   A,[X+4]
    2CD8: 08       PUSH  A
    2CD9: 52 05    MOV   A,[X+5]
    2CDB: 08       PUSH  A
    2CDC: 51 1B    MOV   A,[__r0]
    2CDE: 08       PUSH  A
    2CDF: 51 1A    MOV   A,[__r1]
    2CE1: 08       PUSH  A
    2CE2: 51 19    MOV   A,[__r2]
    2CE4: 08       PUSH  A
    2CE5: 51 18    MOV   A,[__r3]
    2CE7: 08       PUSH  A
    2CE8: 7C 20 B6 LCALL __fpadd
    2CEB: 18       POP   A
    2CEC: 53 18    MOV   [__r3],A
    2CEE: 18       POP   A
    2CEF: 53 19    MOV   [__r2],A
    2CF1: 18       POP   A
    2CF2: 53 1A    MOV   [__r1],A
    2CF4: 18       POP   A
    2CF5: 38 FC    ADD   SP,252
    2CF7: 08       PUSH  A
    2CF8: 51 1A    MOV   A,[__r1]
    2CFA: 08       PUSH  A
    2CFB: 51 19    MOV   A,[__r2]
    2CFD: 08       PUSH  A
    2CFE: 51 18    MOV   A,[__r3]
    2D00: 08       PUSH  A
    2D01: 50 3F    MOV   A,63
    2D03: 08       PUSH  A
    2D04: 50 00    MOV   A,0
    2D06: 08       PUSH  A
    2D07: 08       PUSH  A
    2D08: 08       PUSH  A
    2D09: 7C 21 9A LCALL __fpmul
    2D0C: 18       POP   A
    2D0D: 54 05    MOV   [X+5],A
    2D0F: 18       POP   A
    2D10: 54 04    MOV   [X+4],A
    2D12: 18       POP   A
    2D13: 54 03    MOV   [X+3],A
    2D15: 18       POP   A
    2D16: 54 02    MOV   [X+2],A
    2D18: 38 FC    ADD   SP,252
    2D1A: 77 01    INC   [X+1]
    2D1C: 0F 00 00 ADC   [X+0],0
    2D1F: 52 01    MOV   A,[X+1]
    2D21: 11 02    SUB   A,2
    2D23: 52 00    MOV   A,[X+0]
    2D25: 31 80    XOR   A,128
    2D27: 19 80    SBB   A,128
    2D29: CF 7A    JC    0x2CA4
    2D2B: 62 D0 00 MOV   REG[208],0
    2D2E: 52 02    MOV   A,[X+2]
    2D30: 53 1B    MOV   [__r0],A
    2D32: 52 03    MOV   A,[X+3]
    2D34: 53 1A    MOV   [__r1],A
    2D36: 52 04    MOV   A,[X+4]
    2D38: 53 19    MOV   [__r2],A
    2D3A: 52 05    MOV   A,[X+5]
    2D3C: 53 18    MOV   [__r3],A
    2D3E: 38 F6    ADD   SP,246
    2D40: 20       POP   X
    2D41: 7F       RET   
--------------------------------------------------------------------------------


PSoC Designer Version: 4.2.1013.0

Copyright (C) 1994 - 2001 ImageCraft
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Code Compressor V1.09
ICCM8C version V1.56
