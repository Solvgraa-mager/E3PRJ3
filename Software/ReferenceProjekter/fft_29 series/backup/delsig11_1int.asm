;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: DELSIG11_1INT.asm
;;   Version: 3.2, Updated on 2005/10/05 at 11:41:06
;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
;;
;;  DESCRIPTION: Assembler interrupt service routine for the 11-bit Delta-
;;               Sigma A/D Converter User Module. This code works for both
;;               the first and second-order modulator topologies.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "DELSIG11_1.inc"


;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------

export _DELSIG11_1_ADConversion_ISR
export  DELSIG11_1_fState

IF (DELSIG11_1_POLL_ENABLE)
export _DELSIG11_1_iResult
export  DELSIG11_1_iResult
export _DELSIG11_1_bfStatus
export  DELSIG11_1_bfStatus
ENDIF


;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------
AREA InterruptRAM (RAM, REL, CON)

iOut:    BLK  2  ; Decimate by 7 bit answer
iTmp2:   BLK  2  ; z^-2
iTmp1:   BLK  2  ; z^-1
iAns:    BLK  2  ; Final answer calculated from  iOut + 2iOut(-1) + iOut(-2)

DELSIG11_1_fState: BLK 1   ; Current state

IF (DELSIG11_1_POLL_ENABLE)
_DELSIG11_1_iResult:
 DELSIG11_1_iResult:       BLK   2  ;A/D value
_DELSIG11_1_bfStatus:
 DELSIG11_1_bfStatus:      BLK   1  ;Data Valid Flag
ENDIF


;-----------------------------------------------
;  Private Symbols
;-----------------------------------------------
MSB:                   equ  0
LSB:                   equ  1


;@PSoC_UserCode_INIT@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom declarations below this banner
;---------------------------------------------------

;------------------------
; Includes
;------------------------

	
;------------------------
;  Constant Definitions
;------------------------


;------------------------
; Variable Allocation
;------------------------


;---------------------------------------------------
; Insert your custom declarations above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)


AREA UserModules (ROM, REL)

;;-----------------------------------------------------------------------------
;;  FUNCTION NAME: _DELSIG11_1_ADConversion_ISR:
;;
;;  DESCRIPTION:   Implements a state machine that takes data from the hardware
;;                 decimator and completes the calculation of a sinc^2 filter
;;                 to produce an 11-bit result.
;;-----------------------------------------------------------------------------
;;  
;;  state 1   calculate first half of iOut
;;  state 2   calculate rest of iOut, calculate middle of iAns
;;  state 3   calculate first half of iOut
;;  state 4   calculate rest of iOut, calculate rest of iAns and
;;              start of new iAns get this data.

_DELSIG11_1_ADConversion_ISR:
   inc   [DELSIG11_1_fState]           ; Advance to next state
   tst   [DELSIG11_1_fState], 01h
   jz    .State2_State4_Entry

   ; State 1 or State 3: calculate half of iOut
                     ;  Variables:       Out              Tmp2     Tmp1   Deci
                     ;  Initial state:   (x3-x2)-(x2-x1)  (x2-x1)  x1     x0

                                       ; Out = Tmp2
   mov   [iOut+LSB], [iTmp2+LSB]       ; Out              Tmp2     Tmp1   Deci
   mov   [iOut+MSB], [iTmp2+MSB]       ; (x2-x1)          (x2-x1)  x1     x0

                                       ; Tmp2 = Tmp1
   mov   [iTmp2+LSB], [iTmp1+LSB]      ; Out              Tmp2     Tmp1   Deci
   mov   [iTmp2+MSB], [iTmp1+MSB]      ; (x2-x1)          x1       x1     x0
   reti                                ; End of State 1 & State 3 process


.State2_State4_Entry:
   push  A           ;  Variables:       Out              Tmp2     Tmp1   Deci
                     ;  Initial state:   (x3-x2)-(x2-x1)  (x2-x1)  x1     x0

   mov   A, reg[DEC_DL]                ;
   mov   [iTmp1+LSB], A                ; Tmp1  = Deci
   sub   [iTmp2+LSB], A                ; Tmp2 -= Deci
   mov   A, reg[DEC_DH]                ;
   mov   [iTmp1+MSB], A                ; Out              Tmp2     Tmp1   Deci
   sbb   [iTmp2+MSB], A                ; (x2-x1)          x1-x0    x0     x0

   mov   A, [iTmp2+LSB]                ; --> Subtract Tmp2 from iOut:
   sub   [iOut+LSB], A                 ;
   mov   A, [iTmp2+MSB]                ; Out              Tmp2     Tmp1   Deci
   sbb   [iOut+MSB], A                 ; (x2-x1)-(x1-x0)  x1-x0    x0     x0

   tst [DELSIG11_1_fState], 04h
   jnz .State4_Continuation

   ; State 2: calculate the 'middle' of iAns
   ;
   mov   A, [iOut+LSB]
   add   [iAns+LSB], A
   mov   A, [iOut+MSB]
   adc   [iAns+MSB], A
   pop   A
   reti

   ; State4: calculate rest of iOut, calculate rest of iAns
   ;
.State4_Continuation:
   mov   [DELSIG11_1_fState], 0  ; Reset state machine for next cycle
   push  X

   asr   [iOut+MSB]                    ; iOut is always an even value, so divide
   rrc   [iOut+LSB]                    ;   by two to allow an extra bit of range

   mov A, [iOut+LSB]
   add [iAns+LSB], A
   mov A, [iOut+MSB]
   adc [iAns+MSB], A

IF DELSIG11_1_LEFTJUSTIFIED
   jc  .LessThanFullScale              ;
   cmp [iAns+MSB], 80h                 ; Is the value less than full scale?
   jnz .LessThanFullScale              ;    Yes, go set it up
   mov X, 7fh                          ;     No, Limit the value to plus full-scale
   mov A, ffh                          ;         range
   jmp   .ConversionReady

.LessThanFullScale:
   mov X, [iAns+MSB]                   ; Final result in [X,A]
   mov A, [iAns+LSB]                   ; Fall through to .ConversionReady
ENDIF

IF DELSIG11_1_RIGHTJUSTIFIED
   jc    .LessThanFullScale            ;
   cmp   [iAns+MSB], 80h               ; Is the value less than full scale?
   jnz   .LessThanFullScale            ;    Yes, go set it up
   mov   X, 03h                        ;     No, Limit the value to plus full-scale
   mov   A, ffh                        ;         range
   jmp   .ConversionReady

.LessThanFullScale:
   mov   A, [iAns+LSB]                 ; set up and shift the data...
   asr   [iAns+MSB]
   rrc   A
   asr   [iAns+MSB]
   rrc   A
   asr   [iAns+MSB]
   rrc   A
   asr   [iAns+MSB]
   rrc   A
   asr   [iAns+MSB]
   rrc   A
   mov   X, [iAns+MSB]
ENDIF

.ConversionReady:

   ;@PSoC_UserCode_BODY@ (Do not change this line.)
   ;---------------------------------------------------
   ; Insert your custom code below this banner
   ;---------------------------------------------------
   ;  data is now in X, A
   ;  This interrupt service routine has already
   ;  preserved the values of the A and X CPU registers
   ;  and will restore them before returning control...

IF (DELSIG11_1_POLL_ENABLE)
    mov [DELSIG11_1_iResult+LSB], A              ; Save result in iResult
    mov [DELSIG11_1_iResult+MSB], X
    mov [DELSIG11_1_bfStatus], DELSIG11_1_DATA_READY_BIT; Set valid data flag
ENDIF


   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

   mov [iAns+LSB], [iOut+LSB]         ;start next answer
   mov [iAns+MSB], [iOut+MSB]
   pop X
   pop A
   reti

; end of file DELSIG11_1INT.asm
